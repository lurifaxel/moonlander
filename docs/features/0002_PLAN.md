# Awesome Levels

Brief: Introduce multi-stage "awesome levels" where each terrain spans a much larger world than the viewport, features pronounced peaks and valleys, and hides the landing pad far enough away that players must explore to locate it.

1. `moonlander.html` (top-level constants & state)
   - Define a `levels` array describing several oversized maps (e.g., world width, terrain amplitude, pad offset, roughness seed) so we can rotate through distinct "awesome" layouts.
   - Track `currentLevelIndex`/`nextLevelIndex` and expose `terrain.width` so other systems know the expanded boundaries.

2. `moonlander.html` (`generateTerrain`)
   - Accept the active level config, set terrain `samples` using the provided world width and amplitude so the profile delivers dramatic peaks and valleys.
   - Ensure landing pad placement uses a level-specific offset (e.g., 60â€“80% across the world) plus local smoothing so it can end up off-screen from the starting point, forcing exploration.

3. `moonlander.html` (`resetGame`, success branch in `update`)
   - When a landing succeeds, advance to the next level and flag terrain regeneration on restart; initialize the first level on boot without advancing.
   - Start the lander near the world origin but clamp inside the expanded bounds; reset camera to the refreshed starting position after regeneration.

4. `moonlander.html` (`update` loop physics)
   - Replace horizontal wrap with boundary clamping that gently bounces or halts at the edge so larger maps remain traversable instead of looping.
   - Use terrain width when sampling `terrainY` for collisions and when casting thrust dust, guaranteeing correctness across the longer worlds.

5. `moonlander.html` (render helpers `drawTerrain`, `drawHUD`)
   - Iterate terrain drawing across the full world width (not just canvas width) so distant features render when the camera pans.
   - Surface the active level name in the HUD/debug overlay to hint that exploration is needed.
