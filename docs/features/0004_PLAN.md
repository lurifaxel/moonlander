# Feature 0004 - Bombs + Deformable Terrain

## Context
Implement support in `moonlander.html` so that "The ship should be able to drop bombs, that explode in 3 seconds, they blink faster and faster until they explode. Explosions deform the terrain. Spacebar is the button to drop bombs." This extends the existing single-file game loop with timed explosives and terrain sculpting.

## Target files
- `moonlander.html`: update input listeners, shared game-state variables, simulation/update loop, drawing routines, audio hooks, and terrain utilities to drive bomb drops, countdown visuals, explosion FX, and deformable ground.

## Technical plan
1. **Input + shared state wiring**
   - Extend `window.addEventListener('keydown'...)` / `keyup` (around `moonlander.html`:493-529) to map both `'Space'` and `' '` to `keys.Space`, prevent browser scrolling, and gate repeat firing so each discrete press drops at most one bomb while the game is active.
   - Add a `bombs` array and related tuning constants (fuse length, blink multipliers, explosion radius/depth caps, arming delay) alongside existing globals (`smoke`, `blastSmoke`, etc.) so the lifecycle ties into the main update/draw flow.
   - Create helper functions `canDropBomb()` and `dropBomb()` near other gameplay helpers; use the lander's base (reuse thrust nozzle math) to seed bomb position/velocity and stamp `fuseMs = 3000` plus arming delay, respecting `gameOver`/`landed` state.
   - Ensure `resetGame()` clears `bombs` and resets any blink timers so restarts do not retain armed explosives.
2. **Bomb physics & fuse countdown**
   - Introduce `updateBombs(dt)` that applies gravity, a light horizontal drag, and integrates velocity/position similar to debris but without bounce (clamp into terrain on contact); reuse `terrainY()` for ground collision tests so bombs settle on impact while the fuse keeps ticking.
   - Reduce each bomb's `fuseMs` by `dt`; derive a normalised `fuseRatio` (`fuseMs / FUSE_MS`) feeding both the blink rate and the explosion trigger when it reaches ≤0, and store `blinkPhase`/`blinkRate` on the bomb for rendering.
   - Guard against immediate self-detonation by skipping terrain deformation and collision checks until a short `armingDelay` expires or the bomb is a set distance away from the lander.
   - Remove detonated or out-of-bounds bombs from the array to avoid processing dead entries.
3. **Blink feedback that accelerates over time**
   - In `updateBombs`, drive `blinkPhase += blinkRate * dt` with `blinkRate = blinkBase + blinkAccel * (1 - fuseRatio)` so the flash frequency ramps up through the final seconds exactly as the prompt requires.
   - Add `drawBombs()` (invoked inside the world transform before `drawLander()`) that renders bombs as compact sprites with alternating bright/dim fills (e.g., `Math.sin(blinkPhase) > 0`), optionally layering a halo via gradients for visual clarity.
   - Append optional bomb telemetry to the debug overlay (`drawDebugOverlay`) showing active bomb count and nearest fuse timer to aid tuning while keeping the HUD concise.
4. **Explosion trigger and FX reuse**
   - When a bomb's `fuseMs` ≤ 0, call a new `explodeBomb(bomb)` helper that: (a) pushes lightweight debris/blast smoke using trimmed versions of `spawnExplosion()` particles, (b) calls `audio.playExplosion()` so bombs share the crash boom without toggling `gameOver`, and (c) records the blast radius/depth for terrain deformation.
   - Retain per-bomb flags so `explodeBomb` only runs once, even if `updateBombs` is iterated multiple times in the same frame.
   - Optionally give explosions a moderate impulse to nearby dust by reusing `blastSmoke` structures and tagging them with `source: 'bomb'` so existing renderer can tweak color/alpha if desired.
5. **Terrain deformation algorithm**
   - Implement `deformTerrainAt(x, radius, depth)` near the terrain helpers, operating directly on `terrain.samples`: convert the blast center to sample indices, compute each affected sample's distance to the blast center, and lower the height by `depth * falloff` (e.g., quadratic or cosine blend) while clamping to canvas limits.
   - After lowering heights, perform one or two smoothing passes (neighbor averaging) to soften hard edges and avoid rendering spikes; update `pad.y` if any pad samples changed or skip deformation inside pad bounds to keep the landing pad intact.
   - If the lander is within the blast radius, recompute its contact points immediately to keep it above the modified surface (e.g., nudge `lander.y` by the difference) so it doesn't embed in the newly carved crater.
6. **Integration & validation hooks**
   - Plug `updateBombs(dt)` into `update()` prior to terrain collision resolution so deformation is applied before checking lander contact; run `drawBombs()` in the render sequence between terrain and debris layers for correct depth ordering.
   - Respect `gameOver`/`landed` states when processing input and updates so bombs stop spawning after a crash/landing, and clear arrays in `resetGame()`.
   - Manually verify: tapping Space drops a bomb; it blinks faster approaching the 3-second fuse; the blast lowers the sampled terrain profile; subsequent `terrainY()` queries reflect the new crater; the pad/landing detection still works post-deformation.

## Validation
- Browser playtest covering bomb drops while flying and while landed, countdown cadence, blast visuals, and crater formation.
- Confirm existing crash/landing flows still resolve correctly with modified terrain samples and that resets purge active bombs.
