# Feature 0009 - Headless & Browser Test Harness

## Context
Add test coverage for the Moonlander game so we can "verify functionality" without introducing new build steps or third-party libraries. The suite must run both in a browser (manual open) and via CLI to keep the current lightweight workflow intact.

## Target files & touch points
- `index.html`: extract deterministic game logic (terrain generation, physics update loop, state transitions) into a reusable module and wire the page to the new entry point without breaking existing gameplay.
- `src/game-core.js` (new): host all shared game-state structures, pure helpers, and a toggle for rendering/audio hooks so tests can exercise logic headlessly.
- `tests/index.html` (new): lightweight browser runner that imports the module, registers test cases, and renders pass/fail output into the DOM.
- `tests/run.js` (new): Node-based CLI runner that imports the same module with built-in `assert`, aggregates results, and exits non-zero on failure.
- `README.md`: document how to open the browser harness and run the CLI script.
- `CHANGELOG.md`: note the addition of the dual-mode test harness once implemented.

## Technical plan
1. **Modularize core logic**
   - Move the lander state machine, terrain grid helpers (`generateTerrain`, `findSurfaceBelow`, `resolvePenetrationAt`, `update`, etc.), and editor-safe cloning routines from `index.html` into `src/game-core.js` as exported functions and factory helpers.
   - Accept dependency injection hooks (e.g., rendering, audio) so the browser build can plug them in while tests can omit them for headless execution.
   - Provide a deterministic RNG option (seedable wrapper around `Math.random`) surfaced through module config so automated tests yield stable results.

2. **Refactor browser entry point**
   - Replace direct inline `function` definitions in `index.html` with imports from the new module via `<script type="module">`, instantiating the game with browser hooks (canvas drawing, audio) and preserving existing behavior.
   - Ensure editor/test mode transitions keep working by delegating to the moduleâ€™s APIs, passing callbacks for UI updates.

3. **Implement browser test harness**
   - Create `tests/index.html` that loads the module, defines a minimal `test(name, fn)` utility, and runs focused test cases covering terrain generation, collision helpers, physics outcomes, and state transitions.
   - Render a summary table (passed/failed assertions, stack traces on failure) so contributors can visually confirm results when opening the page.

4. **Implement CLI test harness**
   - Add `tests/run.js` using only built-in Node modules (`assert`, `fs/path` if needed). Mirror the browser test cases by requiring/importing the module, executing them sequentially, and printing a concise report.
   - Document expected invocation (`node tests/run.js`) and ensure the script exits with status `1` on any failure so it can plug into future automation.

5. **Author test cases**
   - Validate terrain generation keeps the landing pad flat, stays within bounds, and respects a seed by running `generateTerrain` with a fixed RNG.
   - Check collision helpers (`findSurfaceBelow`, `resolvePenetrationAt`) against handcrafted grids to confirm normals and penetration depth.
   - Simulate physics ticks via `update(dt)` verifying thrust integrates velocity, fuel drains during burns, and landing/crash flags flip at thresholds.
   - Cover game state transitions (`enterPlay`, `resetGame`, editor baseline cloning) to ensure regression protection when refactoring.

6. **Docs & verification**
   - Update `README.md` with step-by-step usage for both harnesses (open `tests/index.html` in a browser, run `node tests/run.js`).
   - Note the new testing capability in `CHANGELOG.md` once implementation ships.

## Notes
- Remember to add the feature to `CHANGELOG.md` after implementation.
