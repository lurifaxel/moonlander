# Mobile touch controls overlay

## Overview
Implement on-screen controls so the existing Moon Lander browser game is fully playable on mobile touch devices, matching the user's request for "controls so that the game is playable on mobile devices (still in the browser)." The current input system (keyboard-driven arrow keys plus the space bar for bombs) must gain a responsive touch-first interface that mirrors those actions without breaking desktop play.

## Relevant files & systems
- `index.html`
  - CSS rules that define layout (top of file) need updates to accommodate a mobile HUD without hiding the canvas.
  - The main script declares input state via the `keys` map and listens for `keydown` / `keyup` events (~lines 1275-1365) and uses that state in `update()` (~lines 2540-2845) to adjust thrust, rotation, and bombs. Touch handlers should integrate with this structure.
  - Menu logic (`enterMenu`, `enterPlay`, etc.) should drive when controls are visible; start menu overlays currently occupy the whole viewport.
- `docs/CHANGELOG.md` (not currently present) or `CHANGELOG.md` at repo root must gain an entry summarizing the new mobile control overlay.

## Implementation plan
1. **Detect touch-friendly environments**
   - Add a helper that checks `window.matchMedia('(pointer: coarse)')` and touch events to decide when to show the mobile HUD. Allow users to force controls on via UI (e.g., toggle button) in case they connect a keyboard to a touch device.
   - Hook this detection into the existing resize / setup logic so the canvas size and layout respond when controls appear.

2. **Create mobile control UI scaffold**
   - Introduce a new `<div id="touchControls">` sibling of the canvas that contains buttons for rotation, thrust, and bomb. Use semantic button elements with visually hidden labels for accessibility.
   - Lay out controls into two clusters: left/right rotation buttons on one side and a vertical stack for thrust + bomb on the other. CSS must position them near the bottom of the viewport with adequate touch targets (>48px) and ensure they do not overlap the start menu or editor overlays.
   - Ensure the overlay remains hidden on desktop-sized pointer environments and fades in/out with transitions to avoid jarring changes.

3. **Wire touch / pointer events into the existing key state**
   - For each virtual button, register `pointerdown`, `pointerup`, `pointercancel`, and `pointerleave` handlers. When pressed, set the appropriate entry in the `keys` map (`ArrowLeft`, `ArrowRight`, `ArrowUp`). When released, clear it.
   - For the bomb action, instead of holding a key, trigger the same logic used for the space bar: set `keys.Space` and invoke `dropBomb()` after checking `canDropBomb()`. Maintain cooldown logic identical to keyboard play.
   - Support multitouch so players can thrust while rotating. Use `event.pointerId` tracking to handle simultaneous presses without interference, and call `setPointerCapture` to keep state while fingers move.

4. **Synchronize HUD visibility with game modes**
   - Show the control overlay only during `APP_MODE.PLAY` and `APP_MODE.TEST` to avoid conflicting with the editor painting gestures. Hide it in menu/editor states by toggling a class when `enterPlay`, `enterEditor`, `enterMenu`, etc., run.
   - Ensure game reset / level transitions do not leave lingering `keys` states by clearing both keyboard and touch-simulated keys when the overlay hides.

5. **Update layout / resize logic**
   - Adjust any canvas sizing code so the play area leaves room for the on-screen controls on small screens (e.g., reduce maximum canvas width/height or add bottom padding). Verify the camera scaling still matches `TARGET_ASPECT` while keeping controls accessible.
   - Confirm info overlays (`#info`, `#editorPanel`) remain readable on small screens; reposition as needed to avoid obstruction by the HUD.

6. **Document and test**
   - Add a `CHANGELOG.md` entry describing the mobile control support.
   - Manually test on desktop browsers (with device emulation) to ensure pointer + keyboard both work, the controls do not appear unnecessarily, multitouch works, and the bomb button respects cooldowns.

## Notes
- Keep the implementation keyboard-compatible; do not remove existing event listeners.
- Consider future extensibility (e.g., haptic feedback) by encapsulating the touch control wiring in reusable functions.
- Remember to update `CHANGELOG.md` once the feature is built.
