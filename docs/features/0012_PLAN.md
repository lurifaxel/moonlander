# Feature 0012 - Persistent Level Catalog & Timing

## Context
Implement persistent level storage and timing so players can enter their name, pick from procedurally generated or saved levels, record completion times, and save new levels from the editor. Levels and best times must live on disk in human-readable files inside the repo, with the game loading them automatically on startup and exposing a Save Level action in the editor menu.

## Target files & touch points
- `index.html`
  - Introduce state for player identity, runtime timers, and the in-memory catalog of loaded levels.
  - Replace the static `levels` array with data fetched from disk (`/api/levels`) while keeping compatibility with procedural generation via `generateTerrain(...)`.
  - Extend menu DOM (start menu + editor menu panel) to gather the player name, provide "Generate Level"/"Select Level" flows, list stored levels, and expose a "Save Level" action tied to the editor menu button flow.
  - Update gameplay flow (`enterMenu()`, `enterPlay()`, `resetGame()`, landing logic in the collision handler, `drawHUD()`) to start/stop a level timer, show the elapsed time, and persist best times for the current player/level.
  - Add fetch helpers to load/save level descriptors and best times via the new API, wiring editor save operations to serialize the current terrain/objects into the agreed human-readable format.
- `server.js` (new): lightweight Node/Express server to serve the static game and expose REST endpoints for reading/writing level JSON and best-time files.
- `package.json` / `package-lock.json` (new or updated): declare server dependencies (`express`, etc.) and scripts for running the dev server.
- `data/levels/` (new directory)
  - `index.json`: catalog of level metadata (id, name, createdBy, lastModified) to drive the "Select Level" menu.
  - `*.json`: individual level descriptors in the human-readable format exported by the editor (terrain, landing pad, spawn, black holes, meteors, brush params).
- `data/best-times.json` (new): JSON map of `{ levelId: { playerName: bestTimeMs } }` persisted by the server.
- `CHANGELOG.md`: note the addition of the timer, player profiles, persistent levels, and best times.

## Technical plan
1. **Define human-readable level & score formats**
   - Adopt JSON for level files: include `id`, `name`, `description` (optional), `world` settings (`worldWidth`, `cellSize`, noise/amp config mirroring the existing procedural fields), `spawn`, `pad`, and `terrain` as an array of strings (`.` = empty, `#` = solid) representing rows of the solid grid so editors can diff the layout. Include arrays for `blackHoles` and `meteors` using the same keys currently stored in `editorState` (clamping via `cloneBlackHoles()`/`cloneMeteors()`).
   - Specify that `data/levels/index.json` contains an array of `{ id, name, createdBy, updatedAt }` that the menu uses for listings; on save, append or update the entry.
   - Define `data/best-times.json` as `{ [levelId]: { [playerName]: bestTimeMs } }` so the HUD can show the player's personal record and optionally the global best.

2. **Add filesystem-backed API**
   - Create `server.js` that:
     - Serves `index.html` and static assets.
     - Implements `GET /api/levels` (read `data/levels/index.json`), `GET /api/levels/:id` (read `data/levels/<id>.json`), `POST /api/levels` (write new/updated level file, update catalog), and `GET/POST /api/best-times` (read/update `data/best-times.json`).
     - Validates request payloads to ensure terrain arrays match expected dimensions and clamp meteor/black hole fields using the same limits as the front-end helpers.
     - Automatically generates safe file names (e.g., slugified level names) and timestamps for `index.json` entries so the client never needs to pick a path.
   - Introduce a basic `package.json` with a `start` script launching the server (and include dependency installation instructions if not already present).

3. **Load persistent data on startup**
   - Refactor `index.html` to wrap the game bootstrap in an async `init()` that fetches `GET /api/levels` and `GET /api/best-times` before enabling menu buttons. Keep a fallback list by reusing one of the existing procedural level seeds if the API returns empty.
   - Replace the global `levels` array with `levelCatalog` (metadata) and a `loadedLevels` map keyed by id; update `generateTerrain()` to accept a level descriptor instead of reading from the old array, pulling default parameters when fields are missing.
   - Cache best-time data in a `bestTimes` object; expose helpers like `getPlayerBest(levelId, playerName)` and `updateBestTime(levelId, playerName, timeMs)` that also `fetch('/api/best-times', { method: 'POST', ... })`.

4. **Revise menu & player onboarding**
   - In the start menu DOM, replace the simple Play/Create buttons with:
     - A required text input for the player name (persist to `localStorage` for convenience) and validation message.
     - Buttons for "Generate Level" (procedural run) and "Select Level" (opens a modal/list within the menu showing entries from `levelCatalog`).
   - Implement `handleGenerateLevel()` to roll a procedural seed (reuse existing randomization logic but record a transient descriptor with `id = 'proc-<timestamp>'`) and call `enterPlay()` with that descriptor.
   - Implement `handleSelectLevel()` to populate a scrollable list of saved levels (use metadata and optionally best times) and load the chosen descriptor via `GET /api/levels/:id` before starting play.
   - Ensure `enterMenu()` resets UI state (closes selection lists, ensures name input is visible) and hides the canvas overlay buttons until the name is set.

5. **Integrate timers & best times into gameplay**
   - Add state (`currentPlayer`, `activeLevelId`, `levelStartTime`, `elapsedMs`, `timerActive`) initialised in `enterPlay()` / `resetGame()`; `resetGame()` should mark the start time when a run begins (skip when regenerating after death to keep the timer consistent per attempt).
   - In the main loop (`update(dt)`), increment `elapsedMs` only during active gameplay (`timerActive` and not `gameOver`).
   - Enhance `drawHUD()` to show `Elapsed: <mm:ss.ms>` and, when available, `Best: <mm:ss.ms>` for the current player/level.
   - When the lander lands successfully (`landed = true` block), compute the run duration, compare to stored best, and call the save helper to persist updates (including posting to `/api/best-times`). Include the player's name in the victory message.

6. **Editor "Save Level" flow**
   - Extend the editor panel menu (where the forthcoming menu button hook will dispatch) to expose a Save Level dialog: prompt for level name (default to existing descriptor or timestamp) and optional description.
   - Serialize the editor state by:
     - Grabbing `terrain.solids`, `terrain.cols`, `terrain.rows`, and converting to the array-of-strings format described earlier.
     - Reading `editorState.spawn`, landing pad data (`pad`), `editorState.blackHoles`, and `editorState.meteors` (cloned via existing helpers) into the JSON structure.
   - POST the JSON to `/api/levels`; on success, refresh the `levelCatalog` in memory so the new level appears in the Select list without a reload.
   - Handle errors (display toast/message via `info` or panel) and disable the Save option while the request is pending to avoid duplicates.

7. **Housekeeping**
   - Update any documentation (README or developer notes) if necessary to explain running the new server, and ensure `CHANGELOG.md` records the timer, player name entry, level persistence, and best-time tracking.

## Notes
- Remember to add the feature to `CHANGELOG.md` after implementation.
