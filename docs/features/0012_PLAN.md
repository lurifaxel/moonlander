# Feature 0012 - Persistent Level Catalog & Timing

## Context
Implement persistent level storage and timing so players can enter their name, pick from procedurally generated or saved levels,
 record completion times, and save new levels from the editor. Levels and best times must live in human-readable JSON that ships with the repo while new saves persist in-browser via `localStorage`, keeping everything inside the existing single-page `index.html` without introducing build tooling or server dependencies. The current front-end is a single-page `index.html` file with large in-memory state (`levels`, `generateTerrain()`, `enterPlay()`, `resetGame()`, etc.), so the work must extend that monolith rather than introducing new modules.
## Target files & touch points
- `index.html`
  - Introduce global state for player identity, runtime timers, and the in-memory catalog of loaded levels while staying inside the existing IIFE.
  - Replace the static `levels` array used by `generateTerrain()` and level cycling with data sourced from bundled JSON (`data/levels/*.json`) plus a procedural descriptor for ad-hoc runs.
  - Extend menu DOM (start menu + editor overlay) to gather the player name, provide "Generate Level"/"Select Level" flows, list stored levels, and expose a "Save Level" action triggered from the editor overlay once the other branch wires its menu button.
  - Update gameplay flow (`enterMenu()`, `enterPlay()`, `resetGame()`, landing handling in `resolveLanderTerrainCollisions()`, and `drawHUD()`) to start/stop a level timer, show the elapsed time, and persist best times for the current player/level.
  - Add helpers to hydrate bundled JSON, merge it with locally saved levels/best times (kept in `localStorage`), and serialize the current terrain/objects into the agreed human-readable format.
- `data/levels/` (directory co-located with the front-end so files commit cleanly)
  - `index.json`: catalog of level metadata (id, name, createdBy, lastModified) to drive the "Select Level" menu.
  - `*.json`: individual level descriptors in the human-readable format exported by the editor (terrain, landing pad, spawn, black holes, meteors, brush params).
- `data/best-times.json`: baseline JSON map of `{ levelId: { playerName: bestTimeMs } }` merged into the client cache at startup.
- `CHANGELOG.md`: note the addition of the timer, player profiles, persistent levels, and best times.

## Technical plan
1. **Define human-readable level & score formats**
   - Adopt JSON for level files: include `id`, `name`, `description` (optional), `world` settings (`worldWidth`, `cellSize`, noise/amp config mirroring the existing procedural fields), `spawn`, `pad`, and `terrain` as an array of strings (`.` = empty, `#` = solid) representing rows of the solid grid so editors can diff the layout. Include arrays for `blackHoles` and `meteors` using the same keys currently stored in `editorState` (reusing `cloneBlackHoles()`/`cloneMeteors()` limits).
   - Specify that `data/levels/index.json` contains an array of `{ id, name, createdBy, updatedAt }` that the menu uses for listings; on save, append or update the entry.
   - Define `data/best-times.json` as `{ [levelId]: { [playerName]: bestTimeMs } }` so the HUD can show the player's personal record and optionally the global best.

2. **Bootstrap data on startup**
   - Wrap the game bootstrap in an async `init()` that fetches bundled JSON (`data/levels/index.json`, `data/best-times.json`) and merges the results with anything stored in `localStorage` (`moonlander.customLevels`, `moonlander.bestTimes`).
   - Replace the global `levels` array with `levelCatalog` (metadata) and a `loadedLevels` map keyed by id; update `generateTerrain()` so it can draw from either a stored descriptor (with explicit `terrain` rows) or the existing procedural seed structure.
   - Cache best-time data in a `bestTimes` object; expose helpers like `getPlayerBest(levelId, playerName)` and `updateBestTime(levelId, playerName, timeMs)` that also persist to `localStorage`.

3. **Revise menu & player onboarding**
   - In the start menu DOM, replace the simple Play/Create buttons with:
     - A required text input for the player name (persist to `localStorage` for convenience) and validation message.
     - Buttons for "Generate Level" (procedural run) and "Select Level" (opens a modal/list within the menu showing entries from `levelCatalog`).
   - Implement `handleGenerateLevel()` to roll a procedural seed (reuse existing randomization logic but record a transient descriptor with `id = 'proc-<timestamp>'`) and call `enterPlay()` with that descriptor.
  - Implement `handleSelectLevel()` to populate a scrollable list of saved levels (use metadata and optionally best times) and load the chosen descriptor from local caches or bundled JSON before starting play.
   - Ensure `enterMenu()` resets UI state (closes selection lists, ensures name input is visible) and hides the canvas overlay buttons until the name is set.

4. **Integrate timers & best times into gameplay**
   - Add state (`currentPlayer`, `activeLevelId`, `levelStartTime`, `elapsedMs`, `timerActive`) initialised in `enterPlay()` / `resetGame()`; `resetGame()` should mark the start time when a run begins (skip when regenerating after death to keep the timer consistent per attempt).
   - In the main loop (`update(dt)`), increment `elapsedMs` only during active gameplay (`timerActive` and not `gameOver`).
   - Enhance `drawHUD()` to show `Elapsed: <mm:ss.ms>` and, when available, `Best: <mm:ss.ms>` for the current player/level.
   - When the lander lands successfully (`landed = true` block), compute the run duration, compare to stored best, and call the save helper to persist updates back into `localStorage`. Include the player's name in the victory message.

5. **Editor "Save Level" flow**
   - Extend the editor panel menu (where the forthcoming menu button hook will dispatch) to expose a Save Level dialog: prompt for level name (default to existing descriptor or timestamp) and optional description.
   - Serialize the editor state by:
     - Grabbing `terrain.solids`, `terrain.cols`, `terrain.rows`, and converting to the array-of-strings format described earlier.
     - Reading `editorState.spawn`, landing pad data (`pad`), `editorState.blackHoles`, and `editorState.meteors` (cloned via existing helpers) into the JSON structure.
   - Persist the descriptor into the `localStorage` collection, generating an id when needed and updating the in-memory catalog so the new level appears immediately.
   - Offer a JSON download option so advanced users can copy the file back into `data/levels/` manually if they need to commit it.

6. **Housekeeping**
   - Update any documentation (README or developer notes) if necessary to explain how bundled data is merged with local saves, and ensure `CHANGELOG.md` records the timer, player name entry, level persistence, and best-time tracking.

## Notes
- Remember to add the feature to `CHANGELOG.md` after implementation.
