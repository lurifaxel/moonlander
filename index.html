<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Moon Lander Game</title>
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      background: #101420;
      color: #fafafa;
      font-family: sans-serif;
      height: 100%;
    }
    body {
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      align-items: center;
      min-height: 100vh;
      overflow: hidden;
      position: relative;
    }
    #gameCanvas {
      display: block;
      background: transparent;
      flex-shrink: 0;
      touch-action: none;
    }
    #gameShell {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
      max-width: 100vw;
    }
    #touchControls {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      justify-content: center;
      padding: 12px 16px calc(12px + env(safe-area-inset-bottom));
      pointer-events: none;
      opacity: 0;
      transform: translateY(12px);
      transition: opacity 0.2s ease, transform 0.2s ease;
      z-index: 6;
      background: rgba(0, 0, 0, 0.9);
      box-shadow: 0 -10px 32px rgba(0, 0, 0, 0.6);
    }
    #touchControls.visible {
      opacity: 1;
      transform: translateY(0);
      pointer-events: auto;
    }
    #touchControls .touch-row {
      display: flex;
      align-items: flex-end;
      justify-content: space-between;
      gap: 16px;
      pointer-events: none;
      width: 100%;
      max-width: 720px;
    }
    #touchControls .touch-row > * {
      pointer-events: auto;
    }
    #touchControls .touch-cluster {
      display: flex;
      align-items: center;
      gap: 14px;
    }
    #touchControls .touch-cluster.action {
      gap: 14px;
    }
    #touchControls button {
      pointer-events: auto;
      cursor: pointer;
      touch-action: manipulation;
      border: 2px solid rgba(255, 255, 255, 0.32);
      background: rgba(18, 26, 40, 0.35);
      color: #f5f8ff;
      font-size: 11px;
      font-weight: 600;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      min-width: 64px;
      min-height: 64px;
      border-radius: 18px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 10px 14px;
      transition: transform 0.12s ease, background 0.15s ease, border-color 0.15s ease;
      box-shadow: 0 4px 18px rgba(0, 0, 0, 0.4);
      line-height: 1;
    }
    #touchControls button:active,
    #touchControls button.is-pressed {
      transform: scale(0.95);
      background: rgba(28, 38, 56, 0.78);
      border-color: rgba(255, 255, 255, 0.6);
    }
    #touchControls .menu-button {
      min-width: 56px;
      min-height: 52px;
      border-radius: 999px;
      font-size: 9px;
      letter-spacing: 0.16em;
      padding: 8px 14px;
    }
    #touchControls .action button {
      min-width: 72px;
      min-height: 72px;
      border-radius: 999px;
    }
    .touch-cluster.rotate {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .touch-cluster.rotate button {
      min-width: 64px;
      min-height: 64px;
      border-radius: 16px;
      padding: 0;
      position: relative;
      background: rgba(18, 26, 40, 0.35);
    }
    .touch-cluster.rotate button::after {
      content: '';
      position: absolute;
      left: 50%;
      top: 50%;
      width: 0;
      height: 0;
      transform: translate(-50%, -50%);
      border-top: 12px solid transparent;
      border-bottom: 12px solid transparent;
    }
    .touch-cluster.rotate button.left::after {
      border-right: 18px solid rgba(255, 255, 255, 0.7);
      margin-left: -4px;
    }
    .touch-cluster.rotate button.right::after {
      border-left: 18px solid rgba(255, 255, 255, 0.7);
      margin-left: 4px;
    }
    .touch-cluster.rotate button.left.is-pressed::after,
    .touch-cluster.rotate button.left:active::after {
      border-right-color: rgba(255, 255, 255, 0.95);
    }
    .touch-cluster.rotate button.right.is-pressed::after,
    .touch-cluster.rotate button.right:active::after {
      border-left-color: rgba(255, 255, 255, 0.95);
    }
    #editorToolBar {
      position: fixed;
      left: 50%;
      bottom: calc(16px + env(safe-area-inset-bottom));
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      padding: 10px 14px;
      border-radius: 999px;
      background: rgba(10, 16, 26, 0.75);
      border: 1px solid rgba(143, 223, 255, 0.35);
      box-shadow: 0 18px 48px rgba(0, 0, 0, 0.45);
      pointer-events: none;
      z-index: 7;
      backdrop-filter: blur(6px);
    }
    #editorToolBar button {
      pointer-events: auto;
      width: 42px;
      height: 42px;
      border-radius: 12px;
      border: 1px solid rgba(143, 223, 255, 0.35);
      background: rgba(18, 26, 40, 0.35);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      cursor: pointer;
      transition: transform 0.12s ease, background 0.15s ease, border-color 0.15s ease;
    }
    #editorToolBar button:hover,
    #editorToolBar button:focus-visible {
      transform: translateY(-1px);
      border-color: rgba(143, 223, 255, 0.7);
      background: rgba(20, 28, 40, 0.55);
      outline: none;
    }
    #editorToolBar button[aria-pressed='true'] {
      border-color: rgba(143, 223, 255, 0.85);
      background: rgba(24, 32, 48, 0.68);
    }
    #editorToolBar button:focus-visible {
      outline: 2px solid rgba(143, 223, 255, 0.9);
      outline-offset: 2px;
    }
    #editorToolBar .tool-icon {
      position: relative;
      width: 24px;
      height: 24px;
    }
    #editorToolBar .tool-icon::before,
    #editorToolBar .tool-icon::after {
      content: '';
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
    }
    #editorToolBar .tool-icon.spawn::before {
      top: 32%;
      transform: translate(-50%, -50%);
      width: 0;
      height: 0;
      border-left: 8px solid transparent;
      border-right: 8px solid transparent;
      border-bottom: 14px solid rgba(143, 223, 255, 0.85);
    }
    #editorToolBar .tool-icon.spawn::after {
      top: 68%;
      width: 12px;
      height: 6px;
      border-radius: 3px;
      background: rgba(143, 223, 255, 0.85);
    }
    #editorToolBar .tool-icon.landing::before {
      width: 18px;
      height: 6px;
      border-radius: 3px;
      background: rgba(255, 214, 160, 0.85);
      top: 70%;
    }
    #editorToolBar .tool-icon.landing::after {
      width: 12px;
      height: 12px;
      border: 2px solid rgba(255, 214, 160, 0.85);
      border-radius: 3px;
      top: 38%;
    }
    #editorToolBar .tool-icon.terrain::before {
      width: 18px;
      height: 12px;
      clip-path: polygon(0% 100%, 25% 40%, 45% 70%, 70% 20%, 100% 100%);
      background: rgba(147, 255, 195, 0.85);
      top: 58%;
    }
    #editorToolBar .tool-icon.terrain::after {
      display: none;
    }
    #editorToolBar .tool-icon.blackHole::before {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      border: 3px solid rgba(200, 180, 255, 0.85);
    }
    #editorToolBar .tool-icon.blackHole::after {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: rgba(200, 180, 255, 0.85);
    }
    #editorToolBar .tool-icon.meteor::before {
      width: 18px;
      height: 4px;
      background: linear-gradient(90deg, rgba(255, 140, 60, 0) 0%, rgba(255, 200, 120, 0.85) 60%, rgba(255, 240, 200, 0.95) 100%);
      transform: translate(-50%, -50%) rotate(-35deg);
      border-radius: 2px;
    }
    #editorToolBar .tool-icon.meteor::after {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: rgba(255, 200, 120, 0.95);
      transform: translate(-50%, -50%) rotate(-35deg);
    }
    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }
    #touchToggle {
      position: absolute;
      top: 12px;
      right: 12px;
      padding: 8px 14px;
      border: 1px solid rgba(255, 255, 255, 0.35);
      border-radius: 999px;
      background: rgba(15, 25, 45, 0.7);
      color: #f0f6ff;
      font-size: 12px;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      cursor: pointer;
      z-index: 11;
      transition: background 0.15s ease, border-color 0.15s ease;
    }
    #touchToggle:focus-visible {
      outline: 2px solid #8fdfff;
      outline-offset: 2px;
    }
    #touchToggle.toggle-hidden {
      display: none;
    }
    #info {
      position: absolute;
      top: 12px;
      left: 12px;
      color: #f0f6ff;
      font-size: 13px;
      pointer-events: auto;
      background: rgba(10, 16, 28, 0.82);
      border: 1px solid rgba(255, 255, 255, 0.14);
      border-radius: 12px;
      padding: 10px 12px;
      max-width: min(320px, calc(100vw - 24px));
      box-shadow: 0 14px 34px rgba(0, 0, 0, 0.38);
      backdrop-filter: blur(8px);
      display: flex;
      flex-direction: column;
      gap: 8px;
      z-index: 8;
    }
    #info.hidden {
      display: none !important;
    }
    #info .info-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }
    #info .info-title {
      font-size: 11px;
      font-weight: 600;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      opacity: 0.72;
    }
    #info .info-toggle {
      pointer-events: auto;
      cursor: pointer;
      border: 1px solid rgba(255, 255, 255, 0.25);
      background: rgba(18, 26, 40, 0.65);
      color: #f0f6ff;
      border-radius: 999px;
      font-size: 11px;
      letter-spacing: 0.08em;
      padding: 4px 12px;
      text-transform: uppercase;
      transition: border-color 0.15s ease, background 0.15s ease;
    }
    #info .info-toggle:focus-visible {
      outline: 2px solid #8fdfff;
      outline-offset: 2px;
    }
    #info .info-toggle:hover,
    #info .info-toggle:active {
      border-color: rgba(255, 255, 255, 0.45);
      background: rgba(22, 32, 50, 0.8);
    }
    #info .info-body {
      line-height: 1.45;
      pointer-events: none;
      font-size: 13px;
    }
    #info.collapsed .info-body {
      display: none;
    }
    #info.collapsed {
      padding-bottom: 8px;
    }
    #info.debug-hidden {
      visibility: hidden;
    }
    .hidden {
      display: none !important;
    }
    .menu-overlay {
      position: absolute;
      inset: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      text-align: center;
      padding: 32px 16px;
      z-index: 10;
    }
    #startMenu {
      background: rgba(16, 20, 32, 0.92);
    }
    #postLevelMenu {
      background: none;
      padding: 24px 16px calc(24px + env(safe-area-inset-bottom));
    }
    .menu-panel {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 18px;
      width: min(320px, 100%);
    }
    #startMenu .menu-panel {
      background: rgba(8, 12, 20, 0.85);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 20px;
      padding: 32px 28px;
      box-shadow: 0 18px 48px rgba(0, 0, 0, 0.45);
    }
    #postLevelMenu .menu-panel {
      background: rgba(8, 12, 20, 0.82);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 18px;
      padding: 24px 24px;
      box-shadow: 0 18px 38px rgba(0, 0, 0, 0.4);
    }
    #startMenu h1 {
      margin: 0;
      font-size: 28px;
      letter-spacing: 1px;
    }
    #postLevelMenu h2 {
      margin: 0;
      font-size: 24px;
      letter-spacing: 1px;
      text-transform: uppercase;
    }
    #postLevelMenu p {
      margin: 0;
      font-size: 15px;
      line-height: 1.5;
      color: rgba(255, 255, 255, 0.82);
    }
    .menu-actions {
      display: flex;
      flex-direction: column;
      gap: 12px;
      width: 100%;
    }
    .menu-actions button {
      width: 100%;
      padding: 12px 18px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.35);
      background: rgba(15, 22, 36, 0.7);
      color: #f1f5ff;
      font-size: 15px;
      font-weight: 600;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      cursor: pointer;
      transition: background 0.15s ease, border-color 0.15s ease, transform 0.12s ease;
    }
    .menu-actions button:hover,
    .menu-actions button:focus-visible {
      transform: translateY(-1px);
      border-color: rgba(255, 255, 255, 0.6);
      background: rgba(24, 34, 52, 0.85);
      outline: none;
    }
    .menu-actions button.secondary {
      border-color: rgba(143, 223, 255, 0.45);
    }
    .menu-actions button.secondary:hover,
    .menu-actions button.secondary:focus-visible {
      border-color: rgba(143, 223, 255, 0.7);
      background: rgba(26, 36, 54, 0.9);
    }
    #editorPanel {
      position: absolute;
      top: 12px;
      right: 12px;
      max-width: 280px;
      padding: 12px 16px;
      border-radius: 8px;
      background: rgba(0, 0, 0, 0.65);
      color: #f0f6ff;
      font-size: 13px;
      line-height: 1.5;
      z-index: 6;
      pointer-events: auto;
      text-align: left;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    #editorPanel.collapsed {
      padding-bottom: 10px;
    }
    #editorPanel.collapsed .editor-panel-body {
      display: none;
    }
    #editorPanel .editor-panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }
    #editorPanel .editor-panel-title {
      font-size: 11px;
      font-weight: 600;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      opacity: 0.72;
    }
    #editorPanel .editor-panel-toggle {
      pointer-events: auto;
      cursor: pointer;
      border: 1px solid rgba(255, 255, 255, 0.25);
      background: rgba(18, 26, 40, 0.65);
      color: #f0f6ff;
      border-radius: 999px;
      font-size: 11px;
      letter-spacing: 0.08em;
      padding: 4px 12px;
      text-transform: uppercase;
      transition: border-color 0.15s ease, background 0.15s ease;
    }
    #editorPanel .editor-panel-toggle:focus-visible {
      outline: 2px solid #8fdfff;
      outline-offset: 2px;
    }
    #editorPanel .editor-panel-toggle:hover,
    #editorPanel .editor-panel-toggle:active {
      border-color: rgba(255, 255, 255, 0.45);
      background: rgba(22, 32, 50, 0.8);
    }
    #editorPanel .editor-panel-body {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    #editorPanel .editor-panel-body strong {
      color: #8fdfff;
      font-weight: 600;
    }
    #editorPanel .meteor-controls {
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid rgba(143, 223, 255, 0.2);
      display: flex;
      flex-direction: column;
      gap: 10px;
      pointer-events: auto;
    }
    #editorPanel .meteor-controls h4 {
      margin: 0 0 4px;
      font-size: 13px;
      color: #ffd8a6;
      font-weight: 600;
    }
    #editorPanel .meteor-controls .meteor-section {
      background: rgba(12, 18, 30, 0.55);
      border: 1px solid rgba(143, 223, 255, 0.15);
      border-radius: 6px;
      padding: 8px 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    #editorPanel .meteor-controls .meteor-list {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }
    #editorPanel .meteor-controls .meteor-list button {
      background: rgba(29, 42, 68, 0.75);
      border: 1px solid rgba(143, 223, 255, 0.3);
      border-radius: 4px;
      color: #f0f6ff;
      font-size: 12px;
      padding: 2px 6px;
      cursor: pointer;
    }
    #editorPanel .meteor-controls .meteor-list button.selected {
      background: rgba(143, 223, 255, 0.25);
      border-color: rgba(143, 223, 255, 0.6);
    }
    #editorPanel .meteor-controls label {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      font-size: 12px;
    }
    #editorPanel .meteor-controls input[type='number'] {
      flex: 0 0 84px;
      padding: 2px 6px;
      border-radius: 4px;
      border: 1px solid rgba(143, 223, 255, 0.45);
      background: rgba(12, 18, 30, 0.9);
      color: #f5fbff;
      font-size: 12px;
    }
    #editorPanel .meteor-controls input[type='number']::-webkit-outer-spin-button,
    #editorPanel .meteor-controls input[type='number']::-webkit-inner-spin-button {
      opacity: 0.5;
    }
    #editorPanel .meteor-controls .meteor-empty {
      font-size: 12px;
      color: rgba(255, 255, 255, 0.7);
    }
  </style>
</head>
<body>
  <div id="gameShell">
    <canvas id="gameCanvas" width="600" height="400"></canvas>
    <div id="editorToolBar" class="hidden" aria-hidden="true">
      <button type="button" data-tool="spawn" aria-pressed="false">
        <span class="sr-only">Spawn point tool</span>
        <span class="tool-icon spawn" aria-hidden="true"></span>
      </button>
      <button type="button" data-tool="landing" aria-pressed="false">
        <span class="sr-only">Landing zone tool</span>
        <span class="tool-icon landing" aria-hidden="true"></span>
      </button>
      <button type="button" data-tool="terrain" aria-pressed="false">
        <span class="sr-only">Terrain sculpt tool</span>
        <span class="tool-icon terrain" aria-hidden="true"></span>
      </button>
      <button type="button" data-tool="blackHole" aria-pressed="false">
        <span class="sr-only">Black hole tool</span>
        <span class="tool-icon blackHole" aria-hidden="true"></span>
      </button>
      <button type="button" data-tool="meteor" aria-pressed="false">
        <span class="sr-only">Meteor tool</span>
        <span class="tool-icon meteor" aria-hidden="true"></span>
      </button>
    </div>
    <div id="touchControls" class="hidden" aria-hidden="true">
      <div class="touch-row">
        <div class="touch-cluster rotate">
          <button type="button" class="left" data-key="ArrowLeft" aria-label="Rotate left"><span class="sr-only">Rotate left</span></button>
          <button type="button" class="right" data-key="ArrowRight" aria-label="Rotate right"><span class="sr-only">Rotate right</span></button>
        </div>
        <button type="button" class="menu-button" data-action="menu" aria-label="Open menu">Start</button>
        <div class="touch-cluster action">
          <button type="button" class="bomb-button" data-key="Space" data-action="bomb" aria-label="Drop bomb">Bomb</button>
          <button type="button" class="thrust-button" data-key="ArrowUp" aria-label="Main thruster">Thrust</button>
        </div>
      </div>
    </div>
  </div>
  <button id="touchToggle" class="hidden" type="button" aria-pressed="false">Touch Controls</button>
  <div id="info" class="hidden" aria-live="polite" aria-atomic="true">
    <div class="info-header">
      <span class="info-title">Status</span>
      <button type="button" class="info-toggle" aria-expanded="true">Hide info</button>
    </div>
    <div class="info-body"></div>
  </div>
  <div id="startMenu" class="menu-overlay">
    <div class="menu-panel">
      <h1>Moon Lander</h1>
      <div class="menu-actions">
        <button id="menuPlay">Play</button>
        <button id="menuEditor" class="secondary">Create Level</button>
      </div>
    </div>
  </div>
  <div id="postLevelMenu" class="menu-overlay hidden" aria-hidden="true">
    <div class="menu-panel">
      <h2 id="postLevelTitle">Mission Update</h2>
      <p id="postLevelMessage"></p>
      <div class="menu-actions">
        <button id="postRestart" type="button">Restart Level</button>
        <button id="postNext" type="button" class="secondary">Next Level</button>
        <button id="postMainMenu" type="button" class="secondary">Main Menu</button>
      </div>
    </div>
  </div>
  <div id="editorPanel" class="hidden" aria-live="polite" aria-atomic="true" aria-hidden="true">
    <div class="editor-panel-header">
      <span class="editor-panel-title">Level Editor</span>
      <button type="button" class="editor-panel-toggle" aria-expanded="true">Hide info</button>
    </div>
    <div class="editor-panel-body"></div>
  </div>
  <script>
    (() => {
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      const infoPanel = document.getElementById('info');
      const infoBody = infoPanel ? infoPanel.querySelector('.info-body') : null;
      const infoToggleButton = infoPanel ? infoPanel.querySelector('.info-toggle') : null;
      const infoTitle = infoPanel ? infoPanel.querySelector('.info-title') : null;
      const startMenu = document.getElementById('startMenu');
      const menuPlayBtn = document.getElementById('menuPlay');
      const menuEditorBtn = document.getElementById('menuEditor');
      const touchControls = document.getElementById('touchControls');
      const touchToggle = document.getElementById('touchToggle');
      const postLevelMenu = document.getElementById('postLevelMenu');
      const postLevelTitle = document.getElementById('postLevelTitle');
      const postLevelMessage = document.getElementById('postLevelMessage');
      const postRestartBtn = document.getElementById('postRestart');
      const postNextBtn = document.getElementById('postNext');
      const postMenuBtn = document.getElementById('postMainMenu');
      const editorToolBar = document.getElementById('editorToolBar');
      const editorToolButtons = editorToolBar
        ? Array.from(editorToolBar.querySelectorAll('button[data-tool]'))
        : [];

      let infoCollapsed = false;
      let editorPanelCollapsed = false;

      function setInfoTitle(text) {
        if (infoTitle) {
          infoTitle.textContent = text || 'Status';
        }
      }

      function applyInfoCollapsedState() {
        if (!infoPanel) return;
        infoPanel.classList.toggle('collapsed', infoCollapsed);
        if (infoToggleButton) {
          infoToggleButton.setAttribute('aria-expanded', (!infoCollapsed).toString());
          infoToggleButton.textContent = infoCollapsed ? 'Show info' : 'Hide info';
        }
      }

      function setInfoMessage(text, title = null) {
        if (!infoPanel || !infoBody) return;
        if (title !== null) {
          setInfoTitle(title);
        }
        infoBody.textContent = text || '';
        const hasText = !!text;
        if (hasText) {
          infoPanel.classList.remove('hidden');
          infoPanel.setAttribute('aria-hidden', 'false');
          applyInfoCollapsedState();
        } else {
          infoPanel.classList.add('hidden');
          infoPanel.setAttribute('aria-hidden', 'true');
        }
      }

      function clearInfoMessage() {
        if (!infoPanel || !infoBody) return;
        infoBody.textContent = '';
        infoPanel.classList.add('hidden');
        infoPanel.setAttribute('aria-hidden', 'true');
      }

      function setEditorPanelTitle(text) {
        if (editorPanelTitle) {
          editorPanelTitle.textContent = text || 'Level Editor';
        }
      }

      function applyEditorPanelCollapsedState() {
        if (!editorPanel) return;
        editorPanel.classList.toggle('collapsed', editorPanelCollapsed);
        if (editorPanelToggle) {
          editorPanelToggle.setAttribute('aria-expanded', (!editorPanelCollapsed).toString());
          editorPanelToggle.textContent = editorPanelCollapsed ? 'Show info' : 'Hide info';
        }
      }

      const TOUCH_PREF_KEY = 'moonlander.touchControls';
      let manualTouchPreference = null;
      let wantsTouchControls = false;
      let touchControlsVisible = false;
      let postLevelActive = false;
      let postLevelOutcome = null;
      let postLevelRevealTimer = null;
      const coarsePointerQuery = window.matchMedia ? window.matchMedia('(pointer: coarse)') : null;

      const activeTouchPointers = new Map();
      const virtualKeyCounts = new Map();
      const physicalKeyState = {};

      const TOUCH_CONTROL_KEYS = new Set(['ArrowLeft', 'ArrowRight', 'ArrowUp', 'Space']);

      const editorPanel = document.getElementById('editorPanel');
      const editorPanelBody = editorPanel ? editorPanel.querySelector('.editor-panel-body') : null;
      const editorPanelToggle = editorPanel ? editorPanel.querySelector('.editor-panel-toggle') : null;
      const editorPanelTitle = editorPanel ? editorPanel.querySelector('.editor-panel-title') : null;
      let width = canvas.width;
      let height = canvas.height;

      const APP_MODE = {
        MENU: 'menu',
        PLAY: 'play',
        EDITOR: 'editor',
        TEST: 'test',
      };
      let appMode = APP_MODE.MENU;

      const MAX_VIEW_WIDTH = 1280;
      const MAX_VIEW_HEIGHT = 1400;
      const MIN_VIEW_WIDTH = 600;
      const MIN_VIEW_HEIGHT = 400;

      /**
       * Encapsulates deterministic physics helpers that can be reused across gameplay and tests.
       */
      const Physics = (() => {
        const DEFAULT_FUEL_BURN_RATE = 0.0005;

        /**
         * Integrates the lander's motion for a single frame.
         * Mutates the provided lander object in-place and returns metadata about the step.
         *
         * @param {object} lander - Mutable lander state with position, velocity, angle, and tuning knobs.
         * @param {number} dt - Delta time in milliseconds.
         * @param {object} control - Control input booleans for the step.
         * @param {object} environment - Environmental configuration and helper callbacks.
         * @returns {{thrusterActive: boolean, thrusterDust: object|null, captureHole: any}}
         */
        function integrateLander(lander, dt, control, environment) {
          const rotateLeft = !!(control && control.rotateLeft);
          const rotateRight = !!(control && control.rotateRight);
          const thrust = !!(control && control.thrust);
          const g = environment && typeof environment.g === 'number' ? environment.g : 0;
          const fuelBurnRate = environment && typeof environment.fuelBurnRate === 'number'
            ? environment.fuelBurnRate
            : DEFAULT_FUEL_BURN_RATE;
          const bounce = environment && typeof environment.bounce === 'number' ? environment.bounce : 0;
          const boundaries = environment && environment.boundaries ? environment.boundaries : null;
          const computeBlackHoleAcceleration = environment ? environment.computeBlackHoleAcceleration : null;
          const findBlackHoleCapture = environment ? environment.findBlackHoleCapture : null;
          const dustOptions = environment || {};

          if (rotateLeft) {
            lander.angularVelocity -= lander.rotateAccel * dt;
          }
          if (rotateRight) {
            lander.angularVelocity += lander.rotateAccel * dt;
          }
          lander.angularVelocity *= lander.rotateDamping;
          lander.angle += lander.angularVelocity * dt;

          let thrusterActive = false;
          if (thrust && lander.fuel > 0) {
            const ax = Math.sin(lander.angle) * lander.thrustPower;
            const ay = -Math.cos(lander.angle) * lander.thrustPower;
            lander.vx += ax * dt;
            lander.vy += ay * dt;
            lander.fuel -= fuelBurnRate * dt;
            if (lander.fuel < 0) lander.fuel = 0;
            thrusterActive = true;
          }

          lander.vy += g * dt;

          if (typeof computeBlackHoleAcceleration === 'function') {
            const holeAccel = computeBlackHoleAcceleration(lander.x, lander.y);
            if (holeAccel) {
              lander.vx += holeAccel.ax * dt;
              lander.vy += holeAccel.ay * dt;
            }
          }

          lander.x += lander.vx * dt;
          lander.y += lander.vy * dt;

          if (boundaries) {
            const minX = typeof boundaries.minX === 'number' ? boundaries.minX : -Infinity;
            const maxX = typeof boundaries.maxX === 'number' ? boundaries.maxX : Infinity;
            if (lander.x < minX) {
              lander.x = minX;
              if (lander.vx < 0) lander.vx = -lander.vx * bounce;
            }
            if (lander.x > maxX) {
              lander.x = maxX;
              if (lander.vx > 0) lander.vx = -lander.vx * bounce;
            }
          }

          const captureHole = typeof findBlackHoleCapture === 'function'
            ? findBlackHoleCapture(lander.x, lander.y)
            : null;

          const thrusterDust = thrusterActive
            ? computeThrusterDust(lander, dustOptions)
            : null;

          return {
            thrusterActive,
            thrusterDust,
            captureHole,
          };
        }

        /**
         * Computes the thruster dust emission parameters for the current lander pose.
         */
        function computeThrusterDust(lander, options = {}) {
          const castThrustRay = options.castThrustRay;
          if (typeof castThrustRay !== 'function') {
            return null;
          }
          // 70 mirrors the original DUST_MAX_DIST constant from the legacy update loop.
          const dustMaxDistance = typeof options.dustMaxDistance === 'number' ? options.dustMaxDistance : 70;
          const nozzleOffset = lander.height / 2;
          const originX = lander.x - Math.sin(lander.angle) * nozzleOffset;
          const originY = lander.y + Math.cos(lander.angle) * nozzleOffset;
          const dirX = -Math.sin(lander.angle);
          const dirY = Math.cos(lander.angle);
          const maxRayDistance = dustMaxDistance / Math.max(dirY, 0.05);
          const hit = castThrustRay(originX, originY, dirX, dirY, maxRayDistance);
          if (!hit) {
            return null;
          }
          const verticalDrop = hit.y - originY;
          if (!(verticalDrop > 0 && verticalDrop < dustMaxDistance)) {
            return null;
          }
          const prox = Math.max(0, 1 - verticalDrop / dustMaxDistance);
          const intensity = prox * prox;
          const baseCount = Math.floor(1 + intensity * 30);
          return {
            emitX: hit.x,
            emitY: hit.y - 2,
            spawnCount: Math.min(60, baseCount),
            spread: 0.02 + intensity * 0.22,
            pushUp: 0.015 + intensity * 0.1,
            prox,
          };
        }

        /**
         * Evaluates whether the lander satisfies landing conditions for a safe touchdown.
         */
        function evaluateLanding(lander, touchingFeet, pad, terrain, thresholds = {}, resolveSurfaceY) {
          const result = {
            success: false,
            reason: null,
            touchdownY: null,
            speed: Math.hypot(lander.vx, lander.vy),
          };
          if (!Array.isArray(touchingFeet) || touchingFeet.length === 0) {
            result.reason = 'no-support';
            return result;
          }
          const uprightTolerance = typeof thresholds.uprightTolerance === 'number' ? thresholds.uprightTolerance : 0.26;
          const padMargin = typeof thresholds.padMargin === 'number' ? thresholds.padMargin : 1;
          const surfaceGapTolerance = typeof thresholds.surfaceGapTolerance === 'number'
            ? thresholds.surfaceGapTolerance
            : terrain.cellSize;
          const maxSpeed = typeof thresholds.maxSpeed === 'number' ? thresholds.maxSpeed : 0.09;
          const maxHorizontalSpeed = typeof thresholds.maxHorizontalSpeed === 'number' ? thresholds.maxHorizontalSpeed : 0.07;
          const maxVerticalSpeed = typeof thresholds.maxVerticalSpeed === 'number' ? thresholds.maxVerticalSpeed : 0.07;

          const normalizedAngle = ((lander.angle % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
          const uprightNow = normalizedAngle < uprightTolerance || normalizedAngle > Math.PI * 2 - uprightTolerance;
          const padLeft = pad.x - padMargin;
          const padRight = pad.x + pad.w + padMargin;
          const padTop = pad.y + pad.h;
          const onPad = touchingFeet.every((pt) => {
            if (pt.surfaceY == null) return false;
            if (pt.x < padLeft || pt.x > padRight) return false;
            return Math.abs(padTop - pt.surfaceY) <= surfaceGapTolerance;
          });
          const okSpeed = result.speed < maxSpeed;
          const okVx = Math.abs(lander.vx) < maxHorizontalSpeed;
          const okVy = lander.vy < maxVerticalSpeed;

          if (onPad && uprightNow && okSpeed && okVx && okVy) {
            result.success = true;
            let touchdown = null;
            for (const pt of touchingFeet) {
              if (typeof pt.surfaceY === 'number') {
                touchdown = touchdown == null ? pt.surfaceY : Math.min(touchdown, pt.surfaceY);
              }
            }
            if (touchdown == null && typeof resolveSurfaceY === 'function') {
              touchdown = resolveSurfaceY(lander.x, lander.y);
            }
            result.touchdownY = touchdown != null ? touchdown : lander.y;
            return result;
          }

          result.reason = {
            onPad,
            upright: uprightNow,
            okSpeed,
            okVx,
            okVy,
          };
          return result;
        }

        return {
          integrateLander,
          evaluateLanding,
          computeThrusterDust,
          DEFAULT_FUEL_BURN_RATE,
        };
      })();

      function computeDefaultTouchPreference() {
        if (coarsePointerQuery && typeof coarsePointerQuery.matches === 'boolean' && coarsePointerQuery.matches) {
          return true;
        }
        if (typeof navigator !== 'undefined' && typeof navigator.maxTouchPoints === 'number' && navigator.maxTouchPoints > 0) {
          return true;
        }
        if (window.matchMedia) {
          try {
            const fine = window.matchMedia('(pointer: fine)');
            if (fine && fine.matches) {
              return false;
            }
          } catch (_) {
            /* ignore */
          }
        }
        return 'ontouchstart' in window;
      }

      function updateTouchToggleLabel() {
        if (!touchToggle) return;
        const auto = manualTouchPreference === null;
        const stateLabel = auto
          ? (wantsTouchControls ? 'Auto (On)' : 'Auto (Off)')
          : (manualTouchPreference === 'on' ? 'On' : 'Off');
        touchToggle.textContent = `Touch HUD: ${stateLabel}`;
        touchToggle.setAttribute('aria-pressed', wantsTouchControls ? 'true' : 'false');
        touchToggle.classList.remove('hidden');
      }

      function setTouchControlsVisibility(shouldShow) {
        const show = !!shouldShow && wantsTouchControls;
        if (show === touchControlsVisible) return;
        const wasVisible = touchControlsVisible;
        touchControlsVisible = show;
        if (!touchControls) return;
        if (show) {
          touchControls.classList.remove('hidden');
          touchControls.classList.add('visible');
          touchControls.setAttribute('aria-hidden', 'false');
        } else {
          touchControls.classList.remove('visible');
          touchControls.classList.add('hidden');
          touchControls.setAttribute('aria-hidden', 'true');
          if (wasVisible) {
            clearVirtualTouchState();
          }
        }
        if (typeof resizeCanvas === 'function') {
          resizeCanvas();
        }
      }

      function refreshTouchControlsPreference() {
        const previous = wantsTouchControls;
        if (manualTouchPreference === 'on') {
          wantsTouchControls = true;
        } else if (manualTouchPreference === 'off') {
          wantsTouchControls = false;
        } else {
          wantsTouchControls = computeDefaultTouchPreference();
        }
        updateTouchToggleLabel();
        if (!wantsTouchControls && touchControlsVisible) {
          setTouchControlsVisibility(false);
        } else if (wantsTouchControls && previous !== wantsTouchControls) {
          updateTouchControlsForMode();
        }
        return previous !== wantsTouchControls;
      }

      function syncCombinedKeyState(key) {
        const virtualCount = virtualKeyCounts.get(key) || 0;
        const physicalDown = !!physicalKeyState[key];
        const shouldBeDown = virtualCount > 0 || physicalDown;
        if (shouldBeDown) {
          keys[key] = true;
        } else if (keys[key]) {
          keys[key] = false;
        }
      }

      function incrementVirtualKey(key) {
        const current = virtualKeyCounts.get(key) || 0;
        virtualKeyCounts.set(key, current + 1);
        keys[key] = true;
      }

      function decrementVirtualKey(key) {
        const current = virtualKeyCounts.get(key) || 0;
        if (current <= 1) {
          virtualKeyCounts.delete(key);
        } else {
          virtualKeyCounts.set(key, current - 1);
        }
        syncCombinedKeyState(key);
      }

      function clearVirtualTouchState() {
        activeTouchPointers.clear();
        virtualKeyCounts.clear();
        const buttons = touchControls ? touchControls.querySelectorAll('button.is-pressed') : null;
        if (buttons) {
          buttons.forEach(btn => btn.classList.remove('is-pressed'));
        }
        ['ArrowLeft', 'ArrowRight', 'ArrowUp', 'Space'].forEach((key) => syncCombinedKeyState(key));
      }

      function resetControlKeyState() {
        TOUCH_CONTROL_KEYS.forEach((key) => {
          physicalKeyState[key] = false;
          if (keys[key]) {
            keys[key] = false;
          }
        });
      }

      function updateTouchControlsForMode() {
        const gameplayMode = appMode === APP_MODE.PLAY || appMode === APP_MODE.TEST;
        setTouchControlsVisibility(gameplayMode);
        if (touchToggle) {
          if (appMode === APP_MODE.EDITOR) {
            touchToggle.classList.add('toggle-hidden');
          } else {
            touchToggle.classList.remove('toggle-hidden');
          }
        }
      }

      function setManualTouchPreference(value) {
        manualTouchPreference = value;
        try {
          if (value === null) {
            window.localStorage.removeItem(TOUCH_PREF_KEY);
          } else {
            window.localStorage.setItem(TOUCH_PREF_KEY, value);
          }
        } catch (_) {
          /* storage can fail (private mode) */
        }
        refreshTouchControlsPreference();
      }

      function cycleTouchPreference() {
        if (manualTouchPreference === 'on') {
          setManualTouchPreference('off');
        } else if (manualTouchPreference === 'off') {
          setManualTouchPreference(null);
        } else {
          setManualTouchPreference('on');
        }
      }

      function hidePostLevelMenu() {
        if (!postLevelMenu) return;
        if (postLevelRevealTimer) {
          clearTimeout(postLevelRevealTimer);
          postLevelRevealTimer = null;
        }
        postLevelActive = false;
        postLevelOutcome = null;
        postLevelMenu.classList.add('hidden');
        postLevelMenu.setAttribute('aria-hidden', 'true');
      }

      function showPostLevelMenu(kind, detail, upcoming) {
        if (!postLevelMenu) return;
        if (appMode !== APP_MODE.PLAY) return;
        if (postLevelRevealTimer) {
          clearTimeout(postLevelRevealTimer);
          postLevelRevealTimer = null;
        }
        postLevelOutcome = kind;
        if (postLevelTitle) {
          postLevelTitle.textContent = kind === 'success' ? 'Mission Complete' : 'Mission Failed';
        }
        if (postLevelMessage) {
          postLevelMessage.textContent = detail || '';
        }
        if (postNextBtn) {
          if (kind === 'success') {
            postNextBtn.classList.remove('hidden');
            postNextBtn.disabled = false;
            postNextBtn.textContent = upcoming ? `Next: ${upcoming}` : 'Next Level';
          } else {
            postNextBtn.classList.add('hidden');
            postNextBtn.disabled = true;
          }
        }
        postLevelMenu.classList.add('hidden');
        postLevelMenu.setAttribute('aria-hidden', 'true');
        postLevelActive = false;
        postLevelRevealTimer = window.setTimeout(() => {
          postLevelRevealTimer = null;
          if (appMode !== APP_MODE.PLAY) return;
          postLevelActive = true;
          postLevelMenu.classList.remove('hidden');
          postLevelMenu.setAttribute('aria-hidden', 'false');
        }, 3000);
      }

      function handleMenuButtonPress() {
        audio.unlock();
        if (appMode === APP_MODE.TEST) {
          returnToEditorFromTest();
        } else if (appMode === APP_MODE.EDITOR) {
          enterMenu();
        } else if (appMode === APP_MODE.PLAY) {
          enterMenu();
        }
      }

      function advanceToNextLevel() {
        if (appMode !== APP_MODE.PLAY) return;
        if (!gameOver) return;
        if (postLevelOutcome !== 'success') return;
        if (!Array.isArray(levels) || levels.length === 0) return;
        nextLevelIndex = (currentLevelIndex + 1) % levels.length;
        shouldRegen = true;
        hidePostLevelMenu();
        resetGame(true);
      }

      try {
        const savedPref = window.localStorage.getItem(TOUCH_PREF_KEY);
        if (savedPref === 'on' || savedPref === 'off') {
          manualTouchPreference = savedPref;
        }
      } catch (_) {
        manualTouchPreference = null;
      }
      if (touchToggle) {
        touchToggle.addEventListener('click', cycleTouchPreference);
        touchToggle.setAttribute('title', 'Tap to cycle: On -> Off -> Auto');
      }
      function releaseVirtualPointer(pointerId) {
        const state = activeTouchPointers.get(pointerId);
        if (!state) return;
        activeTouchPointers.delete(pointerId);
        const { key, action, element } = state;
        if (element && element.classList.contains('is-pressed')) {
          element.classList.remove('is-pressed');
        }
        if (element && typeof element.releasePointerCapture === 'function') {
          try {
            element.releasePointerCapture(pointerId);
          } catch (_) {
            /* ignore */
          }
        }
        if (key) {
          decrementVirtualKey(key);
        }
        if (action === 'menu') {
          // menu action is fire-and-forget on pointer down
        }
      }

      function handleVirtualPointerDown(event) {
        if (!touchControlsVisible) return;
        const button = event.target instanceof Element ? event.target.closest('button') : null;
        if (!button) return;
        event.preventDefault();
        event.stopPropagation();
        const key = button.dataset.key;
        const action = button.dataset.action || null;
        if (!key && !action) return;
        const pointerId = event.pointerId;
        if (activeTouchPointers.has(pointerId)) {
          releaseVirtualPointer(pointerId);
        }
        activeTouchPointers.set(pointerId, { key: key || null, action, element: button });
        button.classList.add('is-pressed');
        if (typeof button.setPointerCapture === 'function') {
          try {
            button.setPointerCapture(pointerId);
          } catch (_) {
            /* ignore */
          }
        }
        if (action === 'menu') {
          handleMenuButtonPress();
          return;
        }
        if (!key) return;
        incrementVirtualKey(key);
        if (action === 'bomb' || key === 'Space') {
          if (typeof canDropBomb === 'function') {
            dropBomb();
          }
        }
      }

      function handleVirtualPointerEnd(event) {
        releaseVirtualPointer(event.pointerId);
      }

      if (touchControls) {
        touchControls.addEventListener('pointerdown', handleVirtualPointerDown);
        touchControls.addEventListener('pointerup', handleVirtualPointerEnd);
        touchControls.addEventListener('pointercancel', handleVirtualPointerEnd);
        touchControls.addEventListener('pointerleave', handleVirtualPointerEnd);
        touchControls.addEventListener('contextmenu', (event) => event.preventDefault());
      }

      if (postRestartBtn) {
        postRestartBtn.addEventListener('click', () => {
          audio.unlock();
          if (appMode !== APP_MODE.PLAY || !gameOver) return;
          shouldRegen = false;
          hidePostLevelMenu();
          resetGame(true);
        });
      }

      if (postNextBtn) {
        postNextBtn.addEventListener('click', () => {
          audio.unlock();
          if (appMode !== APP_MODE.PLAY || !gameOver) return;
          advanceToNextLevel();
        });
      }

      if (postMenuBtn) {
        postMenuBtn.addEventListener('click', () => {
          audio.unlock();
          if (appMode !== APP_MODE.PLAY) return;
          enterMenu();
        });
      }
      if (infoToggleButton && infoPanel) {
        infoToggleButton.addEventListener('click', () => {
          infoCollapsed = !infoCollapsed;
          applyInfoCollapsedState();
          if (infoBody && infoBody.textContent && infoBody.textContent.length) {
            infoPanel.classList.remove('hidden');
            infoPanel.setAttribute('aria-hidden', 'false');
          }
        });
      }
      if (editorPanelToggle && editorPanel) {
        editorPanelToggle.addEventListener('click', () => {
          editorPanelCollapsed = !editorPanelCollapsed;
          applyEditorPanelCollapsedState();
          if (!editorPanelCollapsed) {
            editorPanel.classList.remove('hidden');
            editorPanel.setAttribute('aria-hidden', 'false');
          }
        });
      }
      if (editorToolBar) {
        editorToolBar.addEventListener('click', (event) => {
          const button = event.target.closest('button[data-tool]');
          if (!button || button.disabled) return;
          event.preventDefault();
          const tool = button.getAttribute('data-tool');
          const targetIndex = editorState.placementOptions.indexOf(tool);
          if (targetIndex === -1 || targetIndex === editorState.placementIndex) return;
          editorState.placementIndex = targetIndex;
          editorState.isPainting = false;
          editorState.hasMoved = false;
          editorState.pendingPaintStart = null;
          editorState.lastPointer = null;
          if (tool !== 'meteor') {
            editorCancelPendingMeteor();
          }
          updateEditorOverlay();
        });
      }

      if (coarsePointerQuery) {
        const listener = () => {
          if (manualTouchPreference === null) {
            refreshTouchControlsPreference();
            updateTouchControlsForMode();
          }
        };
        if (typeof coarsePointerQuery.addEventListener === 'function') {
          coarsePointerQuery.addEventListener('change', listener);
        } else if (typeof coarsePointerQuery.addListener === 'function') {
          coarsePointerQuery.addListener(listener);
        }
      }

      refreshTouchControlsPreference();
      updateTouchControlsForMode();

      // --- Procedural terrain (peaks, valleys, and a flat pad segment) ---
      const levels = [
        {
          name: 'Crater Run',
          worldWidth: 2000,
          baseBand: [0.65, 0.9],
          amp: 0.22,
          waveScale: 0.65,
          waveFreq: 0.012,
          roughWaveFreq: 0.037,
          noiseScale: 0.12,
          padOffset: 0.78,
          meteors: [
            {
              startMs: 6000,
              warningLeadMs: 2600,
              speed: 0.34,
              radius: 28,
              spawn: { x: 340, y: -210 },
              target: { x: 840, y: height * 0.78 },
            },
            {
              startMs: 11200,
              warningLeadMs: 3200,
              speed: 0.28,
              radius: 34,
              spawn: { x: 1460, y: -240 },
              target: { x: 1180, y: height * 0.82 },
            },
          ],
        },
        {
          name: 'Basalt Dunes',
          worldWidth: 2400,
          baseBand: [0.60, 0.88],
          amp: 0.26,
          waveScale: 0.72,
          waveFreq: 0.009,
          roughWaveFreq: 0.028,
          noiseScale: 0.16,
          padOffset: 0.66,
        },
        {
          name: 'Ridge Maze',
          worldWidth: 2600,
          baseBand: [0.58, 0.9],
          amp: 0.28,
          waveScale: 0.80,
          waveFreq: 0.007,
          roughWaveFreq: 0.032,
          noiseScale: 0.18,
          padOffset: 0.82,
        },
      ];

      let currentLevelIndex = 0;
      let nextLevelIndex = 0;

      const GRID_CELL_SIZE = 8;
      let terrain = {
        cellSize: GRID_CELL_SIZE,
        cols: 0,
        rows: 0,
        solids: new Uint8Array(0),
        width: width,
        height: height,
        levelName: levels[0].name,
        dirtyRender: true,
        blackHoles: [],
        meteors: [],
      };
      const pad = { x: 0, y: 0, w: 110, h: 10 };
      const PAD_PULSE_PERIOD = 3000; // ms for a full pad glow cycle
      const BOMB_FUSE_MS = 3000;      // ms until detonation
      const BOMB_ARM_DELAY = 220;     // ms before the bomb can detonate post-drop
      const BOMB_BLINK_BASE = 0.002;  // radians/ms baseline blink speed
      const BOMB_BLINK_ACCEL = 0.013; // blink speed gain as fuse approaches zero
      const BOMB_MAX_RADIUS = 68;     // px crater influence radius
      const BOMB_MAX_DEPTH = 36;      // px maximum depth carved into terrain
      const BOMB_SELF_PUSH = 18;      // px upward nudge if lander inside blast
      const BOMB_MAX_ACTIVE = 6;      // limit simultaneous live bombs to keep perf stable
      const BOMB_DROP_COOLDOWN = 220; // ms cooldown between drops
      const BOMB_CHAIN_RADIUS = 86;   // px radius within which blasts trigger other bombs
      const EXPLOSION_KILL_RADIUS = 74; // px radius that destroys the lander from a blast
      const CRASH_CRATER_RADIUS = 78; // px terrain deformation from crashing
      const CRASH_CRATER_DEPTH = 44;  // px depth carved by a crash explosion

      const METEOR_TRAIL_INTERVAL = 26;      // ms between trail samples
      const METEOR_CRATER_RADIUS_SCALE = 2.1; // crater radius multiplier per meteor radius
      const METEOR_CRATER_DEPTH_SCALE = 1.25; // crater depth multiplier per meteor radius
      const METEOR_SPAWN_ABOVE_MARGIN = 60;   // ensure meteors spawn above the visible top edge
      const METEOR_SPAWN_HANDLE_OFFSET = 28;  // screen offset for the draggable spawn handle
      const METEOR_SPARK_COUNT = 18;          // sparks spawned on impact
      const METEOR_IMPACT_SMOKE_SCALE = 0.2;    // multiplier for post-impact dust plume count
      const METEOR_WARNING_FLASH_MS = 280;    // period for warning flash oscillation
      const METEOR_WARNING_ALPHA_MIN = 0.22;
      const METEOR_WARNING_ALPHA_MAX = 0.8;
      const METEOR_MIN_RADIUS = 4;
      const METEOR_MAX_RADIUS = 140;
      const METEOR_MIN_SPEED = 0.02;
      const METEOR_MAX_SPEED = 2.5;

      const BLACK_HOLE_EVENT_RADIUS = 42;     // px radius where objects are consumed
      const BLACK_HOLE_PULL_RADIUS = 220;     // px radius where gravity begins to pull
      const BLACK_HOLE_PULL_STRENGTH = 0.0014; // base acceleration gain (px/ms^2)
      const BLACK_HOLE_MAX_FORCE = 0.0025;     // clamp for stability
      const BLACK_HOLE_MIN_DISTANCE = 18;      // avoid infinite acceleration near center
      const BLACK_HOLE_MIN_SPACING = BLACK_HOLE_EVENT_RADIUS * 2.1; // spacing between holes

      function holeEventRadius(hole) {
        return hole && typeof hole.eventRadius === 'number' ? hole.eventRadius : BLACK_HOLE_EVENT_RADIUS;
      }

      function holePullRadius(hole) {
        return hole && typeof hole.pullRadius === 'number' ? hole.pullRadius : BLACK_HOLE_PULL_RADIUS;
      }
      const DEBRIS_GRAVITY_MULT = 3;  // tweak to make explosion debris fall faster/slower
      const DEBRIS_LIFE_MULT = 3;   // tweak to make explosion debris linger longer/shorter

      const editorState = {
        active: false,
        grid: null,
        placementOptions: ['spawn', 'landing', 'terrain', 'blackHole', 'meteor'],
        placementIndex: 0,
        spawn: { x: 180, y: 120 },
        isPainting: false,
        hasMoved: false,
        cursorWorld: null,
        lastPointer: null,
        pendingPaintStart: null,
        brushRadius: 26,
        activeBrushMode: 'add',
        camX: null,
        camY: null,
        testBaseline: null,
        blackHoles: [],
        meteors: [],
        meteorDefaults: {
          startMs: 3500,
          warningLeadMs: 1600,
          speed: 0.32,
          radius: 26,
        },
        pendingMeteor: null,
        isPlacingMeteor: false,
        selectedMeteor: -1,
        dragging: null,
      };

      function cloneSolidsArray(source) {
        const copy = new Uint8Array(source.length);
        copy.set(source);
        return copy;
      }

      function cloneBlackHoles(source) {
        if (!source || !source.length) return [];
        return source.map(hole => ({
          x: hole.x,
          y: hole.y,
          eventRadius: hole.eventRadius ?? BLACK_HOLE_EVENT_RADIUS,
          pullRadius: hole.pullRadius ?? BLACK_HOLE_PULL_RADIUS,
        }));
      }

      function cloneMeteors(source) {
        if (!source || !source.length) return [];
        return source.map(m => ({
          id: m.id ?? null,
          startMs: Math.max(0, m.startMs ?? 0),
          warningLeadMs: Math.max(0, m.warningLeadMs ?? 0),
          speed: Math.max(METEOR_MIN_SPEED, Math.min(METEOR_MAX_SPEED, m.speed ?? 0.32)),
          radius: Math.max(METEOR_MIN_RADIUS, Math.min(METEOR_MAX_RADIUS, m.radius ?? 20)),
          spawn: { x: m.spawn?.x ?? 0, y: m.spawn?.y ?? 0 },
          target: { x: m.target?.x ?? 0, y: m.target?.y ?? 0 },
        }));
      }

      function restoreTerrainFromBaseline() {
        const baseline = editorState.testBaseline;
        if (!baseline) return;
        const solidSnapshot = baseline.solids ? baseline.solids : baseline;
        terrain.solids = cloneSolidsArray(solidSnapshot);
        terrain.dirtyRender = true;
        const baselineHoles = baseline.blackHoles ? baseline.blackHoles : [];
        terrain.blackHoles = cloneBlackHoles(baselineHoles);
        editorState.blackHoles = terrain.blackHoles;
        const baselineMeteors = baseline.meteors ? baseline.meteors : [];
        terrain.meteors = cloneMeteors(baselineMeteors);
        editorState.meteors = terrain.meteors;
        if (baseline.pad) {
          pad.x = baseline.pad.x;
          pad.y = baseline.pad.y;
          pad.w = baseline.pad.w;
          pad.h = baseline.pad.h;
        }
        alignPadToSurface(pad.x + pad.w / 2, pad.y + pad.h);
        if (editorState.grid) {
          editorState.grid.solids = terrain.solids;
          editorState.grid.blackHoles = terrain.blackHoles;
          editorState.grid.meteors = terrain.meteors;
        }
      }

      function initTerrainGrid(worldWidthPx) {
        const cellSize = terrain.cellSize;
        const cols = Math.max(1, Math.ceil(worldWidthPx / cellSize));
        const rows = Math.max(1, Math.ceil(height / cellSize));
        terrain.cols = cols;
        terrain.rows = rows;
        terrain.width = cols * cellSize;
        terrain.height = rows * cellSize;
        terrain.solids = new Uint8Array(cols * rows);
        terrain.dirtyRender = true;
        if (!Array.isArray(terrain.blackHoles)) {
          terrain.blackHoles = [];
        }
        if (!Array.isArray(terrain.meteors)) {
          terrain.meteors = [];
        }
      }

      function fillColumnSolid(col, fromRow) {
        if (col < 0 || col >= terrain.cols) return;
        for (let row = fromRow; row < terrain.rows; row++) {
          terrain.solids[row * terrain.cols + col] = 1;
        }
      }

      function generateTerrain(index = currentLevelIndex) {
        currentLevelIndex = index;
        nextLevelIndex = currentLevelIndex;
        const level = levels[currentLevelIndex];
        terrain.levelName = level.name;
        initTerrainGrid(level.worldWidth);
        terrain.blackHoles = [];
        terrain.meteors = cloneMeteors(level.meteors);

        const step = terrain.cellSize;
        const cols = terrain.cols;
        const heights = new Array(cols).fill(height);

        const baseMin = height * level.baseBand[0];
        const baseMax = height * level.baseBand[1];
        const baseMid = (baseMin + baseMax) * 0.5;
        const amp = height * level.amp;

        let y = baseMid;
        for (let i = 0; i < cols; i++) {
          const t = i * step;
          const primaryWave = Math.sin(t * level.waveFreq) * amp * level.waveScale;
          const secondaryWave = Math.sin((t + 500) * level.roughWaveFreq) * amp * 0.35;
          const target = baseMid + primaryWave + secondaryWave;
          const noise = (Math.random() - 0.5) * amp * level.noiseScale;
          y = y * 0.55 + (target + noise) * 0.45;
          y = Math.max(baseMin, Math.min(baseMax, y));
          heights[i] = y | 0;
        }

        // create a flat segment for landing pad away from the start
        const padW = 110; // keep in sync with pad.w
        const padCols = Math.max(4, Math.round(padW / step));
        const padStartPx = Math.floor(level.worldWidth * level.padOffset - padW / 2);
        const padStartIdx = Math.max(0, Math.min(cols - padCols - 1, Math.floor(padStartPx / step)));
        let padY = heights[padStartIdx];
        for (let i = 1; i < padCols; i++) padY = Math.min(padY, heights[padStartIdx + i]);
        for (let i = 0; i < padCols; i++) heights[padStartIdx + i] = padY;

        for (let col = 0; col < cols; col++) {
          const fillStart = Math.floor(heights[col] / step);
          fillColumnSolid(col, fillStart);
        }

        pad.w = padW;
        pad.x = padStartIdx * step;
        pad.y = padY - pad.h;
        alignPadToSurface(pad.x + pad.w / 2, pad.y);
        terrain.dirtyRender = true;
      }

      function cellIndex(col, row) {
        return row * terrain.cols + col;
      }

      function isSolidCell(col, row) {
        if (col < 0 || col >= terrain.cols) return false;
        if (row < 0 || row >= terrain.rows) return true;
        return terrain.solids[cellIndex(col, row)] === 1;
      }

      function setSolidCell(col, row, value) {
        if (col < 0 || col >= terrain.cols) return;
        if (row < 0 || row >= terrain.rows) return;
        terrain.solids[cellIndex(col, row)] = value ? 1 : 0;
        terrain.dirtyRender = true;
      }

      function isSolidWorld(x, y) {
        const clampedX = clamp(x, 0, terrain.width - 1);
        const clampedY = clamp(y, 0, terrain.height - 1);
        const col = Math.floor(clampedX / terrain.cellSize);
        const row = Math.floor(clampedY / terrain.cellSize);
        return isSolidCell(col, row);
      }

      function findSurfaceAlongRay(x, y, dirX, dirY, maxDistance = 1600) {
        const step = terrain.cellSize * 0.5;
        const steps = Math.ceil(maxDistance / step);
        let px = x;
        let py = y;
        for (let i = 0; i < steps; i++) {
          px += dirX * step;
          py += dirY * step;
          if (px < 0 || px >= terrain.width || py < 0 || py >= terrain.height) break;
          if (isSolidWorld(px, py)) {
            return { x: px, y: py };
          }
        }
        return null;
      }

      function findSurfaceBelow(x, startY) {
        const hit = findSurfaceAlongRay(x, startY, 0, 1, terrain.height - startY + 16);
        if (!hit) return null;
        const row = Math.floor(hit.y / terrain.cellSize);
        return { x, y: row * terrain.cellSize };
      }

      function findSurfaceAbove(x, startY) {
        const hit = findSurfaceAlongRay(x, startY, 0, -1, startY + 16);
        if (!hit) return null;
        const row = Math.floor(hit.y / terrain.cellSize);
        return { x, y: (row + 1) * terrain.cellSize };
      }

      function alignPadToSurface(centerX, hintY) {
        const searchStart = clamp(hintY ?? 0, 0, terrain.height - 1);
        const surface = findSurfaceBelow(centerX, searchStart);
        if (!surface) return;
        pad.y = clamp(surface.y - pad.h, 0, terrain.height - pad.h);
      }

      function groundYAt(x, hintY = 0) {
        const surface = findSurfaceBelow(x, hintY);
        return surface ? surface.y : terrain.height;
      }

      function resolvePenetrationAt(x, y) {
        const outsideSurface = findSurfaceBelow(x, y + terrain.cellSize * 0.6);
        if (!isSolidWorld(x, y)) {
          return {
            depth: 0,
            normal: { x: 0, y: -1 },
            surfaceY: outsideSurface ? outsideSurface.y : null,
          };
        }
        const directions = [
          { x: 0, y: -1 },
          { x: 0, y: 1 },
          { x: -1, y: 0 },
          { x: 1, y: 0 },
          { x: -1, y: -1 },
          { x: 1, y: -1 },
          { x: -1, y: 1 },
          { x: 1, y: 1 },
        ];
        const step = Math.max(terrain.cellSize * 0.3, 2);
        const maxSteps = 80;
        let best = null;
        for (const dir of directions) {
          let px = x;
          let py = y;
          let dist = 0;
          for (let i = 0; i < maxSteps; i++) {
            px += dir.x * step;
            py += dir.y * step;
            dist += step;
            if (px < 0 || px >= terrain.width || py < 0 || py >= terrain.height) {
              break;
            }
            if (!isSolidWorld(px, py)) {
              if (!best || dist < best.dist) {
                best = {
                  dist,
                  dir,
                  exitX: px - dir.x * step * 0.5,
                  exitY: py - dir.y * step * 0.5,
                };
              }
              break;
            }
          }
        }
        if (!best) {
          return {
            depth: 0,
            normal: { x: 0, y: -1 },
            surfaceY: outsideSurface ? outsideSurface.y : null,
          };
        }
        const len = Math.hypot(best.dir.x, best.dir.y) || 1;
        const normal = { x: best.dir.x / len, y: best.dir.y / len };
        const surfaceY = best.exitY != null
          ? clamp(best.exitY, 0, terrain.height)
          : (outsideSurface ? outsideSurface.y : null);
        const depth = Math.min(best.dist, terrain.cellSize * 12);
        return {
          depth,
          normal,
          surfaceY,
        };
      }

      function clamp(value, min, max) {
        return Math.max(min, Math.min(max, value));
      }

      function screenToWorld(x, y) {
        const camXSafe = camX == null ? 0 : camX;
        const camYSafe = camY == null ? 0 : camY;
        const worldX = x + camXSafe - width / 2;
        const worldY = y + camYSafe - height / 2;
        return { x: worldX, y: worldY };
      }

      function initEditorTerrain(resetTerrain = false) {
        const worldWidth = Math.max(width, 1200);
        terrain.levelName = 'Custom Level';
        if (resetTerrain || !editorState.grid || editorState.grid.cols === 0) {
          initTerrainGrid(worldWidth);
          terrain.solids.fill(0);
          const fillRow = Math.floor((height * 0.78) / terrain.cellSize);
          for (let col = 0; col < terrain.cols; col++) {
            fillColumnSolid(col, fillRow);
          }
          editorState.grid = {
            cellSize: terrain.cellSize,
            cols: terrain.cols,
            rows: terrain.rows,
            solids: terrain.solids,
          };
          editorState.blackHoles = [];
          terrain.blackHoles = editorState.blackHoles;
          editorState.meteors = [];
          terrain.meteors = editorState.meteors;
          editorState.spawn.x = Math.min(worldWidth * 0.18, worldWidth - 200);
          const spawnSurface = findSurfaceBelow(editorState.spawn.x, height * 0.6);
          editorState.spawn.y = (spawnSurface ? spawnSurface.y : height * 0.75) - 140;
          pad.w = 110;
          pad.x = clamp(worldWidth * 0.65 - pad.w / 2, 0, Math.max(0, worldWidth - pad.w));
          alignPadToSurface(pad.x + pad.w / 2, height * 0.4);
          editorState.camX = worldWidth / 2;
          editorState.camY = height * 0.6;
          editorState.placementIndex = 0;
        } else {
          initTerrainGrid(editorState.grid.cols * editorState.grid.cellSize);
          terrain.solids.set(editorState.grid.solids);
          editorState.grid.solids = terrain.solids;
          if (editorState.grid.blackHoles) {
            editorState.blackHoles = cloneBlackHoles(editorState.grid.blackHoles);
          }
          terrain.blackHoles = editorState.blackHoles;
          if (editorState.grid.meteors) {
            editorState.meteors = cloneMeteors(editorState.grid.meteors);
          }
          terrain.meteors = editorState.meteors;
        }
        editorState.active = true;
        editorState.brushRadius = editorState.brushRadius || 26;
        if (editorState.camX == null) editorState.camX = terrain.width / 2;
        if (editorState.camY == null) editorState.camY = height * 0.6;
        editorState.camX = clamp(editorState.camX, width / 2, Math.max(width / 2, terrain.width - width / 2));
        editorState.camY = clamp(editorState.camY, height * 0.3, height * 0.9);
        camX = editorState.camX;
        camY = editorState.camY;
        alignEditorSpawn();
        alignEditorPad();
        editorState.grid = {
          cellSize: terrain.cellSize,
          cols: terrain.cols,
          rows: terrain.rows,
          solids: terrain.solids,
          blackHoles: editorState.blackHoles,
          meteors: editorState.meteors,
        };
        editorState.testBaseline = null;
        editorState.pendingMeteor = null;
        editorState.isPlacingMeteor = false;
        editorState.selectedMeteor = -1;
        editorState.dragging = null;
      }

      function alignEditorSpawn() {
        editorState.spawn.x = clamp(editorState.spawn.x, 0, terrain.width);
        const below = findSurfaceBelow(editorState.spawn.x, editorState.spawn.y + 2) || findSurfaceBelow(editorState.spawn.x, 0) || { y: terrain.height };
        const above = findSurfaceAbove(editorState.spawn.x, editorState.spawn.y - 2);
        const ceiling = above ? above.y + 40 : height * 0.12;
        const floor = below ? below.y - 30 : terrain.height - 30;
        editorState.spawn.y = clamp(editorState.spawn.y, ceiling, floor);
      }

      function alignEditorPad() {
        pad.x = clamp(pad.x, 0, Math.max(0, terrain.width - pad.w));
        alignPadToSurface(pad.x + pad.w / 2, pad.y + pad.h);
      }

      function editorPlaceSpawn(x, y) {
        const safeX = clamp(x, 0, terrain.width);
        const below = findSurfaceBelow(safeX, y) || findSurfaceBelow(safeX, 0) || { y: terrain.height };
        const above = findSurfaceAbove(safeX, y);
        const ceiling = above ? above.y + 35 : height * 0.12;
        const floor = below ? below.y - 30 : terrain.height - 30;
        editorState.spawn.x = safeX;
        editorState.spawn.y = clamp(y, ceiling, floor);
      }

      function editorPlaceLanding(x, y) {
        const half = pad.w / 2;
        const start = clamp(x - half, 0, Math.max(0, terrain.width - pad.w));
        pad.x = start;
        const surface = findSurfaceBelow(x, y);
        if (surface) {
          pad.y = clamp(surface.y - pad.h, 0, terrain.height - pad.h);
        } else {
          alignPadToSurface(x, y);
        }
      }

      function ensureEditorBlackHoles() {
        if (!Array.isArray(editorState.blackHoles)) {
          editorState.blackHoles = [];
        }
        if (terrain.blackHoles !== editorState.blackHoles) {
          terrain.blackHoles = editorState.blackHoles;
        }
        return editorState.blackHoles;
      }

      function ensureEditorMeteors() {
        if (!Array.isArray(editorState.meteors)) {
          editorState.meteors = [];
        }
        if (terrain.meteors !== editorState.meteors) {
          terrain.meteors = editorState.meteors;
        }
        return editorState.meteors;
      }

      function findBlackHoleNear(x, y, radiusMultiplier = 1.1) {
        const holes = ensureEditorBlackHoles();
        if (!holes.length) return null;
        const radius = BLACK_HOLE_EVENT_RADIUS * radiusMultiplier;
        let closest = null;
        let bestDist = Infinity;
        for (const hole of holes) {
          const dx = hole.x - x;
          const dy = hole.y - y;
          const dist = Math.hypot(dx, dy);
          if (dist <= radius && dist < bestDist) {
            closest = hole;
            bestDist = dist;
          }
        }
        return closest;
      }

      function editorPlaceBlackHole(x, y) {
        const holes = ensureEditorBlackHoles();
        const margin = BLACK_HOLE_EVENT_RADIUS + terrain.cellSize;
        let px = clamp(x, margin, Math.max(margin, terrain.width - margin));
        let py = clamp(y, margin, Math.max(margin, terrain.height - margin));
        const penetration = resolvePenetrationAt(px, py);
        if (penetration.depth > 0.5) {
          px += penetration.normal.x * (penetration.depth + terrain.cellSize * 0.5);
          py += penetration.normal.y * (penetration.depth + terrain.cellSize * 0.5);
          px = clamp(px, margin, Math.max(margin, terrain.width - margin));
          py = clamp(py, margin, Math.max(margin, terrain.height - margin));
        }
        if (isSolidWorld(px, py)) {
          return false;
        }
        for (const existing of holes) {
          const dist = Math.hypot(existing.x - px, existing.y - py);
          if (dist < BLACK_HOLE_MIN_SPACING) {
            return false;
          }
        }
        const hole = {
          x: px,
          y: py,
          eventRadius: BLACK_HOLE_EVENT_RADIUS,
          pullRadius: BLACK_HOLE_PULL_RADIUS,
        };
        holes.push(hole);
        terrain.blackHoles = holes;
        editorState.blackHoles = holes;
        terrain.dirtyRender = true;
        return true;
      }

      function editorRemoveBlackHole(x, y) {
        const holes = ensureEditorBlackHoles();
        if (!holes.length) return false;
        const radius = BLACK_HOLE_EVENT_RADIUS * 1.4;
        let index = -1;
        let bestDist = Infinity;
        for (let i = 0; i < holes.length; i++) {
          const hole = holes[i];
          const dist = Math.hypot(hole.x - x, hole.y - y);
          if (dist <= radius && dist < bestDist) {
            index = i;
            bestDist = dist;
          }
        }
        if (index === -1) return false;
        holes.splice(index, 1);
        terrain.blackHoles = holes;
        editorState.blackHoles = holes;
        terrain.dirtyRender = true;
        return true;
      }

      function findMeteorIndexNear(x, y, radiusMultiplier = 1.0) {
        const meteors = ensureEditorMeteors();
        if (!meteors.length) return -1;
        let index = -1;
        let bestDist = Infinity;
        for (let i = 0; i < meteors.length; i++) {
          const meteor = meteors[i];
          const spawnHandle = meteorSpawnHandlePosition(meteor);
          const spawnReach = Math.max(18, meteor.radius * radiusMultiplier + 14);
          const spawnDist = Math.hypot(spawnHandle.x - x, spawnHandle.y - y);
          if (spawnDist <= spawnReach && spawnDist < bestDist) {
            index = i;
            bestDist = spawnDist;
            continue;
          }
          const targetReach = Math.max(18, meteor.radius * 0.6 * radiusMultiplier + 12);
          const targetDist = Math.hypot(meteor.target.x - x, meteor.target.y - y);
          if (targetDist <= targetReach && targetDist < bestDist) {
            index = i;
            bestDist = targetDist;
            continue;
          }
          const projection = projectPointOnSegment(x, y, spawnHandle.x, spawnHandle.y, meteor.target.x, meteor.target.y);
          if (projection.t >= 0 && projection.t <= 1) {
            const pathReach = Math.max(18, meteor.radius * 0.5 * radiusMultiplier + 10);
            const pathDist = Math.hypot(x - projection.x, y - projection.y);
            if (pathDist <= pathReach && pathDist < bestDist) {
              index = i;
              bestDist = pathDist;
            }
          }
        }
        return index;
      }

      function editorRemoveMeteor(x, y) {
        const meteors = ensureEditorMeteors();
        const index = findMeteorIndexNear(x, y, 1.6);
        if (index === -1) return false;
        meteors.splice(index, 1);
        editorState.selectedMeteor = -1;
        terrain.meteors = meteors;
        editorState.meteors = meteors;
        terrain.dirtyRender = true;
        updateEditorOverlay();
        return true;
      }

      function editorStartMeteorPlacement(x, y) {
        const meteors = ensureEditorMeteors();
        editorState.isPlacingMeteor = true;
        const camYEditor = editorState.camY != null ? editorState.camY : (camY != null ? camY : height * 0.65);
        const viewTop = camYEditor - height / 2;
        const spawnY = Math.min(-METEOR_SPAWN_ABOVE_MARGIN, viewTop - METEOR_SPAWN_ABOVE_MARGIN);
        editorState.pendingMeteor = {
          spawn: { x, y: spawnY },
          target: { x, y },
          radius: Math.max(METEOR_MIN_RADIUS, Math.min(METEOR_MAX_RADIUS, editorState.meteorDefaults.radius)),
          speed: Math.max(METEOR_MIN_SPEED, Math.min(METEOR_MAX_SPEED, editorState.meteorDefaults.speed)),
          startMs: editorState.meteorDefaults.startMs,
          warningLeadMs: editorState.meteorDefaults.warningLeadMs,
        };
        editorState.selectedMeteor = -1;
        terrain.meteors = meteors;
        updateEditorOverlay();
      }

      function editorCommitPendingMeteor() {
        const pending = editorState.pendingMeteor;
        if (!pending) return false;
        const meteors = ensureEditorMeteors();
        const placed = {
          id: `editor-${Date.now()}-${Math.random().toString(36).slice(2, 6)}`,
          spawn: { ...pending.spawn },
          target: { ...pending.target },
          radius: Math.max(METEOR_MIN_RADIUS, Math.min(METEOR_MAX_RADIUS, pending.radius)),
          speed: Math.max(METEOR_MIN_SPEED, Math.min(METEOR_MAX_SPEED, pending.speed)),
          startMs: Math.max(0, pending.startMs),
          warningLeadMs: Math.max(0, pending.warningLeadMs),
        };
        meteors.push(placed);
        editorState.pendingMeteor = null;
        editorState.isPlacingMeteor = false;
        editorState.selectedMeteor = meteors.length - 1;
        terrain.meteors = meteors;
        editorState.meteors = meteors;
        terrain.dirtyRender = true;
        updateEditorOverlay();
        return true;
      }

      function editorCancelPendingMeteor() {
        if (!editorState.isPlacingMeteor) return;
        editorState.pendingMeteor = null;
        editorState.isPlacingMeteor = false;
      }

      function editorSelectMeteorAt(x, y) {
        const index = findMeteorIndexNear(x, y, 1.2);
        editorState.selectedMeteor = index;
        return index;
      }

      function currentEditorViewTop() {
        const camYEditor = editorState.camY != null ? editorState.camY : (camY != null ? camY : height * 0.65);
        return camYEditor - height / 2;
      }

      function meteorSpawnHandlePosition(meteor) {
        if (!meteor || !meteor.spawn) {
          const viewTopFallback = currentEditorViewTop();
          return {
            x: 0,
            y: viewTopFallback + METEOR_SPAWN_HANDLE_OFFSET,
          };
        }
        clampMeteorSpawnPosition(meteor);
        const viewTop = currentEditorViewTop();
        return {
          x: meteor.spawn.x,
          y: viewTop + METEOR_SPAWN_HANDLE_OFFSET,
        };
      }

      function clampMeteorSpawnPosition(meteor) {
        if (!meteor || !meteor.spawn) return;
        meteor.spawn.x = clamp(meteor.spawn.x, 0, terrain.width);
        const viewTop = currentEditorViewTop();
        const minSpawnY = Math.min(-METEOR_SPAWN_ABOVE_MARGIN, viewTop - METEOR_SPAWN_ABOVE_MARGIN);
        meteor.spawn.y = minSpawnY;
      }

      function clampMeteorTargetPosition(meteor) {
        if (!meteor || !meteor.target) return;
        meteor.target.x = clamp(meteor.target.x, 0, terrain.width);
        const maxY = terrain.height + 400;
        meteor.target.y = clamp(meteor.target.y, -METEOR_SPAWN_ABOVE_MARGIN, maxY);
      }

      function projectPointOnSegment(px, py, ax, ay, bx, by) {
        const abx = bx - ax;
        const aby = by - ay;
        const abLenSq = abx * abx + aby * aby;
        if (abLenSq <= 0.000001) {
          return { x: ax, y: ay, t: 0 };
        }
        let t = ((px - ax) * abx + (py - ay) * aby) / abLenSq;
        t = Math.max(0, Math.min(1, t));
        return { x: ax + abx * t, y: ay + aby * t, t };
      }

      function pickMeteorHandleAt(x, y) {
        const meteors = ensureEditorMeteors();
        if (!meteors.length) return null;
        const handleRadius = 36;
        const pathRadius = 26;
        let best = null;
        const consider = (candidate) => {
          if (!candidate) return;
          if (!best) {
            best = candidate;
            return;
          }
          if (candidate.priority < best.priority) {
            best = candidate;
            return;
          }
          if (candidate.priority === best.priority && candidate.dist < best.dist) {
            best = candidate;
          }
        };
        for (let i = 0; i < meteors.length; i++) {
          const meteor = meteors[i];
          const spawnHandle = meteorSpawnHandlePosition(meteor);
          const spawnDist = Math.hypot(x - spawnHandle.x, y - spawnHandle.y);
          if (spawnDist <= handleRadius) {
            consider({
              type: 'meteor',
              index: i,
              handle: 'spawn',
              dist: spawnDist,
              priority: 0,
              offsetX: meteor.spawn.x - spawnHandle.x,
              offsetY: meteor.spawn.y - spawnHandle.y,
            });
          }
          const targetDist = Math.hypot(x - meteor.target.x, y - meteor.target.y);
          if (targetDist <= handleRadius) {
            consider({
              type: 'meteor',
              index: i,
              handle: 'target',
              dist: targetDist,
              priority: 0,
              offsetX: meteor.target.x - x,
              offsetY: meteor.target.y - y,
            });
          }
          const projection = projectPointOnSegment(x, y, spawnHandle.x, spawnHandle.y, meteor.target.x, meteor.target.y);
          const pathDist = Math.hypot(x - projection.x, y - projection.y);
          if (pathDist <= pathRadius && projection.t > 0.08 && projection.t < 0.92) {
            consider({
              type: 'meteor',
              index: i,
              handle: 'path',
              dist: pathDist,
              priority: 1,
              startPointer: { x, y },
              initialSpawn: { ...meteor.spawn },
              initialTarget: { ...meteor.target },
            });
          }
        }
        return best;
      }

      function adjustSelectedMeteor(mutator) {
        const meteors = ensureEditorMeteors();
        const index = editorState.selectedMeteor;
        if (index < 0 || index >= meteors.length) return false;
        const meteor = meteors[index];
        const clone = {
          ...meteor,
          spawn: { ...meteor.spawn },
          target: { ...meteor.target },
        };
        const changed = mutator(clone) !== false;
        if (!changed) return false;
        clone.radius = Math.max(METEOR_MIN_RADIUS, Math.min(METEOR_MAX_RADIUS, clone.radius));
        clone.speed = Math.max(METEOR_MIN_SPEED, Math.min(METEOR_MAX_SPEED, clone.speed));
        clone.startMs = Math.max(0, clone.startMs);
        clone.warningLeadMs = Math.max(0, clone.warningLeadMs);
        meteors[index] = clone;
        terrain.meteors = meteors;
        editorState.meteors = meteors;
        terrain.dirtyRender = true;
        return true;
      }

      function editorApplyBrush(x, y, mode) {
        const radius = editorState.brushRadius;
        const cellSize = terrain.cellSize;
        const colCenter = Math.floor(clamp(x, 0, terrain.width - 1) / cellSize);
        const rowCenter = Math.floor(clamp(y, 0, terrain.height - 1) / cellSize);
        const radiusCells = Math.ceil(radius / cellSize);
        const radiusSq = radius * radius;
        for (let dy = -radiusCells; dy <= radiusCells; dy++) {
          for (let dx = -radiusCells; dx <= radiusCells; dx++) {
            const col = colCenter + dx;
            const row = rowCenter + dy;
            const cx = (col + 0.5) * cellSize;
            const cy = (row + 0.5) * cellSize;
            const distSq = (cx - x) * (cx - x) + (cy - y) * (cy - y);
            if (distSq <= radiusSq) {
              setSolidCell(col, row, mode === 'add');
            }
          }
        }
        alignPadToSurface(pad.x + pad.w / 2, pad.y + pad.h);
        alignEditorSpawn();
      }

      function editorStroke(from, to, mode) {
        const distance = Math.hypot(to.x - from.x, to.y - from.y);
        const steps = Math.max(1, Math.floor(distance / (terrain.cellSize * 0.5)));
        for (let i = 0; i <= steps; i++) {
          const t = i / steps;
          const px = from.x + (to.x - from.x) * t;
          const py = from.y + (to.y - from.y) * t;
          editorApplyBrush(px, py, mode);
        }
      }

      function updateEditorPanel(statusLines, extraHtml = '', title = null) {
        if (!editorPanel || !editorPanelBody) return;
        if (title !== null) {
          setEditorPanelTitle(title);
        }
        let html = '';
        if (statusLines && statusLines.length) {
          html += statusLines.map(line => `<div>${line}</div>`).join('');
        }
        if (extraHtml) {
          html += extraHtml;
        }
        editorPanelBody.innerHTML = html;
        applyEditorPanelCollapsedState();
      }

      function updateEditorToolButtons() {
        if (!editorToolBar) return;
        const isEditorMode = appMode === APP_MODE.EDITOR;
        if (isEditorMode && editorState.placementOptions.length) {
          editorToolBar.classList.remove('hidden');
          editorToolBar.setAttribute('aria-hidden', 'false');
          const current = editorState.placementOptions[editorState.placementIndex];
          for (const button of editorToolButtons) {
            const tool = button.getAttribute('data-tool');
            const enabled = editorState.placementOptions.includes(tool);
            button.disabled = !enabled;
            const isActive = enabled && tool === current;
            button.setAttribute('aria-pressed', isActive ? 'true' : 'false');
            button.classList.toggle('active', isActive);
          }
        } else {
          editorToolBar.classList.add('hidden');
          editorToolBar.setAttribute('aria-hidden', 'true');
        }
      }

      function buildMeteorEditorControls() {
        const meteors = ensureEditorMeteors();
        const selectedIndex = editorState.selectedMeteor;
        const hasSelection = selectedIndex != null && selectedIndex >= 0 && selectedIndex < meteors.length;
        const selected = hasSelection ? meteors[selectedIndex] : null;
        const defaults = editorState.meteorDefaults;
        const formatSeconds = (ms) => (Math.max(0, ms || 0) / 1000).toFixed(2);
        const formatSpeed = (speed) => (speed ?? METEOR_MIN_SPEED).toFixed(2);
        const formatRadius = (radius) => Math.round(radius ?? METEOR_MIN_RADIUS);

        const listContent = meteors.length
          ? `<div class="meteor-list">${meteors.map((m, i) => {
              const selectedClass = i === selectedIndex ? ' selected' : '';
              return `<button type="button" data-meteor-select="${i}" class="meteor-choice${selectedClass}">Meteor ${i + 1}</button>`;
            }).join('')}</div>`
          : '<div class="meteor-empty">No meteors placed yet.</div>';

        const selectedContent = hasSelection
          ? [
              `<label>Arrival time (s)<input type="number" step="0.1" min="0" data-meteor-scope="selected" data-field="startMs" value="${formatSeconds(selected.startMs)}"></label>`,
              `<label>Warning lead (s)<input type="number" step="0.1" min="0" data-meteor-scope="selected" data-field="warningLeadMs" value="${formatSeconds(selected.warningLeadMs)}"></label>`,
              `<label>Speed (px/ms)<input type="number" step="0.01" min="${METEOR_MIN_SPEED}" max="${METEOR_MAX_SPEED}" data-meteor-scope="selected" data-field="speed" value="${formatSpeed(selected.speed)}"></label>`,
              `<label>Size (px radius)<input type="number" step="1" min="${METEOR_MIN_RADIUS}" max="${METEOR_MAX_RADIUS}" data-meteor-scope="selected" data-field="radius" value="${formatRadius(selected.radius)}"></label>`,
            ].join('')
          : '<div class="meteor-empty">Click a meteor path to edit its timing, warning, speed, and size.</div>';

        const defaultsContent = [
          `<label>Arrival time (s)<input type="number" step="0.1" min="0" data-meteor-scope="defaults" data-field="startMs" value="${formatSeconds(defaults.startMs)}"></label>`,
          `<label>Warning lead (s)<input type="number" step="0.1" min="0" data-meteor-scope="defaults" data-field="warningLeadMs" value="${formatSeconds(defaults.warningLeadMs)}"></label>`,
          `<label>Speed (px/ms)<input type="number" step="0.01" min="${METEOR_MIN_SPEED}" max="${METEOR_MAX_SPEED}" data-meteor-scope="defaults" data-field="speed" value="${formatSpeed(defaults.speed)}"></label>`,
          `<label>Size (px radius)<input type="number" step="1" min="${METEOR_MIN_RADIUS}" max="${METEOR_MAX_RADIUS}" data-meteor-scope="defaults" data-field="radius" value="${formatRadius(defaults.radius)}"></label>`,
        ].join('');

        return `
          <div class="meteor-controls">
            <div class="meteor-section">
              <h4>Placed Meteors</h4>
              ${listContent}
            </div>
            <div class="meteor-section">
              <h4>Selected Meteor</h4>
              ${selectedContent}
            </div>
            <div class="meteor-section">
              <h4>Defaults for New Meteors</h4>
              ${defaultsContent}
            </div>
          </div>
        `;
      }

      function attachMeteorEditorEvents() {
        const selectButtons = editorPanel.querySelectorAll('[data-meteor-select]');
        selectButtons.forEach((btn) => {
          btn.addEventListener('click', () => {
            const index = parseInt(btn.getAttribute('data-meteor-select'), 10);
            if (Number.isNaN(index)) return;
            editorState.selectedMeteor = index;
            updateEditorOverlay();
          });
        });
        const inputs = editorPanel.querySelectorAll('input[data-meteor-scope]');
        inputs.forEach((input) => {
          input.addEventListener('change', handleMeteorInputEvent);
          input.addEventListener('blur', handleMeteorInputEvent);
        });
      }

      function handleMeteorInputEvent(event) {
        const input = event.target;
        if (!(input instanceof HTMLInputElement)) return;
        const scope = input.getAttribute('data-meteor-scope');
        const field = input.getAttribute('data-field');
        if (!scope || !field) return;
        let raw = parseFloat(input.value);
        if (Number.isNaN(raw)) {
          updateEditorOverlay();
          return;
        }
        const applySeconds = field === 'startMs' || field === 'warningLeadMs';
        if (applySeconds) {
          raw = Math.max(0, raw) * 1000;
        }
        if (field === 'speed') {
          raw = Math.max(METEOR_MIN_SPEED, Math.min(METEOR_MAX_SPEED, raw));
        } else if (field === 'radius') {
          raw = Math.max(METEOR_MIN_RADIUS, Math.min(METEOR_MAX_RADIUS, Math.round(raw)));
        } else if (field === 'startMs' || field === 'warningLeadMs') {
          raw = Math.max(0, raw);
        }

        if (scope === 'selected') {
          const changed = adjustSelectedMeteor((meteor) => {
            if (field === 'startMs') {
              meteor.startMs = raw;
              if (meteor.warningLeadMs > meteor.startMs) {
                meteor.warningLeadMs = meteor.startMs;
              }
            } else if (field === 'warningLeadMs') {
              meteor.warningLeadMs = Math.min(meteor.startMs, raw);
            } else {
              meteor[field] = raw;
            }
            return true;
          });
          if (!changed) {
            updateEditorOverlay();
            return;
          }
          terrain.dirtyRender = true;
        } else if (scope === 'defaults') {
          const defaults = editorState.meteorDefaults;
          if (!defaults) return;
          if (field === 'startMs') {
            defaults.startMs = raw;
            if (defaults.warningLeadMs > defaults.startMs) {
              defaults.warningLeadMs = defaults.startMs;
            }
          } else if (field === 'warningLeadMs') {
            defaults.warningLeadMs = Math.min(defaults.startMs, raw);
          } else {
            defaults[field] = raw;
          }
          if (editorState.pendingMeteor) {
            if (field === 'startMs') {
              editorState.pendingMeteor.startMs = raw;
              if (editorState.pendingMeteor.warningLeadMs > raw) {
                editorState.pendingMeteor.warningLeadMs = raw;
              }
            } else if (field === 'warningLeadMs') {
              editorState.pendingMeteor.warningLeadMs = Math.min(editorState.pendingMeteor.startMs, raw);
            } else {
              editorState.pendingMeteor[field] = raw;
            }
          }
          terrain.dirtyRender = true;
        }
        updateEditorOverlay();
      }

      function labelForPlacement(key) {
        switch (key) {
          case 'spawn': return 'Spawn point';
          case 'landing': return 'Landing zone';
          case 'terrain': return 'Terrain';
          case 'blackHole': return 'Black hole';
          case 'meteor': return 'Meteor';
          default: return key;
        }
      }
      // --- End terrain helpers ---

      // --- Parallax background images ---
      // Place space_far.png and space_near.png next to this HTML file
      const bgFar = new Image();  bgFar.src = 'space_far.png';   // subtle stars
      const bgNear = new Image(); bgNear.src = 'space_near.png'; // denser stars + nebula

      // Tile an image across the canvas with an offset (no global translate)
      function tileLayer(img, offX, offY) {
        if (!img.complete) return; // skip until loaded
        const iw = img.width, ih = img.height;
        // Normalize offsets to [-iw, 0) and [-ih, 0)
        let x0 = ((offX % iw) + iw) % iw - iw;
        let y0 = ((offY % ih) + ih) % ih - ih;
        // Keep pixel art crisp
        const prev = ctx.imageSmoothingEnabled;
        ctx.imageSmoothingEnabled = false;
        for (let x = x0; x < width; x += iw) {
          for (let y = y0; y < height; y += ih) {
            ctx.drawImage(img, x, y);
          }
        }
        ctx.imageSmoothingEnabled = prev;
      }
      // --- End parallax helpers ---

      // Game state
      const lander = {
        x: width / 2,
        y: 50,
        vx: 0,
        vy: 0,
        angle: 0, // in radians
        // angular velocity accumulates when rotating; in radians per ms
        angularVelocity: 0,
        // rotational acceleration applied when pressing left/right; in radians per ms^2
        rotateAccel: 0.00001,
        // damping factor applied every frame to gradually slow rotation
        rotateDamping: 0.99,
        fuel: 100,
        width: 20,
        height: 30,
        thrustPower: 0.0007,
        // rotateSpeed is no longer used; we keep it commented for reference
        // rotateSpeed: 0.04,
      };
      lander.legLength = 10;
      lander.legAttachOffset = lander.width / 4;
      lander.legFootOffset = lander.width / 2;

let g = 0.00015; // gravity (tunable, slightly lower)
      let lastTime = null;
      let keys = {};
let gameOver = false;
let message = '';
let exploded = false;
let debris = []; // explosion pieces
let landed = false; // success state
let winFx = []; // celebration particles
let padFlash = 0; // ms of pad glow remaining
      let shouldRegen = false; // regenerate terrain only after choosing to advance
let padPulsePhase = 0;
let padGlowAlpha = 0.525;
let smoke = []; // engine dust/smoke particles near ground
let blastSmoke = []; // post-explosion embers smoke
let wreckFlames = []; // persistent burning wreckage
let bombs = []; // active bombs dropped by the lander
let bombCooldown = 0; // ms remaining until next bomb can be dropped
let meteorTimeline = []; // queued meteor events awaiting spawn
let meteorWarnings = []; // active warning ghosts
let activeMeteors = []; // live meteors in-flight
let meteorTime = 0; // ms since level start for meteor scheduling
let activeBlackHoles = [];
let blackHolePhase = 0;

let camX = null;
let camY = null;

      function resizeCanvas() {
        let hudReserve = 0;
        if (touchControlsVisible && touchControls) {
          const rect = touchControls.getBoundingClientRect();
          hudReserve = Math.ceil(rect.height);
        }
        const availWidth = Math.max(0, window.innerWidth);
        const availHeight = Math.max(window.innerHeight - hudReserve, 0);
        const maxWidth = Math.min(availWidth, MAX_VIEW_WIDTH);
        const maxHeight = Math.min(availHeight, MAX_VIEW_HEIGHT);
        const minWidthCap = Math.min(MIN_VIEW_WIDTH, availWidth);
        const minHeightCap = Math.min(MIN_VIEW_HEIGHT, availHeight);

        let targetWidth = maxWidth;
        let targetHeight = maxHeight;

        if (targetWidth < minWidthCap) {
          targetWidth = minWidthCap;
        }
        if (targetHeight < minHeightCap) {
          targetHeight = minHeightCap;
        }

        if (availWidth > 0) {
          targetWidth = Math.min(targetWidth, availWidth);
        }
        if (availHeight > 0) {
          targetHeight = Math.min(targetHeight, availHeight);
        }

        canvas.width = Math.max(1, Math.round(targetWidth));
        canvas.height = Math.max(1, Math.round(targetHeight));
        canvas.style.width = `${canvas.width}px`;
        canvas.style.height = `${canvas.height}px`;
        width = canvas.width;
        height = canvas.height;

        camX = null;
        camY = null;
        editorState.camX = null;
        editorState.camY = null;
      }

      function getLanderContactPoints() {
        const cos = Math.cos(lander.angle);
        const sin = Math.sin(lander.angle);
        const localPoints = [
          { type: 'body', lx: 0, ly: lander.height / 2 },
          { type: 'body', lx: -lander.legAttachOffset, ly: lander.height / 2 },
          { type: 'body', lx: lander.legAttachOffset, ly: lander.height / 2 },
          { type: 'foot', lx: -lander.legFootOffset, ly: lander.height / 2 + lander.legLength },
          { type: 'foot', lx: lander.legFootOffset, ly: lander.height / 2 + lander.legLength },
        ];
        return localPoints.map(pt => {
          const x = lander.x + pt.lx * cos - pt.ly * sin;
          const y = lander.y + pt.lx * sin + pt.ly * cos;
          return { ...pt, x, y };
        });
      }

      function canDropBomb() {
        if (gameOver || landed) return false;
        if (bombCooldown > 0) return false;
        if (bombs.length >= BOMB_MAX_ACTIVE) return false;
        return true;
      }

      function dropBomb() {
        if (!canDropBomb()) return;
        bombCooldown = BOMB_DROP_COOLDOWN;
        const cos = Math.cos(lander.angle);
        const sin = Math.sin(lander.angle);
        const baseOffset = lander.height / 2 + 6;
        const dropX = lander.x + sin * baseOffset;
        const dropY = lander.y + cos * baseOffset + 4;
        const inheritVx = lander.vx;
        const inheritVy = lander.vy;
        const bomb = {
          x: dropX,
          y: dropY,
          vx: inheritVx + sin * 0.006,
          vy: inheritVy + Math.max(0.012, cos * 0.006) + 0.01,
          fuseMs: BOMB_FUSE_MS,
          armingMs: BOMB_ARM_DELAY,
          blinkPhase: 0,
          blinkRate: BOMB_BLINK_BASE,
          lastFuseRatio: 1,
          radius: 7,
          grounded: false,
          detonated: false,
        };
        bombs.push(bomb);
      }

      const audio = (() => {
        const AudioCtx = window.AudioContext || window.webkitAudioContext;
        const levels = {
          master: 0.4,
          thruster: 0.27,
          explosion: 0.9,
          death: 0.3,
          win: 0.28,
          meteorWarn: 0.32,
          meteorImpact: 0.88,
        };
        const state = {
          ctx: null,
          master: null,
          unlocked: false,
          thruster: {
            osc: null,
            gain: null,
            noiseGain: null,
            filter: null,
            active: false,
          },
        };

        function ensureContext() {
          if (!AudioCtx) return null;
          if (!state.ctx) {
            state.ctx = new AudioCtx();
            state.master = state.ctx.createGain();
            state.master.gain.value = levels.master;
            state.master.connect(state.ctx.destination);
          }
          return state.ctx;
        }

        function createNoiseBuffer(ctx) {
          const buffer = ctx.createBuffer(1, ctx.sampleRate, ctx.sampleRate);
          const data = buffer.getChannelData(0);
          for (let i = 0; i < data.length; i++) {
            data[i] = Math.random() * 2 - 1;
          }
          return buffer;
        }

        function ensureThruster() {
          const ctx = ensureContext();
          if (!ctx) return null;
          if (!state.thruster.osc) {
            const mainOsc = ctx.createOscillator();
            mainOsc.type = 'sawtooth';
            const harmOsc = ctx.createOscillator();
            harmOsc.type = 'square';

            const filter = ctx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 1600;
            filter.Q.value = 0.7;

            const bodyGain = ctx.createGain();
            bodyGain.gain.value = 0;

            const noise = ctx.createBufferSource();
            noise.buffer = createNoiseBuffer(ctx);
            noise.loop = true;

            const noiseFilter = ctx.createBiquadFilter();
            noiseFilter.type = 'highpass';
            noiseFilter.frequency.value = 2200;
            noiseFilter.Q.value = 0.9;

            const noiseGain = ctx.createGain();
            noiseGain.gain.value = 0;

            mainOsc.connect(filter);
            harmOsc.connect(filter);
            filter.connect(bodyGain);
            bodyGain.connect(state.master);

            noise.connect(noiseFilter);
            noiseFilter.connect(noiseGain);
            noiseGain.connect(state.master);

            mainOsc.start();
            harmOsc.start();
            noise.start();

            state.thruster.osc = mainOsc;
            state.thruster.harm = harmOsc;
            state.thruster.noise = noise;
            state.thruster.noiseFilter = noiseFilter;
            state.thruster.filter = filter;
            state.thruster.gain = bodyGain;
            state.thruster.noiseGain = noiseGain;
          }
          return state.thruster;
        }

        function rampGain(gainNode, target, timeConstant) {
          const ctx = state.ctx;
          if (!ctx) return;
          const now = ctx.currentTime;
          gainNode.gain.cancelScheduledValues(now);
          gainNode.gain.setTargetAtTime(target, now, timeConstant);
        }

        function playNoiseBurst(duration, frequency, q, startGain, endTime) {
          const ctx = ensureContext();
          if (!ctx) return;
          const length = Math.max(0.05, duration);
          const buffer = ctx.createBuffer(1, Math.floor(ctx.sampleRate * length), ctx.sampleRate);
          const data = buffer.getChannelData(0);
          for (let i = 0; i < data.length; i++) {
            const t = i / data.length;
            const envelope = Math.pow(1 - t, 2);
            data[i] = (Math.random() * 2 - 1) * envelope;
          }
          const source = ctx.createBufferSource();
          source.buffer = buffer;
          source.playbackRate.value = 1;
          const filter = ctx.createBiquadFilter();
          filter.type = 'bandpass';
          filter.frequency.value = frequency;
          filter.Q.value = q;
          const gain = ctx.createGain();
          gain.gain.setValueAtTime(startGain, ctx.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + endTime);
          source.connect(filter);
          filter.connect(gain);
          gain.connect(state.master);
          source.start();
          source.stop(ctx.currentTime + endTime);
        }

        return {
          unlock() {
            const ctx = ensureContext();
            if (!ctx || state.unlocked) return;
            if (ctx.state === 'suspended') {
              ctx.resume();
            }
            state.unlocked = true;
          },
          setThrusterActive(on) {
            const thruster = ensureThruster();
            if (!thruster) return;
            if (state.ctx.state === 'suspended') return;
            if (thruster.active === on) return;
            const targetBody = on ? levels.thruster : 0.0001;
            const targetNoise = on ? levels.thruster * 0.75 : 0.0001;
            rampGain(thruster.gain, targetBody, on ? 0.07 : 0.08);
            if (thruster.noiseGain) {
              rampGain(thruster.noiseGain, targetNoise, on ? 0.12 : 0.09);
            }
            if (on) {
              const now = state.ctx.currentTime;
              const baseFreq = 260 + Math.random() * 30;
              const jitter = (Math.random() - 0.5) * 25;
              thruster.osc.frequency.setTargetAtTime(baseFreq + jitter, now, 0.18);
              thruster.harm.frequency.setTargetAtTime((baseFreq * 1.95) + jitter * 0.5, now, 0.18);
              thruster.osc.detune.setTargetAtTime((Math.random() - 0.5) * 70, now, 0.35);
              thruster.harm.detune.setTargetAtTime((Math.random() - 0.5) * 45, now, 0.3);
              thruster.filter.frequency.setTargetAtTime(2200 + Math.random() * 600, now, 0.28);
              if (thruster.filter.Q) {
                thruster.filter.Q.cancelScheduledValues(now);
                thruster.filter.Q.setTargetAtTime(0.8 + Math.random() * 0.25, now, 0.3);
              }
              thruster.noiseFilter.frequency.setTargetAtTime(3200 + Math.random() * 900, now, 0.3);
              if (thruster.noiseFilter.Q) {
                thruster.noiseFilter.Q.cancelScheduledValues(now);
                thruster.noiseFilter.Q.setTargetAtTime(0.9 + Math.random() * 0.4, now, 0.25);
              }
            }
            thruster.active = on;
          },
          stopThrusterImmediate() {
            if (!state.thruster.gain) return;
            const ctx = state.ctx;
            if (!ctx) return;
            const now = ctx.currentTime;
            state.thruster.gain.gain.cancelScheduledValues(now);
            state.thruster.gain.gain.setValueAtTime(0.0001, now);
            if (state.thruster.noiseGain) {
              state.thruster.noiseGain.gain.cancelScheduledValues(now);
              state.thruster.noiseGain.gain.setValueAtTime(0.0001, now);
            }
            state.thruster.active = false;
          },
          playExplosion() {
            const ctx = ensureContext();
            if (!ctx) return;
            if (ctx.state === 'suspended') return;
            playNoiseBurst(0.8, 180, 0.8, levels.explosion, 0.8);
            const boomOsc = ctx.createOscillator();
            boomOsc.type = 'sine';
            const boomGain = ctx.createGain();
            const now = ctx.currentTime;
            boomOsc.frequency.setValueAtTime(90, now);
            boomOsc.frequency.exponentialRampToValueAtTime(35, now + 0.8);
            boomGain.gain.setValueAtTime(levels.explosion * 0.6, now);
            boomGain.gain.exponentialRampToValueAtTime(0.0001, now + 0.9);
            boomOsc.connect(boomGain);
            boomGain.connect(state.master);
            boomOsc.start(now);
            boomOsc.stop(now + 1);
          },
          playDeathTone() {
            const ctx = ensureContext();
            if (!ctx) return;
            if (ctx.state === 'suspended') return;
            const osc = ctx.createOscillator();
            osc.type = 'triangle';
            const gain = ctx.createGain();
            const now = ctx.currentTime + 0.15;
            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(levels.death, now + 0.1);
            gain.gain.exponentialRampToValueAtTime(0.0001, now + 1.2);
            osc.frequency.setValueAtTime(320, now);
            osc.frequency.linearRampToValueAtTime(90, now + 0.9);
            osc.connect(gain);
            gain.connect(state.master);
            osc.start(now);
            osc.stop(now + 1.3);
          },
          playWinChime() {
            const ctx = ensureContext();
            if (!ctx) return;
            if (ctx.state === 'suspended') return;
            const notes = [523.25, 659.25, 784, 1046.5];
            const now = ctx.currentTime;
            notes.forEach((freq, i) => {
              const osc = ctx.createOscillator();
              osc.type = 'sine';
              const gain = ctx.createGain();
              const start = now + i * 0.08;
              osc.frequency.setValueAtTime(freq, start);
              gain.gain.setValueAtTime(0, start);
              gain.gain.linearRampToValueAtTime(levels.win, start + 0.05);
              gain.gain.exponentialRampToValueAtTime(0.0001, start + 0.45);
              osc.connect(gain);
              gain.connect(state.master);
              osc.start(start);
              osc.stop(start + 0.5);
            });
          },
          playMeteorWarning() {
            const ctx = ensureContext();
            if (!ctx) return;
            if (ctx.state === 'suspended') return;
            const osc = ctx.createOscillator();
            osc.type = 'sine';
            const gain = ctx.createGain();
            const now = ctx.currentTime;
            osc.frequency.setValueAtTime(920, now);
            osc.frequency.exponentialRampToValueAtTime(450, now + 0.45);
            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(levels.meteorWarn, now + 0.05);
            gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.45);
            osc.connect(gain);
            gain.connect(state.master);
            osc.start(now);
            osc.stop(now + 0.5);
          },
          playMeteorImpact() {
            const ctx = ensureContext();
            if (!ctx) return;
            if (ctx.state === 'suspended') return;
            playNoiseBurst(1.1, 160, 0.7, levels.meteorImpact, 1.2);
            const boom = ctx.createOscillator();
            boom.type = 'sine';
            const rumble = ctx.createOscillator();
            rumble.type = 'triangle';
            const gain = ctx.createGain();
            const rumbleGain = ctx.createGain();
            const now = ctx.currentTime;
            boom.frequency.setValueAtTime(130, now);
            boom.frequency.exponentialRampToValueAtTime(46, now + 1.2);
            rumble.frequency.setValueAtTime(48, now);
            rumble.frequency.exponentialRampToValueAtTime(28, now + 1.3);
            gain.gain.setValueAtTime(levels.meteorImpact * 0.65, now);
            gain.gain.exponentialRampToValueAtTime(0.0001, now + 1.3);
            rumbleGain.gain.setValueAtTime(levels.meteorImpact * 0.35, now);
            rumbleGain.gain.exponentialRampToValueAtTime(0.0001, now + 1.5);
            boom.connect(gain);
            rumble.connect(rumbleGain);
            gain.connect(state.master);
            rumbleGain.connect(state.master);
            boom.start(now);
            boom.stop(now + 1.4);
            rumble.start(now);
            rumble.stop(now + 1.6);
          },
          reset() {
            this.stopThrusterImmediate();
          },
        };
      })();

      // Live-tunable parameters and debug
      const tune = {
        camLag: 0.004,      // smoothing factor: k = min(1, dt*camLag)
        lookGainX: 120,     // px per (vx) for look-ahead
        lookGainY: 80,      // px per (vy)
        lookCap: 80,        // max look-ahead in px
        parallaxFar: 0.08,
        parallaxNear: 0.18,
        bounce: 0.35,
        friction: 0.78,
      };

      function updateEditorOverlay() {
        if (appMode === APP_MODE.EDITOR) {
          if (editorPanel) {
            editorPanel.classList.remove('hidden');
            editorPanel.setAttribute('aria-hidden', 'false');
          }
          const option = editorState.placementOptions[editorState.placementIndex];
          const placementLabel = labelForPlacement(option);
          const toolTitle = `${placementLabel} Tool`;
          const lines = ['Toolbar buttons or 1-5 select tools (mouse wheel cycles).'];
          if (option === 'terrain') {
            lines.push('Tap or click to sculpt terrain (hold Alt to carve).');
            lines.push('Drag to paint continuous strokes; release to finish.');
          } else if (option === 'spawn') {
            lines.push('Tap or click: place the spawn point');
            lines.push('Drag: reposition the spawn point');
          } else if (option === 'landing') {
            lines.push('Tap or click: place the landing zone');
            lines.push('Drag: slide the landing zone');
          } else if (option === 'blackHole') {
            lines.push('Tap or click: place black hole (Alt + tap/click removes one)');
            lines.push('Drag: move the nearest black hole');
          } else if (option === 'meteor') {
            lines.push('Tap + drag: aim meteor (release to confirm)');
            lines.push('Alt + tap/click: delete nearest meteor');
            lines.push('Drag start/end handles: adjust spawn or impact');
            lines.push('Drag path: move the entire meteor');
            lines.push('[/ ] radius  |  -/ = speed');
            lines.push(`,/ . warning lead  |  ;/' (apostrophe) start time`);
            lines.push('Select a meteor or defaults in the panel to edit timing, warning, speed, and size.');
          } else {
            lines.push(`Tap or click: place ${placementLabel}`);
          }
          lines.push('R: test this level');
          lines.push('Esc: back to menu');
          if (option === 'meteor') {
            const panelHtml = buildMeteorEditorControls();
            updateEditorPanel(lines, panelHtml, toolTitle);
            attachMeteorEditorEvents();
          } else {
            updateEditorPanel(lines, '', toolTitle);
          }
        } else if (appMode === APP_MODE.TEST) {
          if (editorPanel) {
            editorPanel.classList.remove('hidden');
            editorPanel.setAttribute('aria-hidden', 'false');
          }
          updateEditorPanel(
            [
              'Arrow keys: fly the lander',
              'R: restart test',
              'Esc: return to editor',
            ],
            '',
            'Test Flight'
          );
        } else {
          if (editorPanel) {
            editorPanel.classList.add('hidden');
            editorPanel.setAttribute('aria-hidden', 'true');
          }
          updateEditorPanel([], '', null);
        }
        updateEditorToolButtons();
      }

      function enterMenu() {
        appMode = APP_MODE.MENU;
        hidePostLevelMenu();
        updateTouchControlsForMode();
        editorState.active = false;
        startMenu.classList.remove('hidden');
        updateEditorOverlay();
        clearInfoMessage();
        audio.setThrusterActive(false);
        keys.Space = false;
        for (const key of Object.keys(keys)) {
          if (keys[key]) keys[key] = false;
        }
        resetControlKeyState();
      }

      function enterPlay() {
        appMode = APP_MODE.PLAY;
        hidePostLevelMenu();
        updateTouchControlsForMode();
        startMenu.classList.add('hidden');
        editorState.active = false;
        generateTerrain(0);
        resetGame(true);
        updateEditorOverlay();
      }

      function enterEditor(resetTerrain = false) {
        appMode = APP_MODE.EDITOR;
        hidePostLevelMenu();
        updateTouchControlsForMode();
        startMenu.classList.add('hidden');
        initEditorTerrain(resetTerrain);
        resetGame(false, {
          spawn: { ...editorState.spawn },
          customTerrain: true,
          camera: { x: editorState.spawn.x, y: editorState.spawn.y },
        });
        shouldRegen = false;
        exploded = true; // hide lander during editing
        camX = editorState.camX;
        camY = editorState.camY;
        editorState.cursorWorld = null;
        editorState.isPainting = false;
        editorState.hasMoved = false;
        editorState.lastPointer = null;
        editorState.pendingPaintStart = null;
        editorState.activeBrushMode = 'add';
        updateEditorOverlay();
      }

      function enterEditorTest() {
        const startingFromEditor = appMode === APP_MODE.EDITOR;
        if (!startingFromEditor) {
          restoreTerrainFromBaseline();
        }
        hidePostLevelMenu();
        if (startingFromEditor) {
          editorState.camX = camX;
          editorState.camY = camY;
          editorState.testBaseline = {
            solids: cloneSolidsArray(terrain.solids),
            blackHoles: cloneBlackHoles(terrain.blackHoles),
            meteors: cloneMeteors(terrain.meteors),
            pad: { x: pad.x, y: pad.y, w: pad.w, h: pad.h },
          };
        } else if (editorState.testBaseline) {
          const solidSnapshot = editorState.testBaseline.solids || editorState.testBaseline;
          if (solidSnapshot.length !== terrain.solids.length) {
            terrain.solids = new Uint8Array(solidSnapshot.length);
          }
          terrain.solids.set(solidSnapshot);
          terrain.blackHoles = cloneBlackHoles(editorState.testBaseline.blackHoles);
          editorState.blackHoles = terrain.blackHoles;
          terrain.meteors = cloneMeteors(editorState.testBaseline.meteors);
          editorState.meteors = terrain.meteors;
          if (editorState.testBaseline.pad) {
            const baselinePad = editorState.testBaseline.pad;
            pad.x = baselinePad.x;
            pad.y = baselinePad.y;
            pad.w = baselinePad.w;
            pad.h = baselinePad.h;
          }
          alignPadToSurface(pad.x + pad.w / 2, pad.y + pad.h);
        }
        appMode = APP_MODE.TEST;
        updateTouchControlsForMode();
        startMenu.classList.add('hidden');
        exploded = false;
        terrain.meteors = cloneMeteors(editorState.meteors);
        resetGame(false, {
          spawn: { ...editorState.spawn },
          customTerrain: true,
          camera: { x: editorState.spawn.x, y: editorState.spawn.y },
        });
        shouldRegen = false;
        editorState.pendingPaintStart = null;
        updateEditorOverlay();
      }

      function returnToEditorFromTest() {
        if (editorState.testBaseline) {
          editorState.grid = editorState.grid || {};
          const solidSnapshot = editorState.testBaseline.solids || editorState.testBaseline;
          editorState.grid.solids = cloneSolidsArray(solidSnapshot);
          editorState.grid.blackHoles = cloneBlackHoles(editorState.testBaseline.blackHoles);
          editorState.grid.meteors = cloneMeteors(editorState.testBaseline.meteors);
        }
        hidePostLevelMenu();
        enterEditor(false);
        editorState.testBaseline = null;
      }

      menuPlayBtn.addEventListener('click', () => {
        audio.unlock();
        enterPlay();
      });

      menuEditorBtn.addEventListener('click', () => {
        audio.unlock();
        enterEditor(true);
      });

      // Debug overlay is off by default
      let showDebug = false;

      // Store keys by their .key value and handle immediate restart on R
      window.addEventListener('keydown', (e) => {
        audio.unlock();
        const key = e.key === 'Spacebar' ? ' ' : e.key;
        const normalizedKey = key === ' ' ? 'Space' : key;
        const isEditorInput = editorPanel.contains(e.target) && e.target instanceof HTMLInputElement;
        if (key === ' ' || key === 'Space') {
          e.preventDefault();
        }
        if (key === 'Escape') {
          if (appMode === APP_MODE.TEST) {
            e.preventDefault();
            returnToEditorFromTest();
            return;
          }
          if (appMode === APP_MODE.EDITOR) {
            e.preventDefault();
            enterMenu();
            return;
          }
          if (appMode === APP_MODE.PLAY) {
            e.preventDefault();
            enterMenu();
            return;
          }
        }
        keys[key] = true;
        if (TOUCH_CONTROL_KEYS.has(normalizedKey)) {
          physicalKeyState[normalizedKey] = true;
          if (normalizedKey !== key) {
            keys[normalizedKey] = true;
          }
        }
        const gameplayMode = appMode === APP_MODE.PLAY || appMode === APP_MODE.TEST;
        if ((key === ' ' || key === 'Space') && gameplayMode) {
          if (!e.repeat) {
            keys.Space = true;
            if (typeof canDropBomb === 'function' && canDropBomb()) {
              dropBomb();
            }
          }
          return;
        }
        if (key === 'r' || key === 'R') {
          e.preventDefault();
          if (appMode === APP_MODE.PLAY) {
            shouldRegen = false;
            resetGame(true);
          } else if (appMode === APP_MODE.EDITOR) {
            enterEditorTest();
          } else if (appMode === APP_MODE.TEST) {
            enterEditorTest();
          }
          return;
        }
        if (key === 'n' || key === 'N') {
          if (appMode === APP_MODE.PLAY && gameOver) {
            e.preventDefault();
            advanceToNextLevel();
            return;
          }
        }
        if (appMode === APP_MODE.EDITOR) {
          if (!isEditorInput) {
            const placementMap = { '1': 'spawn', '2': 'landing', '3': 'terrain', '4': 'blackHole', '5': 'meteor' };
            if (placementMap[key]) {
              const targetIndex = editorState.placementOptions.indexOf(placementMap[key]);
              if (targetIndex !== -1) {
                editorState.placementIndex = targetIndex;
                editorState.isPainting = false;
                editorState.hasMoved = false;
                editorState.pendingPaintStart = null;
                editorState.lastPointer = null;
                if (placementMap[key] !== 'meteor') {
                  editorCancelPendingMeteor();
                }
                updateEditorOverlay();
              }
              e.preventDefault();
              return;
            }
          }
          const placement = editorState.placementOptions[editorState.placementIndex];
          if (placement === 'meteor' && !isEditorInput) {
            const adjustDefault = (keyName, delta, min, max) => {
              const next = Math.max(min, Math.min(max, editorState.meteorDefaults[keyName] + delta));
              editorState.meteorDefaults[keyName] = next;
              return next;
            };
            const applyToSelection = (mutator, fallbackKey, delta, min, max) => {
              const changed = adjustSelectedMeteor(mutator);
              if (!changed && fallbackKey) {
                const next = adjustDefault(fallbackKey, delta, min, max);
                if (editorState.pendingMeteor) {
                  editorState.pendingMeteor[fallbackKey] = next;
                }
              }
            };
            switch (key) {
              case '[':
                e.preventDefault();
                applyToSelection(m => { m.radius = Math.max(METEOR_MIN_RADIUS, m.radius - 2); }, 'radius', -2, METEOR_MIN_RADIUS, METEOR_MAX_RADIUS);
                break;
              case ']':
                e.preventDefault();
                applyToSelection(m => { m.radius = Math.max(METEOR_MIN_RADIUS, Math.min(METEOR_MAX_RADIUS, m.radius + 2)); }, 'radius', 2, METEOR_MIN_RADIUS, METEOR_MAX_RADIUS);
                break;
              case '-':
                e.preventDefault();
                applyToSelection(m => { m.speed = Math.max(METEOR_MIN_SPEED, m.speed - 0.02); }, 'speed', -0.02, METEOR_MIN_SPEED, METEOR_MAX_SPEED);
                break;
              case '=':
              case '+':
                e.preventDefault();
                applyToSelection(m => { m.speed = Math.max(METEOR_MIN_SPEED, Math.min(METEOR_MAX_SPEED, m.speed + 0.02)); }, 'speed', 0.02, METEOR_MIN_SPEED, METEOR_MAX_SPEED);
                break;
              case ',':
                e.preventDefault();
                applyToSelection(m => { m.warningLeadMs = Math.max(0, m.warningLeadMs - 250); }, 'warningLeadMs', -250, 0, 20000);
                break;
              case '.':
                e.preventDefault();
                applyToSelection(m => { m.warningLeadMs = Math.max(0, m.warningLeadMs + 250); }, 'warningLeadMs', 250, 0, 20000);
                break;
              case ';':
                e.preventDefault();
                applyToSelection(m => { m.startMs = Math.max(0, m.startMs - 250); }, 'startMs', -250, 0, 60000);
                break;
              case "'":
                e.preventDefault();
                applyToSelection(m => { m.startMs = Math.max(0, m.startMs + 250); }, 'startMs', 250, 0, 60000);
                break;
            }
          }
        }
        // --- Tuning keys ---
        const step = (v, s, min, max) => Math.max(min, Math.min(max, v + s));
        if (!gameplayMode) return;
        switch (key) {
          case 'h': case 'H': showDebug = !showDebug; break;
          case 'q': tune.camLag = step(tune.camLag,  0.001, 0.0005, 0.02); break;
          case 'a': tune.camLag = step(tune.camLag, -0.001, 0.0005, 0.02); break;
          case 'w': tune.lookGainX = step(tune.lookGainX,  10, 0, 600); break;
          case 's': tune.lookGainX = step(tune.lookGainX, -10, 0, 600); break;
          case 'e': tune.lookGainY = step(tune.lookGainY,  10, 0, 600); break;
          case 'd': tune.lookGainY = step(tune.lookGainY, -10, 0, 600); break;
          case 'r': tune.lookCap   = step(tune.lookCap,    5, 0, 200); break;
          case 'f': tune.lookCap   = step(tune.lookCap,   -5, 0, 200); break;
          case 't': tune.parallaxFar  = step(tune.parallaxFar,  0.01, 0, 1); break;
          case 'g': tune.parallaxFar  = step(tune.parallaxFar, -0.01, 0, 1); break;
          case 'y': tune.parallaxNear = step(tune.parallaxNear, 0.01, 0, 1); break;
          case 'x': tune.parallaxNear = step(tune.parallaxNear,-0.01, 0, 1); break;
          case 'u': lander.thrustPower = step(lander.thrustPower,  0.0001, 0, 0.005); break;
          case 'j': lander.thrustPower = step(lander.thrustPower, -0.0001, 0, 0.005); break;
          case 'i': lander.rotateAccel = step(lander.rotateAccel,  0.0000002, 0, 0.00002); break;
          case 'k': lander.rotateAccel = step(lander.rotateAccel, -0.0000002, 0, 0.00002); break;
          case 'o': lander.rotateDamping = step(lander.rotateDamping,  0.01, 0.80, 1.00); break;
          case 'l': lander.rotateDamping = step(lander.rotateDamping, -0.01, 0.80, 1.00); break;
          case 'p': g = step(g,  0.00005, 0, 0.005); break;
          case ';': g = step(g, -0.00005, 0, 0.005); break;
          case 'b': tune.bounce = step(tune.bounce,  0.05, 0, 1); break;
          case 'n': tune.bounce = step(tune.bounce, -0.05, 0, 1); break;
          case 'm': tune.friction = step(tune.friction,  0.05, 0, 1); break;
          case ',': tune.friction = step(tune.friction, -0.05, 0, 1); break;
        }
      });
      window.addEventListener('keyup', (e) => {
        const key = e.key === 'Spacebar' ? ' ' : e.key;
        const normalizedKey = key === ' ' ? 'Space' : key;
        if (key === ' ' || key === 'Space') {
          e.preventDefault();
        }
        if (TOUCH_CONTROL_KEYS.has(normalizedKey)) {
          physicalKeyState[normalizedKey] = false;
          if (normalizedKey !== key && keys[key]) {
            keys[key] = false;
          }
          syncCombinedKeyState(normalizedKey);
        } else {
          keys[key] = false;
        }
      });
      window.addEventListener('mousedown', () => audio.unlock());
      window.addEventListener('touchstart', () => audio.unlock(), { passive: true });
      window.addEventListener('blur', () => {
        resetControlKeyState();
        clearVirtualTouchState();
      });

      window.addEventListener('wheel', (e) => {
        if (appMode !== APP_MODE.EDITOR) return;
        if (!editorState.placementOptions.length) return;
        e.preventDefault();
        const direction = e.deltaY > 0 ? 1 : -1;
        const count = editorState.placementOptions.length;
        editorState.placementIndex = (editorState.placementIndex + direction + count) % count;
        updateEditorOverlay();
      }, { passive: false });

      function resetEditorPaintingState() {
        editorState.isPainting = false;
        editorState.hasMoved = false;
        editorState.pendingPaintStart = null;
        editorState.lastPointer = null;
      }

      function beginEditorInteraction(world, { altKey = false } = {}) {
        if (appMode !== APP_MODE.EDITOR) return;
        if (!editorState.placementOptions.length) return;
        editorState.cursorWorld = { ...world };
        editorState.dragging = null;
        const option = editorState.placementOptions[editorState.placementIndex];
        if (!option) {
          resetEditorPaintingState();
          return;
        }
        if (option === 'blackHole' && altKey) {
          editorRemoveBlackHole(world.x, world.y);
          resetEditorPaintingState();
          return;
        }
        if (option === 'meteor' && altKey) {
          if (!editorRemoveMeteor(world.x, world.y)) {
            editorState.selectedMeteor = -1;
          }
          editorCancelPendingMeteor();
          resetEditorPaintingState();
          return;
        }

        const spawnDist = Math.hypot(world.x - editorState.spawn.x, world.y - editorState.spawn.y);
        if (spawnDist <= 40) {
          editorState.dragging = {
            type: 'spawn',
            offsetX: editorState.spawn.x - world.x,
            offsetY: editorState.spawn.y - world.y,
          };
          resetEditorPaintingState();
          return;
        }

        const margin = 20;
        const padCenterX = pad.x + pad.w / 2;
        const padCenterY = pad.y + pad.h / 2;
        const withinPadX = world.x >= pad.x - margin && world.x <= pad.x + pad.w + margin;
        const withinPadY = world.y >= pad.y - margin && world.y <= pad.y + pad.h + margin;
        if (withinPadX && withinPadY) {
          editorState.dragging = {
            type: 'landing',
            offsetX: padCenterX - world.x,
            offsetY: padCenterY - world.y,
          };
          resetEditorPaintingState();
          return;
        }

        const handle = pickMeteorHandleAt(world.x, world.y);
        if (handle) {
          const meteors = ensureEditorMeteors();
          const meteor = meteors[handle.index];
          if (meteor) {
            editorState.selectedMeteor = handle.index;
            editorCancelPendingMeteor();
            editorState.isPlacingMeteor = false;
            editorState.pendingMeteor = null;
            editorState.dragging = {
              type: 'meteor',
              index: handle.index,
              handle: handle.handle,
              offsetX: handle.offsetX || 0,
              offsetY: handle.offsetY || 0,
              startPointer: handle.startPointer ? { ...handle.startPointer } : { ...world },
              initialSpawn: handle.initialSpawn ? { ...handle.initialSpawn } : { ...meteor.spawn },
              initialTarget: handle.initialTarget ? { ...handle.initialTarget } : { ...meteor.target },
            };
            updateEditorOverlay();
            resetEditorPaintingState();
            return;
          }
        }

        const hole = findBlackHoleNear(world.x, world.y, 1.15);
        if (hole) {
          const holes = ensureEditorBlackHoles();
          const index = holes.indexOf(hole);
          if (index !== -1) {
            editorState.dragging = {
              type: 'blackHole',
              index,
              offsetX: hole.x - world.x,
              offsetY: hole.y - world.y,
            };
            resetEditorPaintingState();
            return;
          }
        }

        if (option === 'blackHole') {
          editorPlaceBlackHole(world.x, world.y);
          resetEditorPaintingState();
          return;
        }

        if (option === 'meteor') {
          const selected = findMeteorIndexNear(world.x, world.y, 1.3);
          if (selected !== -1) {
            editorState.selectedMeteor = selected;
            editorCancelPendingMeteor();
            updateEditorOverlay();
            resetEditorPaintingState();
            return;
          }
          editorStartMeteorPlacement(world.x, world.y);
          return;
        }

        if (option === 'spawn') {
          editorPlaceSpawn(world.x, world.y);
          editorState.dragging = {
            type: 'spawn',
            offsetX: editorState.spawn.x - world.x,
            offsetY: editorState.spawn.y - world.y,
          };
          terrain.dirtyRender = true;
          resetEditorPaintingState();
          return;
        }

        if (option === 'landing') {
          editorPlaceLanding(world.x, world.y);
          const newCenterX = pad.x + pad.w / 2;
          const newCenterY = pad.y + pad.h / 2;
          editorState.dragging = {
            type: 'landing',
            offsetX: newCenterX - world.x,
            offsetY: newCenterY - world.y,
          };
          terrain.dirtyRender = true;
          resetEditorPaintingState();
          return;
        }

        if (option === 'terrain') {
          editorState.isPainting = true;
          editorState.hasMoved = false;
          editorState.lastPointer = { ...world };
          editorState.pendingPaintStart = { ...world };
          editorState.activeBrushMode = altKey ? 'carve' : 'add';
        } else {
          resetEditorPaintingState();
        }
      }

      function continueEditorInteraction(world) {
        if (appMode !== APP_MODE.EDITOR) return;
        editorState.cursorWorld = { ...world };
        const dragging = editorState.dragging;
        if (dragging) {
          if (dragging.type === 'spawn') {
            const nextX = world.x + dragging.offsetX;
            const nextY = world.y + dragging.offsetY;
            editorPlaceSpawn(nextX, nextY);
            terrain.dirtyRender = true;
            return;
          }
          if (dragging.type === 'landing') {
            const centerX = world.x + dragging.offsetX;
            const centerY = world.y + dragging.offsetY;
            editorPlaceLanding(centerX, centerY);
            terrain.dirtyRender = true;
            return;
          }
          if (dragging.type === 'blackHole') {
            const holes = ensureEditorBlackHoles();
            if (dragging.index >= 0 && dragging.index < holes.length) {
              const hole = holes[dragging.index];
              const margin = BLACK_HOLE_EVENT_RADIUS + terrain.cellSize;
              let px = clamp(world.x + dragging.offsetX, margin, Math.max(margin, terrain.width - margin));
              let py = clamp(world.y + dragging.offsetY, margin, Math.max(margin, terrain.height - margin));
              const penetration = resolvePenetrationAt(px, py);
              if (penetration.depth > 0.5) {
                px += penetration.normal.x * (penetration.depth + terrain.cellSize * 0.5);
                py += penetration.normal.y * (penetration.depth + terrain.cellSize * 0.5);
                px = clamp(px, margin, Math.max(margin, terrain.width - margin));
                py = clamp(py, margin, Math.max(margin, terrain.height - margin));
              }
              if (!isSolidWorld(px, py)) {
                let blocked = false;
                for (let i = 0; i < holes.length; i++) {
                  if (i === dragging.index) continue;
                  const other = holes[i];
                  const dist = Math.hypot(other.x - px, other.y - py);
                  if (dist < BLACK_HOLE_MIN_SPACING) {
                    blocked = true;
                    break;
                  }
                }
                if (!blocked) {
                  hole.x = px;
                  hole.y = py;
                  terrain.blackHoles = holes;
                  editorState.blackHoles = holes;
                  terrain.dirtyRender = true;
                }
              }
            }
            return;
          }
          if (dragging.type === 'meteor') {
            const meteors = ensureEditorMeteors();
            if (dragging.index >= 0 && dragging.index < meteors.length) {
              const meteor = meteors[dragging.index];
              if (dragging.handle === 'spawn') {
                meteor.spawn.x = world.x + dragging.offsetX;
                meteor.spawn.y = world.y + dragging.offsetY;
                clampMeteorSpawnPosition(meteor);
              } else if (dragging.handle === 'target') {
                meteor.target.x = world.x + dragging.offsetX;
                meteor.target.y = world.y + dragging.offsetY;
              } else if (dragging.handle === 'path') {
                const dx = world.x - dragging.startPointer.x;
                const dy = world.y - dragging.startPointer.y;
                meteor.spawn.x = dragging.initialSpawn.x + dx;
                meteor.spawn.y = dragging.initialSpawn.y + dy;
                meteor.target.x = dragging.initialTarget.x + dx;
                meteor.target.y = dragging.initialTarget.y + dy;
                clampMeteorSpawnPosition(meteor);
              }
              clampMeteorTargetPosition(meteor);
              terrain.meteors = meteors;
              editorState.meteors = meteors;
              terrain.dirtyRender = true;
            }
            return;
          }
        }
        const option = editorState.placementOptions[editorState.placementIndex];
        if (option === 'meteor') {
          if (editorState.isPlacingMeteor && editorState.pendingMeteor) {
            editorState.pendingMeteor.target = { ...world };
          }
        }
        if (!editorState.isPainting) return;
        if (option !== 'terrain') return;
        const prev = editorState.lastPointer;
        if (!editorState.hasMoved) {
          const reference = editorState.pendingPaintStart || prev;
          if (reference) {
            const dx = world.x - reference.x;
            const dy = world.y - reference.y;
            if (Math.hypot(dx, dy) > 4) {
              editorState.hasMoved = true;
              const seed = editorState.pendingPaintStart || reference;
              editorApplyBrush(seed.x, seed.y, editorState.activeBrushMode);
              editorState.pendingPaintStart = null;
            }
          }
        }
        if (editorState.hasMoved && prev) {
          editorStroke(prev, world, editorState.activeBrushMode);
        }
        editorState.lastPointer = { ...world };
      }

      function finishEditorInteraction(world) {
        if (appMode !== APP_MODE.EDITOR) return;
        const resolved = world || (editorState.cursorWorld ? { ...editorState.cursorWorld } : null);
        if (!resolved) {
          if (editorState.dragging) {
            editorState.dragging = null;
          }
          resetEditorPaintingState();
          return;
        }
        editorState.cursorWorld = { ...resolved };
        if (editorState.dragging) {
          const dragging = editorState.dragging;
          editorState.dragging = null;
          if (dragging.type === 'meteor') {
            const meteors = ensureEditorMeteors();
            if (dragging.index >= 0 && dragging.index < meteors.length) {
              const meteor = meteors[dragging.index];
              clampMeteorSpawnPosition(meteor);
              clampMeteorTargetPosition(meteor);
              terrain.meteors = meteors;
              editorState.meteors = meteors;
            }
            updateEditorOverlay();
          } else if (dragging.type === 'blackHole') {
            terrain.blackHoles = ensureEditorBlackHoles();
          }
          return;
        }
        const option = editorState.placementOptions[editorState.placementIndex];
        if (option === 'meteor') {
          if (editorState.isPlacingMeteor && editorState.pendingMeteor) {
            editorState.pendingMeteor.target = { ...resolved };
            editorCommitPendingMeteor();
          }
          return;
        }
        endEditorStroke(resolved);
      }

      function cancelEditorInteraction() {
        editorState.cursorWorld = null;
        if (editorState.dragging) {
          editorState.dragging = null;
        }
        if (editorState.isPlacingMeteor) {
          editorCancelPendingMeteor();
        }
        if (!editorState.isPainting) return;
        editorState.isPainting = false;
        editorState.lastPointer = null;
        editorState.hasMoved = false;
        editorState.pendingPaintStart = null;
      }

      function touchToWorld(touch) {
        if (!touch) return null;
        const rect = canvas.getBoundingClientRect();
        const x = touch.clientX - rect.left;
        const y = touch.clientY - rect.top;
        return screenToWorld(x, y);
      }

      function endEditorStroke(world) {
        if (!editorState.isPainting) return;
        editorState.isPainting = false;
        const moved = editorState.hasMoved;
        editorState.hasMoved = false;
        const option = editorState.placementOptions[editorState.placementIndex];
        const seedPoint = editorState.pendingPaintStart;
        editorState.pendingPaintStart = null;
        editorState.lastPointer = null;
        if (option === 'terrain') {
          if (!moved && seedPoint) {
            editorApplyBrush(seedPoint.x, seedPoint.y, editorState.activeBrushMode);
          }
          return;
        }
        if (option === 'blackHole' || option === 'meteor') return;
        if (!moved) {
          if (option === 'spawn') {
            editorPlaceSpawn(world.x, world.y);
          } else if (option === 'landing') {
            editorPlaceLanding(world.x, world.y);
          }
        }
      }

      canvas.addEventListener('mousedown', (event) => {
        if (appMode !== APP_MODE.EDITOR) return;
        if (event.button !== 0) return;
        const world = screenToWorld(event.offsetX, event.offsetY);
        beginEditorInteraction(world, { altKey: event.altKey });
      });

      canvas.addEventListener('mousemove', (event) => {
        if (appMode !== APP_MODE.EDITOR) return;
        const world = screenToWorld(event.offsetX, event.offsetY);
        continueEditorInteraction(world);
      });

      canvas.addEventListener('mouseup', (event) => {
        if (appMode !== APP_MODE.EDITOR) return;
        if (event.button !== 0) return;
        const world = screenToWorld(event.offsetX, event.offsetY);
        finishEditorInteraction(world);
      });

      canvas.addEventListener('mouseleave', () => {
        if (appMode !== APP_MODE.EDITOR) return;
        cancelEditorInteraction();
      });

      canvas.addEventListener('touchstart', (event) => {
        if (appMode !== APP_MODE.EDITOR) return;
        if (!event.changedTouches || event.changedTouches.length === 0) return;
        event.preventDefault();
        const world = touchToWorld(event.changedTouches[0]);
        if (world) {
          beginEditorInteraction(world);
        }
      }, { passive: false });

      canvas.addEventListener('touchmove', (event) => {
        if (appMode !== APP_MODE.EDITOR) return;
        if (!event.changedTouches || event.changedTouches.length === 0) return;
        event.preventDefault();
        const world = touchToWorld(event.changedTouches[0]);
        if (world) {
          continueEditorInteraction(world);
        }
      }, { passive: false });

      canvas.addEventListener('touchend', (event) => {
        if (appMode !== APP_MODE.EDITOR) return;
        event.preventDefault();
        const world = event.changedTouches && event.changedTouches.length
          ? touchToWorld(event.changedTouches[0])
          : null;
        finishEditorInteraction(world);
      }, { passive: false });

      canvas.addEventListener('touchcancel', (event) => {
        if (appMode !== APP_MODE.EDITOR) return;
        event.preventDefault();
        cancelEditorInteraction();
      }, { passive: false });

      function resetGame(forceTerrain = false, overrides = {}) {
        const {
          spawn = null,
          customTerrain = false,
          camera = null,
        } = overrides;
        hidePostLevelMenu();
        const usingCustomTerrain = !!customTerrain;
        if ((forceTerrain || shouldRegen) && !usingCustomTerrain) {
          const regenIndex = shouldRegen ? nextLevelIndex : currentLevelIndex;
          generateTerrain(regenIndex);
          shouldRegen = false;
        }
        if (!usingCustomTerrain) {
          const level = levels[currentLevelIndex];
          const startBuffer = 140;
          const preferredStart = Math.max(level.worldWidth * 0.1, width * 0.55);
          const clampedStart = Math.min(level.worldWidth - startBuffer, preferredStart);
          lander.x = Math.max(level.worldWidth * 0.08, clampedStart);
          lander.y = 50;
        } else if (spawn) {
          lander.x = spawn.x;
          lander.y = spawn.y;
        } else {
          const fallbackX = clamp(terrain.width * 0.1, 0, Math.max(0, terrain.width));
          lander.x = fallbackX;
          const below = findSurfaceBelow(fallbackX, 0);
          const fallbackGround = below ? below.y : terrain.height;
          lander.y = Math.max(40, fallbackGround - 160);
        }
        lander.vx = 0;
        lander.vy = 0;
        lander.angle = 0;
        lander.angularVelocity = 0;
        lander.fuel = 100;
        gameOver = false;
        message = '';
        exploded = false;
        debris = [];
        landed = false;
        winFx = [];
        padFlash = 0;
        smoke = [];
        blastSmoke = [];
        wreckFlames = [];
        bombs = [];
        bombCooldown = 0;
        resetMeteorState();
        activeBlackHoles = cloneBlackHoles(terrain.blackHoles);
        blackHolePhase = 0;
        alignPadToSurface(pad.x + pad.w / 2, pad.y + pad.h);
        audio.reset();
        const camSourceX = camera && camera.x != null ? camera.x : lander.x;
        const camSourceY = camera && camera.y != null ? camera.y : lander.y;
        camX = camSourceX;
        camY = camSourceY;
        keys.Space = false;
        for (const key of Object.keys(keys)) {
          if (keys[key]) keys[key] = false;
        }
        clearVirtualTouchState();
      }

      function spawnExplosion(x, y, baseVx, baseVy) {
        if (exploded) return;
        exploded = true;
        gameOver = true;
        if (appMode === APP_MODE.TEST) {
          message = 'Test failed. Press R to retry or Esc to edit';
          hidePostLevelMenu();
        } else {
          message = 'You Crashed! Press R to restart or Esc for menu';
          const upcoming = levels.length > 0 ? levels[(currentLevelIndex + 1) % levels.length].name : null;
          showPostLevelMenu('failure', message, upcoming);
        }
        audio.stopThrusterImmediate();
        audio.playExplosion();
        audio.playDeathTone();
        debris = [];

        // Only create crater if ship is at or near ground
        const surfaceBelow = findSurfaceBelow(x, Math.max(0, y - 10));
        const isNearGround = surfaceBelow && Math.abs(y - surfaceBelow.y) < 30;
        
        if (isNearGround) {
          deformTerrainAt(x, y, CRASH_CRATER_RADIUS, CRASH_CRATER_DEPTH);
        }
        
        // Spawn explosion debris at actual collision point, not ground level
        const originY = y;
        const pushOut = (speedMin, speedRange) => speedMin + Math.random() * speedRange;
        const randomUpVector = (jitter = 0.25) => {
          const angle = (Math.random() - 0.5) * Math.PI; // -90..+90 around upward axis
          let dirX = Math.sin(angle);
          let dirY = -Math.cos(angle);
          dirY += (Math.random() - 0.5) * jitter;
          if (dirY > -0.05) dirY = -0.05 - Math.random() * 0.35;
          const mag = Math.hypot(dirX, dirY) || 1;
          return { dirX: dirX / mag, dirY: dirY / mag };
        };

        const coreCount = 1 + (Math.random() * 2 | 0);
        for (let i = 0; i < coreCount; i++) {
          const radius = 48 + Math.random() * 20;
          const life = 1600 + Math.random() * 900;
          const dir = randomUpVector(0.18);
          const speed = pushOut(0.32, 0.36);
          debris.push({
            x,
            y: originY,
            vx: baseVx * 0.25 + dir.dirX * speed,
            vy: baseVy * 0.18 + dir.dirY * speed,
            radius,
            radiusStart: radius,
            life,
            lifeStart: life,
            glowBias: 1.2,
            kind: 'core',
          });
        }

        const shardCount = 46 + Math.floor(Math.random() * 24);
        for (let i = 0; i < shardCount; i++) {
          const dir = randomUpVector(0.32);
          const speed = pushOut(0.22, 0.42);
          const radius = 12 + Math.random() * 12;
          const life = 1200 + Math.random() * 880;
          debris.push({
            x,
            y: originY,
            vx: baseVx * 0.25 + dir.dirX * speed,
            vy: baseVy * 0.18 + dir.dirY * speed,
            radius,
            radiusStart: radius,
            life,
            lifeStart: life,
            glowBias: 0.85 + Math.random() * 0.4,
            kind: 'shard',
          });
        }

        const emberCount = 28 + Math.floor(Math.random() * 18);
        for (let i = 0; i < emberCount; i++) {
          const dir = randomUpVector(0.42);
          const speed = pushOut(0.14, 0.3);
          const radius = 6 + Math.random() * 6;
          const life = 900 + Math.random() * 660;
          debris.push({
            x,
            y: originY,
            vx: baseVx * 0.25 + dir.dirX * speed,
            vy: baseVy * 0.18 + dir.dirY * speed,
            radius,
            radiusStart: radius,
            life,
            lifeStart: life,
            glowBias: 0.6 + Math.random() * 0.3,
            kind: 'ember',
          });
        }

        const smokeCount = 18 + Math.floor(Math.random() * 14);
        for (let i = 0; i < smokeCount; i++) {
          const spread = (Math.random() - 0.5) * 120;
          const spawnX = clamp(x + spread, 0, terrain.width);
          const radius = 18 + Math.random() * 18;
          const life = 2200 + Math.random() * 1800;
          const rise = 0.012 + Math.random() * 0.018;
          const bias = Math.random() * 0.55 + 0.65;
          blastSmoke.push({
            x: spawnX,
            y: y - radius * bias, // Spawn at actual explosion position, not ground level
            vx: baseVx * 0.22 + (Math.random() - 0.5) * 0.12,
            vy: -rise,
            radius,
            radiusStart: radius,
            life,
            lifeStart: life,
            heat: 0.75 + Math.random() * 0.35,
            source: 'blast',
          });
        }

        const wreckCount = 3 + (Math.random() * 3 | 0);
        for (let i = 0; i < wreckCount; i++) {
          const spread = (Math.random() - 0.5) * 50;
          const px = clamp(x + spread, 0, terrain.width);
          const baseRadius = 14 + Math.random() * 12;
          wreckFlames.push({
            x: px,
            y: y - baseRadius * (0.52 + Math.random() * 0.16), // Spawn at actual explosion position
            vx: baseVx * 0.2 + (Math.random() - 0.5) * 0.08, // Inherit ship velocity
            vy: baseVy * 0.15 + (Math.random() - 0.5) * 0.05,
            radius: baseRadius,
            heat: 0.9 + Math.random() * 0.15,
            pulse: Math.random() * Math.PI * 2,
            flicker: Math.random() * 0.4,
            smokeTimer: 120 + Math.random() * 200,
            grounded: false,
          });
        }
        if (wreckFlames.length > 12) {
          wreckFlames.splice(0, wreckFlames.length - 12);
        }

        applyExplosionEffects(x, y);
      }

      function consumeLanderIntoBlackHole(hole) {
        if (!hole || gameOver) return;
        gameOver = true;
        exploded = true;
        landed = false;
        shouldRegen = false;
        const testMode = appMode === APP_MODE.TEST;
        if (testMode) {
          message = 'Singularity capture! Press R to retry or Esc to edit';
          hidePostLevelMenu();
        } else {
          message = 'Singularity capture! Press R to restart or N for next level';
          const upcoming = levels.length > 0 ? levels[(currentLevelIndex + 1) % levels.length].name : null;
          showPostLevelMenu('failure', message, upcoming);
        }
        audio.stopThrusterImmediate();
        audio.setThrusterActive(false);
        audio.playDeathTone();
        const startX = lander.x;
        const startY = lander.y;
        lander.x = hole.x;
        lander.y = hole.y;
        lander.vx = 0;
        lander.vy = 0;
        lander.angularVelocity = 0;
        debris = [];
        smoke = [];
        winFx = [];
        wreckFlames = [];
        padFlash = 0;
        blastSmoke = [];
        bombCooldown = 0;
        const shards = 36 + (Math.random() * 18 | 0);
        for (let i = 0; i < shards; i++) {
          const angle = (i / shards) * Math.PI * 2 + Math.random() * 0.35;
          const ring = 22 + Math.random() * 32;
          const spawnX = startX + Math.cos(angle) * ring;
          const spawnY = startY + Math.sin(angle) * ring;
          const dirX = hole.x - spawnX;
          const dirY = hole.y - spawnY;
          const mag = Math.hypot(dirX, dirY) || 1;
          const nx = dirX / mag;
          const ny = dirY / mag;
          const inwardSpeed = 0.18 + Math.random() * 0.3;
          const swirl = (Math.random() - 0.5) * 0.22;
          const tangentAngle = angle + Math.PI / 2;
          const vx = nx * inwardSpeed + Math.cos(tangentAngle) * swirl;
          const vy = ny * inwardSpeed + Math.sin(tangentAngle) * swirl;
          const radius = 8 + Math.random() * 10;
          const life = 1400 + Math.random() * 900;
          debris.push({
            x: spawnX,
            y: spawnY,
            vx,
            vy,
            radius,
            radiusStart: radius,
            life,
            lifeStart: life,
            glowBias: 0.9 + Math.random() * 0.4,
            kind: i % 4 === 0 ? 'core' : 'shard',
          });
        }

        const wisps = 18 + (Math.random() * 10 | 0);
        const eventRadius = holeEventRadius(hole);
        for (let i = 0; i < wisps; i++) {
          const theta = Math.random() * Math.PI * 2;
          const radius = eventRadius * (0.6 + Math.random() * 0.5);
          const px = hole.x + Math.cos(theta) * radius;
          const py = hole.y + Math.sin(theta) * radius;
          const dirX = hole.x - px;
          const dirY = hole.y - py;
          const mag = Math.hypot(dirX, dirY) || 1;
          const nx = dirX / mag;
          const ny = dirY / mag;
          const speed = 0.05 + Math.random() * 0.08;
          const swirl = (Math.random() - 0.5) * 0.04;
          const wRadius = 12 + Math.random() * 12;
          const wLife = 1600 + Math.random() * 900;
          blastSmoke.push({
            x: px,
            y: py,
            vx: nx * speed + Math.cos(theta + Math.PI / 2) * swirl,
            vy: ny * speed + Math.sin(theta + Math.PI / 2) * swirl,
            radius: wRadius,
            radiusStart: wRadius,
            life: wLife,
            lifeStart: wLife,
            heat: 0.6 + Math.random() * 0.3,
            source: 'void',
          });
        }

        bombs = bombs.filter(b => !isInsideBlackHole(hole, b.x, b.y));
        blastSmoke = blastSmoke.filter(p => !isNaN(p.x));
      }

      function absorbBombIntoBlackHole(bomb, hole) {
        if (!bomb || bomb.detonated) return;
        bomb.detonated = true;
        bomb.fuseMs = 0;
        bomb.absorbed = true;
        const sparks = 10 + (Math.random() * 8 | 0);
        const pullRadius = holeEventRadius(hole) * 0.9;
        for (let i = 0; i < sparks; i++) {
          const theta = Math.random() * Math.PI * 2;
          const radius = pullRadius * (0.4 + Math.random() * 0.5);
          const px = hole.x + Math.cos(theta) * radius;
          const py = hole.y + Math.sin(theta) * radius;
          const dirX = hole.x - px;
          const dirY = hole.y - py;
          const mag = Math.hypot(dirX, dirY) || 1;
          const nx = dirX / mag;
          const ny = dirY / mag;
          const speed = 0.12 + Math.random() * 0.16;
          const swirl = (Math.random() - 0.5) * 0.06;
          const emberRadius = 4 + Math.random() * 4;
          const emberLife = 900 + Math.random() * 600;
          debris.push({
            x: px,
            y: py,
            vx: nx * speed + Math.cos(theta + Math.PI / 2) * swirl,
            vy: ny * speed + Math.sin(theta + Math.PI / 2) * swirl,
            radius: emberRadius,
            radiusStart: emberRadius,
            life: emberLife,
            lifeStart: emberLife,
            glowBias: 0.7 + Math.random() * 0.4,
            kind: 'ember',
          });
        }
      }

      function updateDebris(dt) {
        const BOUNCE = tune.bounce;
        const FRIC = tune.friction;
        const bounceFactor = 0.35 + BOUNCE * 0.65;
        // Sample a ring of offsets (in radii) so debris can bounce off overhangs and slopes.
        const samples = [
          { x: 0, y: 1 },
          { x: 0, y: -1 },
          { x: 1, y: 0 },
          { x: -1, y: 0 },
          { x: 0.72, y: 0.72 },
          { x: -0.72, y: 0.72 },
          { x: 0.72, y: -0.72 },
          { x: -0.72, y: -0.72 },
        ];
        for (const p of debris) {
          p.life -= dt;
          if (p.life <= 0) continue;

          const lifeRatio = Math.max(0, p.life / p.lifeStart);
          const shrinkCurve = p.kind === 'core' ? 0.52 : p.kind === 'shard' ? 0.7 : 0.82;
          const scale = 0.35 + 0.65 * Math.pow(lifeRatio, shrinkCurve);
          p.radius = p.radiusStart * scale;

          // physics
          const driftDamp = p.kind === 'ember' ? 0.993 : 0.997;
          p.vy += g * dt * DEBRIS_GRAVITY_MULT; // heavier debris arcs
          const debrisPull = computeBlackHoleAcceleration(p.x, p.y);
          if (debrisPull) {
            const pullScale = p.kind === 'core' ? 1.2 : 1.6;
            p.vx += debrisPull.ax * dt * pullScale;
            p.vy += debrisPull.ay * dt * pullScale;
          }
          p.vx *= driftDamp;
          let px = p.x + p.vx * dt;
          let py = p.y + p.vy * dt;

          const captureHole = findBlackHoleCapture(px, py);
          if (captureHole) {
            p.life = 0;
            continue;
          }

          let normalX = 0;
          let normalY = 0;
          let contactCount = 0;
          let pushX = 0;
          let pushY = 0;
          for (const offset of samples) {
            const sampleX = px + offset.x * p.radius;
            const sampleY = py + offset.y * p.radius;
            if (!isSolidWorld(sampleX, sampleY)) continue;
            const info = resolvePenetrationAt(sampleX, sampleY);
            if (!info || info.depth <= 0) continue;
            pushX += info.normal.x * info.depth;
            pushY += info.normal.y * info.depth;
            normalX += info.normal.x;
            normalY += info.normal.y;
            contactCount++;
          }

          const centerInfo = resolvePenetrationAt(px, py);
          if (centerInfo && centerInfo.depth > 0) {
            pushX += centerInfo.normal.x * centerInfo.depth;
            pushY += centerInfo.normal.y * centerInfo.depth;
            normalX += centerInfo.normal.x;
            normalY += centerInfo.normal.y;
            contactCount++;
          }

          if (contactCount > 0) {
            px += pushX;
            py += pushY;
          }

          p.x = px;
          p.y = py;

          if (contactCount > 0) {
            const len = Math.hypot(normalX, normalY);
            if (len > 0.0001) {
              const nx = normalX / len;
              const ny = normalY / len;
              const vDot = p.vx * nx + p.vy * ny;
              if (vDot < 0) {
                const reflected = -vDot * bounceFactor;
                const impulse = reflected - vDot;
                p.vx += nx * impulse;
                p.vy += ny * impulse;
              }
              const tx = ny;
              const ty = -nx;
              const vt = p.vx * tx + p.vy * ty;
              const vtTarget = vt * FRIC;
              const tangentImpulse = vtTarget - vt;
              p.vx += tx * tangentImpulse;
              p.vy += ty * tangentImpulse;
            }
          }

          if (p.x < 0) { p.x = 0; p.vx = Math.abs(p.vx) * BOUNCE; }
          if (p.x > terrain.width) { p.x = terrain.width; p.vx = -Math.abs(p.vx) * BOUNCE; }
          if (p.y > terrain.height) {
            p.y = terrain.height;
            if (p.vy > 0) p.vy = -p.vy * bounceFactor;
          }
        }
        // trim dead
        debris = debris.filter(p => p.life > 0.0 && p.radius > 0.4);
      }

      function clamp01(v) {
        return v < 0 ? 0 : v > 1 ? 1 : v;
      }

      function heatColor(t, glowBias) {
        const mix = Math.pow(clamp01(t), 0.65);
        const flare = (1 - mix) * glowBias;
        const g = 244 - mix * 170 + flare * 28;
        const b = 195 - Math.pow(mix, 1.15) * 160 + flare * 12;
        return {
          r: 255,
          g: Math.max(0, Math.min(255, Math.round(g))),
          b: Math.max(0, Math.min(255, Math.round(b))),
        };
      }

      function updateBlastSmoke(dt) {
        for (const p of blastSmoke) {
          p.life -= dt;
          if (p.life <= 0) continue;
          const lifeRatio = Math.max(0, p.life / p.lifeStart);
          const source = p.source || 'blast';
          const isWreck = source === 'wreck';
          const isMeteor = source === 'meteor';
          const growthBase = isWreck ? 1.35 : isMeteor ? 1.45 : 1.1;
          const growth = 1 + (1 - lifeRatio) * growthBase;
          p.radius = p.radiusStart * growth;
          const buoyancy = isWreck ? -g * 0.28 : isMeteor ? -g * 0.09 : g * 0.07;
          p.vy += buoyancy * dt;
          if (isWreck) {
            if (p.vy > -0.008) p.vy = -0.008;
            if (p.vy < -0.08) p.vy = -0.08;
            p.vx *= 0.9985;
          } else if (isMeteor) {
            if (p.vy < -0.06) p.vy = -0.06;
            if (p.vy > 0.03) p.vy = 0.03;
            p.vx *= 0.996;
          } else {
            if (p.vy < -0.035) p.vy = -0.035;
            p.vx *= 0.997;
          }
          const smokePull = computeBlackHoleAcceleration(p.x, p.y);
          if (smokePull) {
            const pullScale = source === 'void' ? 2.0 : isMeteor ? 0.6 : 0.8;
            p.vx += smokePull.ax * dt * pullScale;
            p.vy += smokePull.ay * dt * pullScale;
          }
          p.x += p.vx * dt;
          p.y += p.vy * dt;
          if (source === 'void') {
            const capture = findBlackHoleCapture(p.x, p.y);
            if (capture) {
              p.life = 0;
              continue;
            }
          }
          const gy = groundYAt(p.x, p.y);
          if (p.y + p.radius >= gy) {
            p.y = gy - p.radius;
            if (isMeteor) {
              p.vy *= -0.2;
              p.vx *= 0.85;
            } else {
              p.vy *= -0.1;
              p.vx *= 0.88;
            }
          }
        }
        blastSmoke = blastSmoke.filter(p => p.life > 0 && p.radius > 0.5);
      }

      function updateWreckFlames(dt) {
        if (wreckFlames.length === 0) return;
        const seconds = dt / 1000;
        for (const f of wreckFlames) {
          f.pulse += seconds * (2.1 + Math.random() * 0.9);
          const flickerTarget = 0.35 + Math.random() * 0.4;
          f.flicker += (flickerTarget - f.flicker) * 0.16;
          const heatTarget = 0.72 + Math.random() * 0.2;
          f.heat += (heatTarget - f.heat) * 0.05;
          
          // Apply physics to falling wreck flames
          if (!f.grounded) {
            f.vy += g * dt;
            f.x += f.vx * dt;
            f.y += f.vy * dt;
            
            // Check for ground collision
            const groundY = groundYAt(f.x, f.y);
            if (f.y + f.radius >= groundY) {
              f.y = groundY - f.radius;
              f.vy = 0;
              f.vx *= 0.5; // Friction on landing
              f.grounded = true;
            }
            
            // Keep within bounds
            if (f.x < 0) {
              f.x = 0;
              f.vx = 0;
            }
            if (f.x > terrain.width) {
              f.x = terrain.width;
              f.vx = 0;
            }
          }
          
          f.smokeTimer -= dt;
          if (f.smokeTimer <= 0) {
            const radius = 14 + Math.random() * 12;
            const life = 5200 + Math.random() * 2800;
            blastSmoke.push({
              x: f.x + (Math.random() - 0.5) * 6,
              y: f.y - f.radius * 0.35,
              vx: (Math.random() - 0.5) * 0.08,
              vy: -0.025 - Math.random() * 0.020, // Increased upward velocity for visibility
              radius,
              radiusStart: radius,
              life,
              lifeStart: life,
              heat: 0.52 + Math.random() * 0.24,
              source: 'wreck',
            });
            f.smokeTimer = 360 + Math.random() * 440;
          }
        }
      }

      function drawDebris() {
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        for (const p of debris) {
          if (p.life <= 0 || p.radius <= 0.4) continue;
          const progress = 1 - clamp01(p.life / p.lifeStart);
          const { r, g, b } = heatColor(progress, p.glowBias);
          const alpha = Math.min(1, 0.85 * (1 - progress * 0.35) * p.glowBias);
          const glowRadius = p.radius * (p.kind === 'core' ? 1.9 : 1.35);
          const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, glowRadius);
          gradient.addColorStop(0, `rgba(${r},${g},${b},${alpha})`);
          gradient.addColorStop(0.35, `rgba(${r},${g},${b},${alpha * 0.7})`);
          gradient.addColorStop(1, `rgba(${r},${g},${b},0)`);
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(p.x, p.y, glowRadius, 0, Math.PI * 2);
          ctx.fill();

          const coreRadius = Math.max(1.5, p.radius * 0.52);
          const coreAlpha = Math.min(1, alpha * 1.08);
          ctx.fillStyle = `rgba(255,${Math.round(Math.min(255, g + 20))},${Math.round(Math.min(255, b + 40))},${coreAlpha})`;
          ctx.beginPath();
          ctx.arc(p.x, p.y, coreRadius, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.restore();
      }

      function drawBlastSmoke() {
        if (blastSmoke.length === 0) return;
        ctx.save();
        ctx.globalCompositeOperation = 'source-over';
        for (const p of blastSmoke) {
          if (p.life <= 0) continue;
          const lifeRatio = clamp01(p.life / p.lifeStart);
          const source = p.source || 'blast';
          const isWreck = source === 'wreck';
          const isMeteor = source === 'meteor';
          const expo = isWreck ? 0.58 : isMeteor ? 0.7 : 0.75;
          const heat = Math.pow(lifeRatio, expo);
          let r, g, b;
          if (isWreck) {
            r = Math.max(0, Math.min(255, Math.round(118 * heat * p.heat)));
            g = Math.max(0, Math.min(255, Math.round(48 * heat * 0.9)));
            b = Math.max(0, Math.min(255, Math.round(44 * heat * 0.75)));
          } else if (isMeteor) {
            r = Math.max(0, Math.min(255, Math.round(160 * heat * p.heat)));
            g = Math.max(0, Math.min(255, Math.round(120 * heat * 0.85)));
            b = Math.max(0, Math.min(255, Math.round(95 * heat * 0.7)));
          } else {
            r = Math.max(0, Math.min(255, Math.round(118 * heat * p.heat)));
            g = Math.max(0, Math.min(255, Math.round(48 * heat * 0.7)));
            b = Math.max(0, Math.min(255, Math.round(44 * heat * 0.6)));
          }
          const alphaBase = isWreck ? 0.32 : isMeteor ? 0.34 : 0.28;
          const centerAlpha = Math.min(0.88, alphaBase + 0.72 * Math.pow(lifeRatio, 0.5) * p.heat);
          const midAlpha = centerAlpha * 0.68;
          const radius = p.radius * (1.0 + (1 - lifeRatio) * (isWreck ? 0.55 : isMeteor ? 0.62 : 0.42));
          const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, radius);
          gradient.addColorStop(0, `rgba(${r},${g},${b},${centerAlpha})`);
          gradient.addColorStop(0.45, `rgba(${r},${g},${b},${midAlpha})`);
          gradient.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.restore();
      }

      function drawWreckFlames() {
        if (wreckFlames.length === 0) return;
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        for (const f of wreckFlames) {
          const pulse = Math.sin(f.pulse) * 0.5 + 0.5;
          const flameRadius = f.radius * (0.78 + pulse * 0.5 + f.flicker * 0.15);
          const flameHeat = Math.min(1, f.heat + pulse * 0.2);
          const r = 255;
          const g = Math.round(210 * flameHeat + 40 * (1 - flameHeat));
          const b = Math.round(120 * (1 - flameHeat * 0.8));
          const alphaCore = 0.82 * (0.7 + pulse * 0.3);
          const alphaEdge = alphaCore * 0.55;
          const gradient = ctx.createRadialGradient(f.x, f.y, 0, f.x, f.y, flameRadius);
          gradient.addColorStop(0, `rgba(${r},${g},${b},${alphaCore})`);
          gradient.addColorStop(0.55, `rgba(${r},${g},${b},${alphaEdge})`);
          gradient.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(f.x, f.y, flameRadius, 0, Math.PI * 2);
          ctx.fill();

          const coalRadius = Math.max(4, f.radius * 0.45);
          ctx.fillStyle = `rgba(90,40,25,0.55)`;
          ctx.beginPath();
          ctx.arc(f.x, f.y + coalRadius * 0.4, coalRadius, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.restore();
      }

      // Celebration particles (confetti)
      function spawnWinFx(x, y) {
        winFx = [];
        const COUNT = 80;
        const colors = ['#ffd166', '#06d6a0', '#118ab2', '#ef476f', '#ffffff'];
        for (let i = 0; i < COUNT; i++) {
          const a = Math.random() * Math.PI * 2;
          const sp = 0.03 + Math.random() * 0.18;
          winFx.push({
            x, y,
            vx: Math.cos(a) * sp,
            vy: -0.05 - Math.random() * 0.20, // kick upward
            ang: Math.random() * Math.PI * 2,
            angVel: (Math.random() - 0.5) * 0.02,
            size: 3 + (Math.random() * 3 | 0),
            life: 1200 + Math.random() * 1200,
            color: colors[i % colors.length],
          });
        }
      }

      function updateWinFx(dt) {
        for (const p of winFx) {
          p.life -= dt;
          if (p.life <= 0) continue;
          // lighter gravity for confetti
          p.vy += (g * 0.6) * dt;
          p.x += p.vx * dt;
          p.y += p.vy * dt;
          p.ang += p.angVel * dt;
          // bounce on ground lightly
          const gy = groundYAt(p.x, p.y);
          if (p.y + p.size >= gy) {
            p.y = gy - p.size;
            p.vy = -Math.abs(p.vy) * 0.25;
            p.vx *= 0.9;
          }
        }
        winFx = winFx.filter(p => p.life > 0);
      }

      function drawWinFx() {
        if (winFx.length === 0) return;
        ctx.save();
        for (const p of winFx) {
          ctx.save();
          ctx.translate(p.x, p.y);
          ctx.rotate(p.ang);
          ctx.fillStyle = p.color;
          ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size);
          ctx.restore();
        }
        ctx.restore();
      }

      function updateBombs(dt) {
        if (bombCooldown > 0) {
          bombCooldown -= dt;
          if (bombCooldown < 0) bombCooldown = 0;
        }
        if (bombs.length === 0) return;
        const airDrag = 0.9985;
        const groundDrag = 0.94;
        for (const bomb of bombs) {
          if (bomb.detonated) continue;
          bomb.armingMs = Math.max(0, bomb.armingMs - dt);
          bomb.fuseMs -= dt;
          const fuseRatio = Math.max(0, bomb.fuseMs / BOMB_FUSE_MS);
          bomb.lastFuseRatio = fuseRatio;
          bomb.blinkRate = BOMB_BLINK_BASE + BOMB_BLINK_ACCEL * (1 - fuseRatio);
          bomb.blinkPhase += bomb.blinkRate * dt;
          if (bomb.fuseMs <= 0) {
            explodeBomb(bomb);
            continue;
          }
          if (!bomb.grounded) {
            bomb.vy += g * dt;
            bomb.vx *= airDrag;
            bomb.vy *= 0.999;
          } else {
            bomb.vx *= groundDrag;
            if (Math.abs(bomb.vx) < 0.00001) bomb.vx = 0;
          }
          const bombPull = computeBlackHoleAcceleration(bomb.x, bomb.y);
          if (bombPull) {
            bomb.vx += bombPull.ax * dt;
            bomb.vy += bombPull.ay * dt;
          }
          bomb.x += bomb.vx * dt;
          bomb.y += bomb.vy * dt;
          const capture = findBlackHoleCapture(bomb.x, bomb.y);
          if (capture) {
            absorbBombIntoBlackHole(bomb, capture);
            continue;
          }
          if (bomb.x < 0) {
            bomb.x = 0;
            bomb.vx = Math.abs(bomb.vx) * 0.35;
          }
          if (bomb.x > terrain.width) {
            bomb.x = terrain.width;
            bomb.vx = -Math.abs(bomb.vx) * 0.35;
          }
          const groundY = groundYAt(bomb.x, bomb.y);
          const radius = bomb.radius;
          if (bomb.y + radius >= groundY) {
            bomb.y = groundY - radius;
            if (bomb.vy > 0) bomb.vy = 0;
            bomb.grounded = true;
          } else if (bomb.grounded && bomb.y + radius < groundY - 1) {
            bomb.grounded = false;
          }
        }
        bombs = bombs.filter(b => !b.detonated);
      }

      function drawBombs() {
        if (bombs.length === 0) return;
        ctx.save();
        for (const bomb of bombs) {
          if (bomb.detonated) continue;
          const fuseRatio = clamp01(bomb.lastFuseRatio ?? 1);
          const heat = 1 - fuseRatio;
          const pulse = Math.sin(bomb.blinkPhase);
          const coreRadius = bomb.radius;
          const haloRadius = coreRadius * (1.6 + heat * 0.9 + Math.max(0, pulse) * 0.4);
          const halo = ctx.createRadialGradient(bomb.x, bomb.y, 0, bomb.x, bomb.y, haloRadius);
          const innerAlpha = Math.min(1, 0.35 + heat * 0.45 + Math.max(0, pulse) * 0.3);
          const midAlpha = innerAlpha * 0.55;
          halo.addColorStop(0, `rgba(255, ${Math.round(150 + heat * 100)}, ${Math.round(70 + heat * 70)}, ${innerAlpha})`);
          halo.addColorStop(0.55, `rgba(255, ${Math.round(110 + heat * 70)}, ${Math.round(40 + heat * 60)}, ${midAlpha})`);
          halo.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.fillStyle = halo;
          ctx.beginPath();
          ctx.arc(bomb.x, bomb.y, haloRadius, 0, Math.PI * 2);
          ctx.fill();

          ctx.fillStyle = pulse > 0 ? '#ffe27a' : '#ff744a';
          ctx.beginPath();
          ctx.arc(bomb.x, bomb.y, coreRadius, 0, Math.PI * 2);
          ctx.fill();

          ctx.strokeStyle = '#311f33';
          ctx.lineWidth = 1.2;
          ctx.beginPath();
          ctx.arc(bomb.x, bomb.y, coreRadius, 0, Math.PI * 2);
          ctx.stroke();
        }
        ctx.restore();
      }

      function checkLanderExplosion(x, y) {
        if (exploded || gameOver) return;
        const dx = lander.x - x;
        const dy = lander.y - y;
        if (dx * dx + dy * dy <= EXPLOSION_KILL_RADIUS * EXPLOSION_KILL_RADIUS) {
          spawnExplosion(lander.x, lander.y, lander.vx, lander.vy);
        }
      }

      function normalizeMeteorDef(def, index = 0) {
        if (!def) return null;
        const spawnX = clamp(def.spawn?.x ?? terrain.width / 2, 0, terrain.width);
        const spawnYRaw = def.spawn?.y ?? -METEOR_SPAWN_ABOVE_MARGIN;
        const spawnYAbove = Math.min(spawnYRaw, -METEOR_SPAWN_ABOVE_MARGIN);
        const spawnY = Math.max(-terrain.height * 1.5, Math.min(terrain.height + 600, spawnYAbove));
        
        // Calculate direction from spawn to target (for backward compatibility with editor)
        const targetX = clamp(def.target?.x ?? spawnX, 0, terrain.width);
        const targetYRaw = def.target?.y ?? terrain.height * 0.9;
        const targetY = Math.max(-400, Math.min(terrain.height + 600, targetYRaw));
        
        const dx = targetX - spawnX;
        const dy = targetY - spawnY;
        const dist = Math.hypot(dx, dy) || 1;
        const dirX = dx / dist;
        const dirY = dy / dist;
        
        const radius = Math.max(METEOR_MIN_RADIUS, Math.min(METEOR_MAX_RADIUS, def.radius ?? 24));
        const speed = Math.max(METEOR_MIN_SPEED, Math.min(METEOR_MAX_SPEED, def.speed ?? 0.32));
        const startMs = Math.max(0, def.startMs ?? 0);
        const warningLeadMs = Math.min(startMs, Math.max(0, def.warningLeadMs ?? 0));
        
        return {
          id: def.id || `meteor-${Date.now()}-${index}`,
          spawn: { x: spawnX, y: spawnY },
          direction: { x: dirX, y: dirY },  // Direction vector instead of target
          radius,
          speed,
          startMs,
          warningLeadMs,
          warningStart: Math.max(0, startMs - warningLeadMs),
          warningIssued: false,
        };
      }

      function prepareMeteorTimeline(source) {
        if (!source || !source.length) return [];
        return source
          .map((def, index) => normalizeMeteorDef(def, index))
          .filter(Boolean)
          .sort((a, b) => a.startMs - b.startMs);
      }

      function resetMeteorState() {
        meteorTime = 0;
        meteorWarnings = [];
        activeMeteors = [];
        meteorTimeline = prepareMeteorTimeline(terrain.meteors);
      }

      function spawnMeteorWarning(event) {
        if (event.warningLeadMs <= 0) {
          event.warningIssued = true;
          return;
        }
        // Calculate a reasonable endpoint for the warning line based on direction
        const dirX = event.direction?.x ?? 0;
        const dirY = event.direction?.y ?? 1;
        const warningDistance = 800; // Extend warning line this far
        const endX = event.spawn.x + dirX * warningDistance;
        const endY = event.spawn.y + dirY * warningDistance;
        
        meteorWarnings.push({
          id: event.id,
          spawn: { ...event.spawn },
          target: { x: endX, y: endY }, // For visual display only
          radius: event.radius,
          start: event.warningStart,
          end: event.startMs,
          flash: 0,
        });
        if (event.warningLeadMs > 0 && audio && typeof audio.playMeteorWarning === 'function') {
          audio.playMeteorWarning();
        }
        event.warningIssued = true;
      }

      function spawnMeteor(event) {
        const dirX = event.direction?.x ?? 0;
        const dirY = event.direction?.y ?? 1;
        const speed = Math.max(event.speed, 0.0001);
        
        const meteor = {
          id: event.id,
          x: event.spawn.x,
          y: event.spawn.y,
          vx: dirX * speed,
          vy: dirY * speed,
          radius: event.radius,
          angle: Math.atan2(dirY, dirX),
          trailTimer: 0,
          exploded: false,
          spawn: { ...event.spawn },
          direction: { x: dirX, y: dirY },
          speed,
        };
        activeMeteors.push(meteor);
        meteorWarnings = meteorWarnings.filter(w => w.id !== event.id);
      }

      function spawnMeteorTrail(meteor) {
        const radius = meteor.radius * (0.45 + Math.random() * 0.25);
        const life = 720 + Math.random() * 380;
        blastSmoke.push({
          x: meteor.x - meteor.vx * 16 + (Math.random() - 0.5) * meteor.radius * 0.6,
          y: meteor.y - meteor.vy * 16 + (Math.random() - 0.5) * meteor.radius * 0.6,
          vx: -meteor.vx * 0.18 + (Math.random() - 0.5) * 0.08,
          vy: -meteor.vy * 0.18 + (Math.random() - 0.5) * 0.08,
          radius,
          radiusStart: radius,
          life,
          lifeStart: life,
          heat: 0.82 + Math.random() * 0.3,
          source: 'meteor',
        });
        const emberRadius = 3 + Math.random() * 3;
        const emberLife = 420 + Math.random() * 360;
        debris.push({
          x: meteor.x,
          y: meteor.y,
          vx: -meteor.vx * 0.12 + (Math.random() - 0.5) * 0.22,
          vy: -meteor.vy * 0.12 + (Math.random() - 0.5) * 0.22,
          radius: emberRadius,
          radiusStart: emberRadius,
          life: emberLife,
          lifeStart: emberLife,
          glowBias: 0.95 + Math.random() * 0.35,
          kind: 'ember',
        });
      }

      function resolveMeteorImpact(meteor, hitX, hitY, isGroundHit = false) {
        if (!meteor || meteor.exploded) return;
        meteor.exploded = true;
        const impactX = clamp(hitX, 0, terrain.width);
        const impactY = hitY;
        
        // Only create terrain crater if this was an actual ground collision
        if (isGroundHit) {
          const groundY = groundYAt(impactX, hitY);
          const craterRadius = Math.max(meteor.radius * 1.2, Math.min(METEOR_MAX_RADIUS * 1.6, meteor.radius * METEOR_CRATER_RADIUS_SCALE));
          const craterDepth = Math.max(meteor.radius * 0.6, meteor.radius * METEOR_CRATER_DEPTH_SCALE);
          deformTerrainAt(impactX, groundY, craterRadius, craterDepth);
          
          const dustCount = Math.max(
            0,
            Math.round((36 + meteor.radius * 0.8) * METEOR_IMPACT_SMOKE_SCALE)
          );
          for (let i = 0; i < dustCount; i++) {
            const spread = (Math.random() - 0.5) * craterRadius * 1.2;
            const spawnX = clamp(impactX + spread, 0, terrain.width);
            const baseY = groundYAt(spawnX, groundY);
            const radius = craterRadius * (0.25 + Math.random() * 0.35);
            const life = 2400 + Math.random() * 1600;
            blastSmoke.push({
              x: spawnX,
              y: baseY - radius * (0.55 + Math.random() * 0.2),
              vx: (spawnX - impactX) * 0.0008 + (Math.random() - 0.5) * 0.12,
              vy: -0.05 - Math.random() * 0.05,
              radius,
              radiusStart: radius,
              life,
              lifeStart: life,
              heat: 0.55 + Math.random() * 0.25,
              source: 'meteor',
            });
          }
        }
        
        // Spawn sparks at the actual impact location
        for (let i = 0; i < METEOR_SPARK_COUNT; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = 0.18 + Math.random() * 0.22;
          const radius = 6 + Math.random() * 4;
          const life = 900 + Math.random() * 600;
          debris.push({
            x: impactX,
            y: impactY,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed - 0.08,
            radius,
            radiusStart: radius,
            life,
            lifeStart: life,
            glowBias: 1.1 + Math.random() * 0.4,
            kind: 'shard',
          });
        }
        meteorWarnings = meteorWarnings.filter(w => w.id !== meteor.id);
        if (audio && typeof audio.playMeteorImpact === 'function') {
          audio.playMeteorImpact();
        }
        // Apply explosion effects (lander damage check) at actual impact point
        applyExplosionEffects(impactX, impactY);
      }

      function updateMeteors(dt) {
        meteorTime += dt;
        if (meteorTimeline.length) {
          const remaining = [];
          for (const event of meteorTimeline) {
            if (!event.warningIssued && meteorTime >= event.warningStart) {
              spawnMeteorWarning(event);
            }
            if (meteorTime >= event.startMs) {
              spawnMeteor(event);
              continue;
            }
            remaining.push(event);
          }
          meteorTimeline = remaining;
        }

        if (meteorWarnings.length) {
          for (const warn of meteorWarnings) {
            warn.flash = (warn.flash || 0) + dt;
            warn.progress = warn.end > warn.start ? clamp01((meteorTime - warn.start) / (warn.end - warn.start)) : 1;
          }
          meteorWarnings = meteorWarnings.filter(warn => meteorTime < warn.end);
        }

        if (!activeMeteors.length) {
          return;
        }
        const remainingMeteors = [];
        for (const meteor of activeMeteors) {
          if (meteor.exploded) {
            continue;
          }
          const prevX = meteor.x;
          const prevY = meteor.y;
          
          // Velocity-based movement instead of interpolation
          meteor.x += meteor.vx * dt;
          meteor.y += meteor.vy * dt;
          
          meteor.angle = Math.atan2(meteor.vy, meteor.vx);
          meteor.trailTimer += dt;
          while (meteor.trailTimer >= METEOR_TRAIL_INTERVAL) {
            spawnMeteorTrail(meteor);
            meteor.trailTimer -= METEOR_TRAIL_INTERVAL;
          }

          let meteorRemoved = false;
          if (!exploded && !gameOver) {
            const hullRadius = Math.max(lander.width, lander.height) * 0.35;
            const dx = lander.x - meteor.x;
            const dy = lander.y - meteor.y;
            const killRadius = (meteor.radius + hullRadius);
            if (dx * dx + dy * dy <= killRadius * killRadius) {
              resolveMeteorImpact(meteor, meteor.x, meteor.y, false); // Mid-air collision, no crater
              meteorRemoved = true;
            }
          }

          if (!meteorRemoved && bombs.length) {
            for (const bomb of bombs) {
              if (!bomb || bomb.detonated) continue;
              if (bomb.armingMs > 0) continue;
              const dx = bomb.x - meteor.x;
              const dy = bomb.y - meteor.y;
              const distSq = dx * dx + dy * dy;
              const limit = (meteor.radius + bomb.radius) * (meteor.radius + bomb.radius);
              if (distSq <= limit) {
                resolveMeteorImpact(meteor, meteor.x, meteor.y, false); // Mid-air collision, no crater
                explodeBomb(bomb);
                meteorRemoved = true;
                break;
              }
            }
          }

          // Check for ground collision along the path from previous to current position
          if (!meteorRemoved) {
            // Sample multiple points along the path to detect collision
            const steps = Math.max(3, Math.ceil(Math.hypot(meteor.x - prevX, meteor.y - prevY) / (meteor.radius * 0.5)));
            for (let i = 0; i <= steps; i++) {
              const t = i / steps;
              const checkX = prevX + (meteor.x - prevX) * t;
              const checkY = prevY + (meteor.y - prevY) * t;
              const groundY = groundYAt(checkX, 0);
              if (checkY + meteor.radius >= groundY) {
                resolveMeteorImpact(meteor, checkX, groundY, true); // Ground collision, create crater
                meteorRemoved = true;
                break;
              }
            }
          }

          // Remove meteors that fly far off-screen
          if (!meteorRemoved && (meteor.x < -meteor.radius * 4 || meteor.x > terrain.width + meteor.radius * 4 || meteor.y > terrain.height + meteor.radius * 4 || meteor.y < -meteor.radius * 4)) {
            meteorRemoved = true;
          }

          if (!meteorRemoved) {
            remainingMeteors.push(meteor);
          }
        }
        activeMeteors = remainingMeteors;
      }

      function drawMeteorWarnings() {
        if (!meteorWarnings.length) return;
        ctx.save();
        ctx.lineWidth = 2;
        for (const warn of meteorWarnings) {
          const phase = (warn.flash % METEOR_WARNING_FLASH_MS) / METEOR_WARNING_FLASH_MS;
          const pulse = Math.sin(phase * Math.PI * 2) * 0.5 + 0.5;
          const alpha = METEOR_WARNING_ALPHA_MIN + (METEOR_WARNING_ALPHA_MAX - METEOR_WARNING_ALPHA_MIN) * pulse;
          ctx.strokeStyle = `rgba(255, 200, 120, ${alpha.toFixed(3)})`;
          ctx.setLineDash([10, 8]);
          ctx.beginPath();
          ctx.moveTo(warn.spawn.x, warn.spawn.y);
          ctx.lineTo(warn.target.x, warn.target.y);
          ctx.stroke();
          ctx.setLineDash([]);
          const samples = 3;
          for (let i = 0; i <= samples; i++) {
            const t = i / samples;
            const px = warn.spawn.x + (warn.target.x - warn.spawn.x) * t;
            const py = warn.spawn.y + (warn.target.y - warn.spawn.y) * t;
            const r = warn.radius * (0.9 - 0.4 * Math.abs(0.5 - t));
            ctx.beginPath();
            ctx.arc(px, py, Math.max(4, r), 0, Math.PI * 2);
            ctx.stroke();
          }
        }
        ctx.restore();
      }

      function drawMeteors() {
        if (!activeMeteors.length) return;
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        for (const meteor of activeMeteors) {
          ctx.save();
          ctx.translate(meteor.x, meteor.y);
          ctx.rotate(meteor.angle);
          const coreRadius = meteor.radius * 0.6;
          const tailLength = meteor.radius * 3.2;
          const gradient = ctx.createLinearGradient(-tailLength, 0, coreRadius, 0);
          gradient.addColorStop(0, 'rgba(80, 40, 10, 0)');
          gradient.addColorStop(0.35, 'rgba(255, 110, 40, 0.35)');
          gradient.addColorStop(0.75, 'rgba(255, 200, 100, 0.8)');
          gradient.addColorStop(1, 'rgba(255, 240, 190, 0.95)');
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.moveTo(-tailLength, -coreRadius * 0.6);
          ctx.quadraticCurveTo(-coreRadius * 0.3, -coreRadius * 0.9, coreRadius, -coreRadius * 0.2);
          ctx.lineTo(coreRadius, coreRadius * 0.2);
          ctx.quadraticCurveTo(-coreRadius * 0.3, coreRadius * 0.9, -tailLength, coreRadius * 0.6);
          ctx.closePath();
          ctx.fill();
          ctx.restore();

          ctx.beginPath();
          ctx.fillStyle = 'rgba(255, 240, 210, 0.9)';
          ctx.arc(meteor.x, meteor.y, coreRadius * 0.75, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.fillStyle = 'rgba(255, 140, 60, 0.7)';
          ctx.arc(meteor.x, meteor.y, coreRadius * 1.05, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.restore();
      }

      function applyExplosionEffects(x, y, sourceBomb = null) {
        if (bombs.length > 0) {
          const chainRadiusSq = BOMB_CHAIN_RADIUS * BOMB_CHAIN_RADIUS;
          for (const other of bombs) {
            if (other === sourceBomb) continue;
            if (!other || other.detonated) continue;
            if (other.armingMs > 0) continue;
            const dx = other.x - x;
            const dy = other.y - y;
            if (dx * dx + dy * dy <= chainRadiusSq) {
              explodeBomb(other);
            }
          }
        }
        checkLanderExplosion(x, y);
      }

      function explodeBomb(bomb) {
        if (!bomb || bomb.detonated) return;
        bomb.detonated = true;
        bomb.fuseMs = 0;
        const x = bomb.x;
        const y = bomb.y;
        if (audio && typeof audio.playExplosion === 'function') {
          audio.playExplosion();
        }

        const shardCount = 18 + (Math.random() * 10 | 0);
        for (let i = 0; i < shardCount; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = 0.14 + Math.random() * 0.22;
          const radius = 6 + Math.random() * 6;
          const life = 900 + Math.random() * 900;
          debris.push({
            x,
            y,
            vx: lander.vx * 0.15 + Math.cos(angle) * speed,
            vy: lander.vy * 0.12 + Math.sin(angle) * speed - 0.02,
            radius,
            radiusStart: radius,
            life,
            lifeStart: life,
            glowBias: 0.85 + Math.random() * 0.4,
            kind: 'shard',
          });
        }

        const emberCount = 12 + (Math.random() * 8 | 0);
        for (let i = 0; i < emberCount; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = 0.10 + Math.random() * 0.18;
          const radius = 4 + Math.random() * 4;
          const life = 800 + Math.random() * 600;
          debris.push({
            x,
            y,
            vx: lander.vx * 0.1 + Math.cos(angle) * speed * 0.75,
            vy: lander.vy * 0.1 + Math.sin(angle) * speed * 0.75 - 0.01,
            radius,
            radiusStart: radius,
            life,
            lifeStart: life,
            glowBias: 0.6 + Math.random() * 0.25,
            kind: 'ember',
          });
        }

        const smokeCount = 20 + (Math.random() * 12 | 0);
        for (let i = 0; i < smokeCount; i++) {
          const spread = (Math.random() - 0.5) * BOMB_MAX_RADIUS * 1.2;
          const spawnX = clamp(x + spread, 0, terrain.width);
          const groundY = groundYAt(spawnX, y);
          const radius = 14 + Math.random() * 16;
          const life = 1700 + Math.random() * 1400;
          blastSmoke.push({
            x: spawnX,
            y: groundY - radius * (0.55 + Math.random() * 0.25),
            vx: (Math.random() - 0.5) * 0.08,
            vy: -0.02 - Math.random() * 0.02,
            radius,
            radiusStart: radius,
            life,
            lifeStart: life,
            heat: 0.75 + Math.random() * 0.35,
            source: 'blast',
          });
        }

        const blastSurface = findSurfaceBelow(x, Math.max(0, y - BOMB_MAX_RADIUS));
        const blastChainY = blastSurface ? blastSurface.y : y;
        deformTerrainAt(x, y, BOMB_MAX_RADIUS, BOMB_MAX_DEPTH);
        applyExplosionEffects(x, blastChainY, bomb);
      }

      function deformTerrainAt(x, y, radius, depth) {
        if (radius <= 0) return;
        const cellSize = terrain.cellSize;
        const radiusSq = radius * radius;
        const minCol = Math.max(0, Math.floor((x - radius) / cellSize));
        const maxCol = Math.min(terrain.cols - 1, Math.ceil((x + radius) / cellSize));
        const minRow = Math.max(0, Math.floor((y - depth - radius) / cellSize));
        const maxRow = Math.min(terrain.rows - 1, Math.ceil((y + radius) / cellSize));
        for (let row = minRow; row <= maxRow; row++) {
          for (let col = minCol; col <= maxCol; col++) {
            const cx = (col + 0.5) * cellSize;
            const cy = (row + 0.5) * cellSize;
            const dx = cx - x;
            const dy = cy - y;
            if (dx * dx + dy * dy <= radiusSq) {
              setSolidCell(col, row, 0);
            }
          }
        }
        terrain.dirtyRender = true;
        alignPadToSurface(pad.x + pad.w / 2, pad.y + pad.h);
      }

      function isInsideBlackHole(hole, x, y, radiusOverride = null) {
        if (!hole) return false;
        const radius = radiusOverride != null ? radiusOverride : holeEventRadius(hole);
        const dx = x - hole.x;
        const dy = y - hole.y;
        return dx * dx + dy * dy <= radius * radius;
      }

      function computeBlackHoleAcceleration(x, y, holeSet = activeBlackHoles) {
        if (!holeSet || !holeSet.length) return null;
        let ax = 0;
        let ay = 0;
        let influenced = false;
        const minDist = BLACK_HOLE_MIN_DISTANCE;
        for (const hole of holeSet) {
          const pullRadius = holePullRadius(hole);
          const dx = hole.x - x;
          const dy = hole.y - y;
          const distSq = dx * dx + dy * dy;
          if (distSq > pullRadius * pullRadius) continue;
          influenced = true;
          const dist = Math.sqrt(distSq) || minDist;
          const clampedDist = Math.max(dist, minDist);
          const falloff = 1 - Math.min(clampedDist / pullRadius, 1);
          const accelBase = BLACK_HOLE_PULL_STRENGTH * Math.pow(falloff, 0.8);
          const accel = Math.min(BLACK_HOLE_MAX_FORCE, accelBase * (pullRadius / (clampedDist + 0.0001)));
          const nx = dx / clampedDist;
          const ny = dy / clampedDist;
          ax += nx * accel;
          ay += ny * accel;
        }
        if (!influenced) return null;
        return { ax, ay };
      }

      function findBlackHoleCapture(x, y, holeSet = activeBlackHoles) {
        if (!holeSet || !holeSet.length) return null;
        for (const hole of holeSet) {
          if (isInsideBlackHole(hole, x, y)) {
            return hole;
          }
        }
        return null;
      }

      // --- Engine dust/smoke when close to terrain ---
      function castThrustRay(originX, originY, dirX, dirY, maxDistance) {
        if (dirY <= 0) return null;
        const hit = findSurfaceAlongRay(originX, originY, dirX, dirY, maxDistance);
        if (!hit) return null;
        const row = Math.floor(clamp(hit.y, 0, terrain.height - 1) / terrain.cellSize);
        const surfaceY = row * terrain.cellSize;
        const clampedX = clamp(hit.x, 0, terrain.width);
        const distance = Math.hypot(clampedX - originX, surfaceY - originY);
        return { x: clampedX, y: surfaceY, distance };
      }

      function spawnSmoke(x, y, count, spread, pushUp, prox) { // prox in [0,1] (ADJUST near emission site)
        // TUNING NOTES:
        //  - baseR: starting dust size when far; sizeBoost scales with proximity.
        //  - Increase sizeBoost to make near-ground particles bigger.
        //  - life/maxLife control how long dust lingers.
        // Colors fade from terrain hue toward brighter, lofted dust
        const groundColor = [0x33, 0x2c, 0x4a];
        const highlight = groundColor.map((c, idx) => {
          const lift = [60, 52, 44][idx];
          return Math.min(255, c + lift);
        });
        const warmHighlight = groundColor.map((c, idx) => {
          const lift = [150, 140, 130][idx];
          return Math.min(255, c + lift);
        });
        for (let i = 0; i < count; i++) {
          const a = (Math.random() - 0.5) * Math.PI * 0.6; // lateral cone
          const sp = Math.random() * spread;
          const baseR = 8 + Math.random() * 6;            // broader base dust size range
          const sizeJitter = 0.6 + Math.random() * 1.4;   // vary dust scale per particle
          const sizeBoost = 4 * prox;                     // ADJUST proximity size gain
          const radius = (baseR + sizeBoost) * sizeJitter;
          const spawnX = clamp(x + (Math.random() - 0.5) * 12, 0, terrain.width);
          const groundY = groundYAt(spawnX, y);
          const biasDepth = radius * (0.35 + Math.random() * 0.55);
          const surfaceChance = 0.18;
          const buryDepth = Math.random() < surfaceChance ? Math.random() * radius * 0.25 : biasDepth;
          let bottom = groundY + buryDepth;
          bottom += (Math.random() - 0.5) * radius * 0.28;       // jitter contact height slightly while staying beneath
          bottom = Math.max(bottom, groundY);                    // never float above the surface
          bottom = Math.min(bottom, groundY + radius * 1.6);     // allow deeper default placement without going extreme
          let spawnY = bottom - radius;
          spawnY = Math.min(spawnY, y);
          const liftMix = Math.min(0.40, 0.12 + prox * 0.26 + Math.random() * 0.16);
          const shadowBias = -10 + Math.random() * 12; // skew darker but allow some lift
          const brightMix = Math.random() < 0.45 ? (0.3 + Math.random() * 0.45) * (0.45 + prox * 0.55) : 0;
          const tint = groundColor.map((c, idx) => {
            const target = highlight[idx];
            let value = c + (target - c) * liftMix + shadowBias;
            if (brightMix > 0) {
              const warm = warmHighlight[idx];
              value += (warm - value) * brightMix;
            }
            value += (Math.random() - 0.5) * 6;
            return Math.round(Math.max(0, Math.min(255, value)));
          });
          const alpha = Math.min(230, 140 + Math.random() * 60 + prox * 40);
          const vx = Math.cos(a) * sp * (Math.random()*0.6 + 0.7);
          const rawLift = Math.abs(Math.sin(a) * sp) * 0.2 + pushUp * 0.45; // base upward impulse from thrust cone
          const cappedLift = Math.min(rawLift, 0.06 + prox * 0.06);         // cap so particles never launch far
          let vy = Math.random() * 0.05;                                    // slight downward drift to hug surface
          vy -= cappedLift;
          vy = Math.max(vy, -0.025 - prox * 0.045);                         // limit upward velocity (negative is upward)
          vy = Math.min(vy, 0.07 + prox * 0.05);                            // keep downward speed gentle
          const lifeBase = 3000 + prox * 520;
          const lifeVariance = 0.45 + Math.random() * 1.75;
          const lifeJitter = Math.random() * 360 - Math.random() * 220;
          const life = Math.max(420, lifeBase * lifeVariance + lifeJitter);
          const maxLife = life * (1.05 + Math.random() * 0.7);
          smoke.push({
            x: spawnX,
            y: spawnY,
            vx,
            vy,
            r: radius,
            life,
            maxLife,
            color: [...tint, alpha],
            prox: prox
          });
        }
      }

      function updateSmoke(dt) {
        for (const p of smoke) {
          p.life -= dt;
          if (p.life <= 0) continue;
          // gravity and slight horizontal drag
          p.vy += g * dt * 0.2; // very light fall
          p.vx *= 0.995;
          const dustPull = computeBlackHoleAcceleration(p.x, p.y);
          if (dustPull) {
            p.vx += dustPull.ax * dt * 0.45;
            p.vy += dustPull.ay * dt * 0.45;
          }
          p.x += p.vx * dt;
          p.y += p.vy * dt;
          if (findBlackHoleCapture(p.x, p.y)) {
            p.life = 0;
            continue;
          }
          // collide with ground softly
          const gy = groundYAt(p.x, p.y);
          if (p.y + p.r >= gy) {
            p.y = gy - p.r;
            p.vy *= -0.15;
            p.vx *= 0.85;
          }
        }
        smoke = smoke.filter(p => p.life > 0);
      }

      function drawSmoke() {
        if (smoke.length === 0) return;
        ctx.save();
        ctx.globalCompositeOperation = 'source-over';
        for (const p of smoke) {
          if (p.life <= 0) continue;
          const aLife = Math.max(0, Math.min(1, p.life / p.maxLife));
          const aProx = 0.25 + 0.75 * (p.prox || 0);    // ADJUST proximity alpha gain
          const alphaRaw = (p.color[3]/255) * aProx * (0.25 + 0.75 * aLife);
          const alpha = Math.min(0.95, alphaRaw);       // cap dust opacity at 95%
          ctx.fillStyle = `rgba(${p.color[0]},${p.color[1]},${p.color[2]},${alpha})`;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.r * (1.2 - 0.6*aLife), 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.restore();
      }
      // --- End smoke helpers ---

      // Draw functions
      function drawLander() {
        if (exploded) return;
        ctx.save();
        ctx.translate(lander.x, lander.y);
        ctx.rotate(lander.angle);
        ctx.fillStyle = '#e8e8ff';
        ctx.beginPath();
        ctx.moveTo(0, -lander.height / 2);
        ctx.lineTo(-lander.width / 2, lander.height / 2);
        ctx.lineTo(lander.width / 2, lander.height / 2);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = '#c0c0f0';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-lander.legAttachOffset, lander.height / 2);
        ctx.lineTo(-lander.legFootOffset, lander.height / 2 + lander.legLength);
        ctx.moveTo(lander.legAttachOffset, lander.height / 2);
        ctx.lineTo(lander.legFootOffset, lander.height / 2 + lander.legLength);
        ctx.stroke();
        if (keys['ArrowUp'] && lander.fuel > 0 && !gameOver) {
          ctx.fillStyle = '#ff9933';
          ctx.beginPath();
          ctx.moveTo(0, lander.height / 2);
          ctx.lineTo(-5, lander.height / 2 + 15);
          ctx.lineTo(5, lander.height / 2 + 15);
          ctx.closePath();
          ctx.fill();
        }
        ctx.restore();
      }

      function drawTerrain() {
        const cellSize = terrain.cellSize;
        ctx.fillStyle = '#332c4a';
        for (let row = 0; row < terrain.rows; row++) {
          let runStart = -1;
          for (let col = 0; col <= terrain.cols; col++) {
            const solid = col < terrain.cols ? isSolidCell(col, row) : false;
            if (solid) {
              if (runStart === -1) runStart = col;
            } else if (runStart !== -1) {
              const x = runStart * cellSize;
              const y = row * cellSize;
              const w = (col - runStart) * cellSize;
              ctx.fillRect(x, y, w, cellSize);
              runStart = -1;
            }
          }
        }

        // landing pad drawn on top
        ctx.fillStyle = `rgba(46, 204, 113, ${padGlowAlpha})`;
        ctx.fillRect(pad.x, pad.y, pad.w, pad.h);

        if (padFlash > 0) {
          const t = (padFlash / 1200);
          ctx.save();
          ctx.lineWidth = 3;
          ctx.strokeStyle = `rgba(255, 255, 255, ${0.2 + 0.6 * Math.abs(Math.sin(t * Math.PI * 4))})`;
          ctx.strokeRect(pad.x - 4, pad.y - 4, pad.w + 8, pad.h + 8);
          ctx.restore();
        }
      }

      function drawBlackHoles(holes) {
        if (!holes || !holes.length) return;
        const cellSize = terrain.cellSize;
        const phase = blackHolePhase;
        ctx.save();
        const prev = ctx.imageSmoothingEnabled;
        ctx.imageSmoothingEnabled = false;
        for (const hole of holes) {
          const eventRadius = holeEventRadius(hole);
          const rimRadius = eventRadius + cellSize * 3.2;
          const cells = Math.ceil(rimRadius / cellSize);
          for (let gy = -cells; gy <= cells; gy++) {
            for (let gx = -cells; gx <= cells; gx++) {
              const cx = hole.x + gx * cellSize;
              const cy = hole.y + gy * cellSize;
              const dx = cx - hole.x;
              const dy = cy - hole.y;
              const dist = Math.hypot(dx, dy);
              if (dist > rimRadius + cellSize * 0.5) continue;
              let color = null;
              if (dist <= eventRadius - cellSize * 0.4) {
                color = '#000000';
              } else if (dist <= eventRadius + cellSize * 0.8) {
                const shade = 8 + Math.floor(Math.max(0, (dist - (eventRadius - cellSize * 0.2)) / cellSize) * 6);
                color = `rgb(${shade},${shade},${shade + 6})`;
              } else {
                const swirl = Math.sin(phase * 1.6 + gx * 0.8 + gy * 0.55);
                const falloff = 1 - Math.min(1, (dist - eventRadius) / (rimRadius - eventRadius + 0.0001));
                const r = Math.max(20, Math.min(70, 35 + swirl * 14));
                const g = Math.round(70 + 90 * falloff + swirl * 18);
                const b = Math.round(110 + 110 * falloff + swirl * 28);
                const alpha = 0.35 + falloff * 0.45;
                color = `rgba(${r},${g},${b},${alpha})`;
              }
              if (!color) continue;
              const half = cellSize / 2;
              ctx.fillStyle = color;
              ctx.fillRect(Math.round(cx - half), Math.round(cy - half), Math.ceil(cellSize), Math.ceil(cellSize));
            }
          }
          ctx.strokeStyle = 'rgba(120, 90, 200, 0.25)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.arc(hole.x, hole.y, eventRadius + cellSize * 0.5, 0, Math.PI * 2);
          ctx.stroke();
        }
        ctx.imageSmoothingEnabled = prev;
        ctx.restore();
      }

      function drawEditorGuides() {
        ctx.save();
        ctx.lineWidth = 2;
        // highlight pad edges for clarity
        ctx.strokeStyle = 'rgba(46, 204, 113, 0.8)';
        ctx.strokeRect(pad.x, pad.y, pad.w, pad.h);
        const spawn = editorState.spawn;
        ctx.fillStyle = '#4da3ff';
        ctx.beginPath();
        ctx.arc(spawn.x, spawn.y, 10, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#ffffff';
        ctx.stroke();
        ctx.fillStyle = '#d8ecff';
        ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace';
        ctx.textAlign = 'center';
        ctx.fillText('Spawn', spawn.x, spawn.y - 16);
        ctx.fillStyle = '#b8ffd4';
        ctx.fillText('Landing', pad.x + pad.w / 2, pad.y - 8);

        const holes = ensureEditorBlackHoles();
        if (holes.length) {
          ctx.save();
          ctx.setLineDash([terrain.cellSize * 0.9, terrain.cellSize * 0.6]);
          for (const hole of holes) {
            const eventRadius = holeEventRadius(hole);
            const pullRadius = holePullRadius(hole);
            ctx.strokeStyle = 'rgba(180, 150, 255, 0.75)';
            ctx.beginPath();
            ctx.arc(hole.x, hole.y, eventRadius, 0, Math.PI * 2);
            ctx.stroke();
            ctx.strokeStyle = 'rgba(120, 90, 200, 0.25)';
            ctx.beginPath();
            ctx.arc(hole.x, hole.y, pullRadius, 0, Math.PI * 2);
            ctx.stroke();
            ctx.fillStyle = 'rgba(200, 180, 255, 0.9)';
            ctx.fillRect(hole.x - 4, hole.y - 4, 8, 8);
            ctx.fillStyle = '#dcd2ff';
            ctx.fillText('Black hole', hole.x, hole.y - eventRadius - 10);
          }
          ctx.restore();
        }

        const meteors = ensureEditorMeteors();
        if (meteors.length || editorState.pendingMeteor) {
          ctx.save();
          ctx.setLineDash([8, 8]);
          for (let i = 0; i < meteors.length; i++) {
            const meteor = meteors[i];
            const spawnHandle = meteorSpawnHandlePosition(meteor);
            const isSelected = i === editorState.selectedMeteor;
            const color = isSelected ? 'rgba(255, 214, 102, 0.95)' : 'rgba(255, 140, 66, 0.85)';
            ctx.strokeStyle = color;
            ctx.lineWidth = isSelected ? 3 : 2;
            ctx.beginPath();
            ctx.moveTo(spawnHandle.x, spawnHandle.y);
            ctx.lineTo(meteor.target.x, meteor.target.y);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.strokeStyle = color;
            ctx.beginPath();
            ctx.arc(spawnHandle.x, spawnHandle.y, meteor.radius, 0, Math.PI * 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(meteor.target.x, meteor.target.y, Math.max(6, meteor.radius * 0.6), 0, Math.PI * 2);
            ctx.stroke();
            ctx.fillStyle = color;
            ctx.font = '11px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace';
            const label = `t=${(meteor.startMs/1000).toFixed(1)}s  warn=${(meteor.warningLeadMs/1000).toFixed(1)}s  v=${meteor.speed.toFixed(2)}  r=${meteor.radius.toFixed(0)}`;
            ctx.fillText(label, spawnHandle.x + 12, spawnHandle.y - 12);
            ctx.setLineDash([8, 8]);
          }
          if (editorState.pendingMeteor) {
            const pending = editorState.pendingMeteor;
            const spawnHandle = meteorSpawnHandlePosition(pending);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(spawnHandle.x, spawnHandle.y);
            ctx.lineTo(pending.target.x, pending.target.y);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.arc(spawnHandle.x, spawnHandle.y, pending.radius, 0, Math.PI * 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(pending.target.x, pending.target.y, Math.max(6, pending.radius * 0.6), 0, Math.PI * 2);
            ctx.stroke();
          }
          ctx.restore();
        }

        ctx.textAlign = 'left';
        const cursor = editorState.cursorWorld;
        if (cursor) {
          ctx.strokeStyle = 'rgba(255, 255, 255, 0.25)';
          ctx.beginPath();
          ctx.moveTo(cursor.x - 10, cursor.y);
          ctx.lineTo(cursor.x + 10, cursor.y);
          ctx.moveTo(cursor.x, cursor.y - 10);
          ctx.lineTo(cursor.x, cursor.y + 10);
          ctx.stroke();
        }
        ctx.restore();
      }

      function drawHUD() {
        const isGameplay = appMode === APP_MODE.PLAY || appMode === APP_MODE.TEST;
        if (isGameplay) {
          setInfoMessage(
            `Level: ${terrain.levelName} | Fuel: ${lander.fuel.toFixed(1)} | Velocity: ${Math.sqrt(lander.vx ** 2 + lander.vy ** 2).toFixed(2)} | Angle: ${(lander.angle * 57.2958).toFixed(0)}`,
            'Status'
          );
        } else {
          clearInfoMessage();
        }
        if (!isGameplay && infoPanel) {
          infoPanel.classList.remove('debug-hidden');
        }
        if (isGameplay && gameOver) {
          ctx.fillStyle = '#ffffff';
          ctx.font = '16px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText(message, width / 2, 28);
        } else if (appMode === APP_MODE.EDITOR) {
          ctx.fillStyle = '#ffffff';
          ctx.font = '16px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText('Level Editor', width / 2, 28);
        }
      }

      function drawDebugOverlay(k) {
        // Hide the DOM info panel so it doesn't cover the canvas debug overlay
        if (infoPanel) {
          const gameplayMode = appMode === APP_MODE.PLAY || appMode === APP_MODE.TEST;
          if (gameplayMode) {
            infoPanel.classList.toggle('debug-hidden', showDebug);
          } else {
            infoPanel.classList.remove('debug-hidden');
          }
        }
        if (!showDebug) return;
        // Ensure overlay renders in screen space with full opacity
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0); // identity transform
        ctx.globalAlpha = 1;
        const activeBombs = bombs.filter(b => !b.detonated);
        const nextFuseMs = activeBombs.length === 0 ? null : activeBombs.reduce((min, b) => Math.min(min, b.fuseMs), Infinity);
        const lines = [
          `level: ${terrain.levelName}  worldWidth: ${terrain.width.toFixed(0)}  padX: ${pad.x.toFixed(1)}`,
          `camLag: ${tune.camLag.toFixed(4)}  (Q/A)`,
          `lookGainX: ${tune.lookGainX.toFixed(0)}  (W/S)`,
          `lookGainY: ${tune.lookGainY.toFixed(0)}  (E/D)`,
          `lookCap: ${tune.lookCap.toFixed(0)}  (R/F)`,
          `parallaxFar: ${tune.parallaxFar.toFixed(2)}  (T/G)`,
          `parallaxNear: ${tune.parallaxNear.toFixed(2)}  (Y/H)`,
          `thrustPower: ${lander.thrustPower.toFixed(4)}  (U/J)`,
          `rotateAccel: ${lander.rotateAccel.toExponential(2)}  (I/K)`,
          `rotateDamping: ${lander.rotateDamping.toFixed(2)}  (O/L)`,
          `gravity g: ${g.toFixed(5)}  (P/;)`,
          `bounce: ${tune.bounce.toFixed(2)}  (B/N)`,
          `friction: ${tune.friction.toFixed(2)}  (M/,)`,
          `cam: (${camX.toFixed(1)}, ${camY.toFixed(1)})  lander: (${lander.x.toFixed(1)}, ${lander.y.toFixed(1)})`,
          `vel: (${lander.vx.toFixed(3)}, ${lander.vy.toFixed(3)})  ang: ${lander.angle.toFixed(2)}  angVel: ${lander.angularVelocity.toFixed(5)}`,
          `bombs: ${activeBombs.length}  cooldown: ${bombCooldown.toFixed(0)}ms  next fuse: ${nextFuseMs === null ? '' : (nextFuseMs / 1000).toFixed(2) + 's'}`,
          `black holes: ${activeBlackHoles.length}`,
          `Hold H to toggle this overlay. R to reset.`
        ];
        ctx.font = '14px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace';
        ctx.textBaseline = 'top';
        const padInset = 8, lineH = 18;
        const w = 420, h = lineH * lines.length + padInset * 2;
        ctx.fillStyle = 'rgba(0,0,0,0.70)';
        ctx.fillRect(10, 10, w, h);
        ctx.strokeStyle = '#88d0ff';
        ctx.lineWidth = 2;
        ctx.strokeRect(10.5, 10.5, w-1, h-1);
        ctx.fillStyle = '#e6f7ff';
        for (let i = 0; i < lines.length; i++) {
          ctx.fillText(lines[i], 16, 10 + padInset + lineH * i);
        }
        // Watermark in corner
        ctx.fillStyle = '#88d0ff';
        ctx.fillText('DEBUG ON (H to hide)', 16, 12);
        ctx.restore(); // restore identity transform state for subsequent draws
      }

      function update(dt) {
        blackHolePhase = (blackHolePhase + dt * 0.0024) % (Math.PI * 2);
        updateDebris(dt);
        updateWreckFlames(dt);
        updateBlastSmoke(dt);
        updateWinFx(dt);
        updateMeteors(dt);
        updateSmoke(dt);
        updateBombs(dt);
        if (padFlash > 0) padFlash -= dt;
        padPulsePhase = (padPulsePhase + (dt / PAD_PULSE_PERIOD) * Math.PI * 2) % (Math.PI * 2);
        padGlowAlpha = 0.525 + 0.325 * Math.sin(padPulsePhase);
        const gameplayMode = appMode === APP_MODE.PLAY || appMode === APP_MODE.TEST;
        if (!gameplayMode) {
          audio.setThrusterActive(false);
          return;
        }
        if (gameOver) {
          audio.setThrusterActive(false);
          return;
        }
        // Integrate motion through the reusable physics module to keep the step deterministic
        // and independently testable.
        const controlState = {
          rotateLeft: !!keys['ArrowLeft'],
          rotateRight: !!keys['ArrowRight'],
          thrust: !!keys['ArrowUp'],
        };
        const edgePadding = 12;
        const minX = edgePadding;
        const maxX = Math.max(edgePadding, terrain.width - edgePadding);
        const integrationResult = Physics.integrateLander(lander, dt, controlState, {
          g,
          fuelBurnRate: Physics.DEFAULT_FUEL_BURN_RATE,
          bounce: tune.bounce,
          boundaries: { minX, maxX },
          computeBlackHoleAcceleration,
          findBlackHoleCapture,
          castThrustRay,
        });
        audio.setThrusterActive(integrationResult.thrusterActive);
        if (integrationResult.captureHole) {
          consumeLanderIntoBlackHole(integrationResult.captureHole);
          return;
        }
        if (integrationResult.thrusterDust) {
          const { emitX, emitY, spawnCount, spread, pushUp, prox } = integrationResult.thrusterDust;
          spawnSmoke(emitX, emitY, spawnCount, spread, pushUp, prox);
        }
        // collisions with terrain
        const contactPoints = getLanderContactPoints();
        let maxPenetration = 0;
        let impactPoint = null;
        for (const pt of contactPoints) {
          const info = resolvePenetrationAt(pt.x, pt.y);
          if (info.depth > 0.0001) {
            lander.x += info.normal.x * info.depth;
            lander.y += info.normal.y * info.depth;
            const vDot = lander.vx * info.normal.x + lander.vy * info.normal.y;
            if (vDot > 0) {
              lander.vx -= info.normal.x * vDot;
              lander.vy -= info.normal.y * vDot;
            }
            if (info.depth > maxPenetration) {
              maxPenetration = info.depth;
              impactPoint = {
                ...pt,
                x: pt.x + info.normal.x * info.depth,
                y: pt.y + info.normal.y * info.depth,
                normal: info.normal,
              };
            }
          }
        }
        if (maxPenetration > 0) {
          const settledPoints = getLanderContactPoints();
          const footContacts = settledPoints
            .filter(pt => pt.type === 'foot')
            .map(pt => {
              const sampleOffset = terrain.cellSize * 0.35;
              const footInfo = resolvePenetrationAt(pt.x, pt.y + sampleOffset);
              const surface = footInfo.surfaceY != null
                ? footInfo.surfaceY
                : groundYAt(pt.x, pt.y + terrain.cellSize * 0.5);
              const gap = surface - pt.y;
              return {
                ...pt,
                surfaceY: surface,
                gap,
                penetration: footInfo.depth,
                normal: footInfo.normal,
              };
            });
          const touchingFeet = footContacts.filter(pt => {
            const supported = pt.penetration > 0 || (pt.surfaceY != null && pt.surfaceY - pt.y <= terrain.cellSize * 0.75);
            const normalUp = !pt.normal || pt.normal.y <= -0.1;
            return supported && normalUp;
          });
          // Evaluate whether the lander satisfied all touchdown criteria using the reusable physics helper.
          const landingStatus = Physics.evaluateLanding(
            lander,
            touchingFeet,
            pad,
            terrain,
            {
              uprightTolerance: 0.26,
              padMargin: 1,
              surfaceGapTolerance: terrain.cellSize,
              maxSpeed: 0.09,
              maxHorizontalSpeed: 0.07,
              maxVerticalSpeed: 0.07,
            },
            (x, y) => groundYAt(x, y)
          );
          if (landingStatus.success) {
            landed = true;
            gameOver = true;
            exploded = false;
            lander.vx = 0;
            lander.vy = 0;
            lander.angularVelocity = 0;
            if (appMode === APP_MODE.TEST) {
              shouldRegen = false;
              message = 'Test complete! Press Esc to edit or R to retry';
              hidePostLevelMenu();
            } else {
              shouldRegen = false;
              nextLevelIndex = (currentLevelIndex + 1) % levels.length;
              const upcoming = levels[nextLevelIndex].name;
              message = upcoming
                ? `Nice landing! Press R to restart or N for ${upcoming}`
                : 'Nice landing! Press R to restart or N for the next level';
              showPostLevelMenu('success', message, upcoming);
            }
            const touchdownY = landingStatus.touchdownY != null
              ? landingStatus.touchdownY
              : groundYAt(lander.x, lander.y);
            spawnWinFx(lander.x, touchdownY - 12);
            padFlash = 1200;
            audio.stopThrusterImmediate();
            audio.playWinChime();
          } else {
            const crashX = impactPoint ? impactPoint.x : lander.x;
            const crashY = impactPoint ? impactPoint.y : groundYAt(lander.x, lander.y);
            spawnExplosion(crashX, crashY, lander.vx, lander.vy);
          }
        }
      }

      const testSuite = createTestSuite();

      /**
       * Builds a zero-dependency test harness for deterministic verification of core game logic.
       */
      function createTestSuite() {
        const tests = [];

        function expect(condition, message) {
          if (!condition) {
            throw new Error(message);
          }
        }

        function addTest(name, fn) {
          tests.push({ name, fn });
        }

        addTest('physics.integrateLander applies thrust and consumes fuel', () => {
          const landerState = {
            x: 0,
            y: 0,
            vx: 0,
            vy: 0,
            angle: 0,
            angularVelocity: 0,
            rotateAccel: 0.002,
            rotateDamping: 0.99,
            thrustPower: 0.003,
            fuel: 1,
            height: 24,
          };
          const initialFuel = landerState.fuel;
          const result = Physics.integrateLander(
            landerState,
            16,
            { rotateLeft: false, rotateRight: false, thrust: true },
            {
              g: 0,
              fuelBurnRate: Physics.DEFAULT_FUEL_BURN_RATE,
              bounce: 0,
              boundaries: { minX: -100, maxX: 100 },
            },
          );
          expect(result.thrusterActive, 'Thruster should activate when thrust control is engaged and fuel remains.');
          expect(landerState.vy < 0, 'Thruster should impart upward acceleration.');
          expect(landerState.fuel < initialFuel, 'Fuel should decrease when thrusting.');
        });

        addTest('physics.integrateLander respects horizontal bounds', () => {
          const landerState = {
            x: -5,
            y: 0,
            vx: -0.1,
            vy: 0,
            angle: 0,
            angularVelocity: 0,
            rotateAccel: 0.002,
            rotateDamping: 1,
            thrustPower: 0,
            fuel: 0,
            height: 24,
          };
          Physics.integrateLander(
            landerState,
            16,
            { rotateLeft: false, rotateRight: false, thrust: false },
            {
              g: 0,
              fuelBurnRate: Physics.DEFAULT_FUEL_BURN_RATE,
              bounce: 0.5,
              boundaries: { minX: 0, maxX: 100 },
            },
          );
          expect(landerState.x === 0, 'Lander should clamp to the minimum boundary.');
          expect(landerState.vx >= 0, 'Lander should bounce horizontally when striking the boundary.');
        });

        addTest('physics.evaluateLanding recognises safe touchdown', () => {
          const pad = { x: 50, y: 100, w: 60, h: 10 };
          const terrain = { cellSize: 8 };
          const landerState = {
            x: 80,
            y: 100,
            vx: 0.01,
            vy: -0.01,
            angle: 0.02,
          };
          const touchingFeet = [
            { surfaceY: 110, x: 70, gap: 0, penetration: 1, normal: { y: -1 } },
            { surfaceY: 110, x: 90, gap: 0, penetration: 1, normal: { y: -1 } },
          ];
          const result = Physics.evaluateLanding(
            landerState,
            touchingFeet,
            pad,
            terrain,
            {
              uprightTolerance: 0.26,
              padMargin: 1,
              surfaceGapTolerance: terrain.cellSize,
              maxSpeed: 0.09,
              maxHorizontalSpeed: 0.07,
              maxVerticalSpeed: 0.07,
            },
            () => 110,
          );
          expect(result.success, 'Landing should be successful when all thresholds are satisfied.');
          expect(Math.abs(result.touchdownY - 110) < 1e-3, 'Touchdown height should match the supporting surface.');
        });

        addTest('physics.integrateLander applies gravity', () => {
          const landerState = {
            x: 100,
            y: 100,
            vx: 0,
            vy: 0,
            angle: 0,
            angularVelocity: 0,
            rotateAccel: 0.002,
            rotateDamping: 0.99,
            thrustPower: 0.003,
            fuel: 1,
            height: 24,
          };
          Physics.integrateLander(
            landerState,
            16,
            { rotateLeft: false, rotateRight: false, thrust: false },
            {
              g: 0.001,
              fuelBurnRate: Physics.DEFAULT_FUEL_BURN_RATE,
              bounce: 0,
              boundaries: { minX: 0, maxX: 200 },
            },
          );
          expect(landerState.vy > 0, 'Gravity should increase downward velocity (positive Y).');
          expect(landerState.y > 100, 'Lander should move downward under gravity.');
        });

        addTest('physics.integrateLander handles rotation left', () => {
          const landerState = {
            x: 100,
            y: 100,
            vx: 0,
            vy: 0,
            angle: 0,
            angularVelocity: 0,
            rotateAccel: 0.002,
            rotateDamping: 0.99,
            thrustPower: 0.003,
            fuel: 1,
            height: 24,
          };
          Physics.integrateLander(
            landerState,
            16,
            { rotateLeft: true, rotateRight: false, thrust: false },
            {
              g: 0,
              fuelBurnRate: Physics.DEFAULT_FUEL_BURN_RATE,
              bounce: 0,
              boundaries: { minX: 0, maxX: 200 },
            },
          );
          expect(landerState.angularVelocity < 0, 'Rotating left should produce negative angular velocity.');
          expect(landerState.angle < 0, 'Angle should decrease when rotating left.');
        });

        addTest('physics.integrateLander handles rotation right', () => {
          const landerState = {
            x: 100,
            y: 100,
            vx: 0,
            vy: 0,
            angle: 0,
            angularVelocity: 0,
            rotateAccel: 0.002,
            rotateDamping: 0.99,
            thrustPower: 0.003,
            fuel: 1,
            height: 24,
          };
          Physics.integrateLander(
            landerState,
            16,
            { rotateLeft: false, rotateRight: true, thrust: false },
            {
              g: 0,
              fuelBurnRate: Physics.DEFAULT_FUEL_BURN_RATE,
              bounce: 0,
              boundaries: { minX: 0, maxX: 200 },
            },
          );
          expect(landerState.angularVelocity > 0, 'Rotating right should produce positive angular velocity.');
          expect(landerState.angle > 0, 'Angle should increase when rotating right.');
        });

        addTest('physics.integrateLander does not burn fuel when thrust with no fuel', () => {
          const landerState = {
            x: 100,
            y: 100,
            vx: 0,
            vy: 0,
            angle: 0,
            angularVelocity: 0,
            rotateAccel: 0.002,
            rotateDamping: 0.99,
            thrustPower: 0.003,
            fuel: 0,
            height: 24,
          };
          const result = Physics.integrateLander(
            landerState,
            16,
            { rotateLeft: false, rotateRight: false, thrust: true },
            {
              g: 0,
              fuelBurnRate: Physics.DEFAULT_FUEL_BURN_RATE,
              bounce: 0,
              boundaries: { minX: 0, maxX: 200 },
            },
          );
          expect(!result.thrusterActive, 'Thruster should not activate when fuel is depleted.');
          expect(landerState.fuel === 0, 'Fuel should remain at zero.');
        });

        addTest('physics.integrateLander applies black hole acceleration', () => {
          const landerState = {
            x: 100,
            y: 100,
            vx: 0,
            vy: 0,
            angle: 0,
            angularVelocity: 0,
            rotateAccel: 0.002,
            rotateDamping: 0.99,
            thrustPower: 0.003,
            fuel: 1,
            height: 24,
          };
          const mockBlackHoleAccel = (x, y) => ({ ax: 0.002, ay: 0.001 });
          Physics.integrateLander(
            landerState,
            16,
            { rotateLeft: false, rotateRight: false, thrust: false },
            {
              g: 0,
              fuelBurnRate: Physics.DEFAULT_FUEL_BURN_RATE,
              bounce: 0,
              boundaries: { minX: 0, maxX: 200 },
              computeBlackHoleAcceleration: mockBlackHoleAccel,
            },
          );
          expect(landerState.vx > 0, 'Black hole should impart horizontal acceleration.');
          expect(landerState.vy > 0, 'Black hole should impart vertical acceleration.');
        });

        addTest('physics.integrateLander detects black hole capture', () => {
          const landerState = {
            x: 100,
            y: 100,
            vx: 0,
            vy: 0,
            angle: 0,
            angularVelocity: 0,
            rotateAccel: 0.002,
            rotateDamping: 0.99,
            thrustPower: 0.003,
            fuel: 1,
            height: 24,
          };
          const mockHole = { x: 100, y: 100, id: 'test-hole' };
          const mockFindCapture = (x, y) => mockHole;
          const result = Physics.integrateLander(
            landerState,
            16,
            { rotateLeft: false, rotateRight: false, thrust: false },
            {
              g: 0,
              fuelBurnRate: Physics.DEFAULT_FUEL_BURN_RATE,
              bounce: 0,
              boundaries: { minX: 0, maxX: 200 },
              findBlackHoleCapture: mockFindCapture,
            },
          );
          expect(result.captureHole === mockHole, 'Result should report black hole capture.');
        });

        addTest('physics.evaluateLanding rejects landing when too fast', () => {
          const pad = { x: 50, y: 100, w: 60, h: 10 };
          const terrain = { cellSize: 8 };
          const landerState = {
            x: 80,
            y: 100,
            vx: 0.5,
            vy: 0.01,
            angle: 0.02,
          };
          const touchingFeet = [
            { surfaceY: 110, x: 70, gap: 0, penetration: 1, normal: { y: -1 } },
            { surfaceY: 110, x: 90, gap: 0, penetration: 1, normal: { y: -1 } },
          ];
          const result = Physics.evaluateLanding(
            landerState,
            touchingFeet,
            pad,
            terrain,
            {
              uprightTolerance: 0.26,
              padMargin: 1,
              surfaceGapTolerance: terrain.cellSize,
              maxSpeed: 0.09,
              maxHorizontalSpeed: 0.07,
              maxVerticalSpeed: 0.07,
            },
            () => 110,
          );
          expect(!result.success, 'Landing should fail when speed is too high.');
          expect(result.reason.okVx === false, 'Reason should indicate horizontal speed violation.');
        });

        addTest('physics.evaluateLanding rejects landing when not on pad', () => {
          const pad = { x: 50, y: 100, w: 60, h: 10 };
          const terrain = { cellSize: 8 };
          const landerState = {
            x: 20,
            y: 100,
            vx: 0.01,
            vy: 0.01,
            angle: 0.02,
          };
          const touchingFeet = [
            { surfaceY: 110, x: 15, gap: 0, penetration: 1, normal: { y: -1 } },
            { surfaceY: 110, x: 25, gap: 0, penetration: 1, normal: { y: -1 } },
          ];
          const result = Physics.evaluateLanding(
            landerState,
            touchingFeet,
            pad,
            terrain,
            {
              uprightTolerance: 0.26,
              padMargin: 1,
              surfaceGapTolerance: terrain.cellSize,
              maxSpeed: 0.09,
              maxHorizontalSpeed: 0.07,
              maxVerticalSpeed: 0.07,
            },
            () => 110,
          );
          expect(!result.success, 'Landing should fail when not positioned over the pad.');
          expect(result.reason.onPad === false, 'Reason should indicate pad position violation.');
        });

        addTest('physics.evaluateLanding rejects landing when tilted', () => {
          const pad = { x: 50, y: 100, w: 60, h: 10 };
          const terrain = { cellSize: 8 };
          const landerState = {
            x: 80,
            y: 100,
            vx: 0.01,
            vy: 0.01,
            angle: Math.PI / 3,
          };
          const touchingFeet = [
            { surfaceY: 110, x: 70, gap: 0, penetration: 1, normal: { y: -1 } },
            { surfaceY: 110, x: 90, gap: 0, penetration: 1, normal: { y: -1 } },
          ];
          const result = Physics.evaluateLanding(
            landerState,
            touchingFeet,
            pad,
            terrain,
            {
              uprightTolerance: 0.26,
              padMargin: 1,
              surfaceGapTolerance: terrain.cellSize,
              maxSpeed: 0.09,
              maxHorizontalSpeed: 0.07,
              maxVerticalSpeed: 0.07,
            },
            () => 110,
          );
          expect(!result.success, 'Landing should fail when lander is tilted beyond tolerance.');
          expect(result.reason.upright === false, 'Reason should indicate upright angle violation.');
        });

        addTest('physics.evaluateLanding rejects landing without support', () => {
          const pad = { x: 50, y: 100, w: 60, h: 10 };
          const terrain = { cellSize: 8 };
          const landerState = {
            x: 80,
            y: 100,
            vx: 0.01,
            vy: 0.01,
            angle: 0.02,
          };
          const touchingFeet = [];
          const result = Physics.evaluateLanding(
            landerState,
            touchingFeet,
            pad,
            terrain,
            {
              uprightTolerance: 0.26,
              padMargin: 1,
              surfaceGapTolerance: terrain.cellSize,
              maxSpeed: 0.09,
              maxHorizontalSpeed: 0.07,
              maxVerticalSpeed: 0.07,
            },
            () => 110,
          );
          expect(!result.success, 'Landing should fail when no feet are touching ground.');
          expect(result.reason === 'no-support', 'Reason should indicate lack of support.');
        });

        addTest('physics.computeThrusterDust returns null when no ray caster provided', () => {
          const landerState = {
            x: 100,
            y: 100,
            vx: 0,
            vy: 0,
            angle: 0,
            angularVelocity: 0,
            rotateAccel: 0.002,
            rotateDamping: 0.99,
            thrustPower: 0.003,
            fuel: 1,
            height: 24,
          };
          const dust = Physics.computeThrusterDust(landerState, {});
          expect(dust === null, 'Dust computation should return null when no ray caster is provided.');
        });

        addTest('physics.computeThrusterDust computes dust when close to ground', () => {
          const landerState = {
            x: 100,
            y: 100,
            vx: 0,
            vy: 0,
            angle: 0,
            angularVelocity: 0,
            rotateAccel: 0.002,
            rotateDamping: 0.99,
            thrustPower: 0.003,
            fuel: 1,
            height: 24,
          };
          const mockCastRay = (x, y, dirX, dirY, maxDist) => {
            return { x: 100, y: 130 };
          };
          const dust = Physics.computeThrusterDust(landerState, {
            castThrustRay: mockCastRay,
            dustMaxDistance: 70,
          });
          expect(dust !== null, 'Dust should be emitted when thruster is close to ground.');
          expect(dust.spawnCount > 0, 'Dust spawn count should be positive.');
          expect(dust.prox > 0 && dust.prox <= 1, 'Proximity should be normalized between 0 and 1.');
        });

        addTest('physics.computeThrusterDust returns null when too far from ground', () => {
          const landerState = {
            x: 100,
            y: 100,
            vx: 0,
            vy: 0,
            angle: 0,
            angularVelocity: 0,
            rotateAccel: 0.002,
            rotateDamping: 0.99,
            thrustPower: 0.003,
            fuel: 1,
            height: 24,
          };
          const mockCastRay = (x, y, dirX, dirY, maxDist) => {
            return { x: 100, y: 300 };
          };
          const dust = Physics.computeThrusterDust(landerState, {
            castThrustRay: mockCastRay,
            dustMaxDistance: 70,
          });
          expect(dust === null, 'Dust should not be emitted when thruster is too far from ground.');
        });

        function now() {
          if (typeof performance !== 'undefined' && performance && typeof performance.now === 'function') {
            return performance.now();
          }
          return Date.now();
        }

        function runAll(options = {}) {
          const results = [];
          for (const test of tests) {
            const start = now();
            try {
              test.fn({ expect });
              const duration = now() - start;
              results.push({ name: test.name, success: true, duration });
            } catch (error) {
              const duration = now() - start;
              results.push({ name: test.name, success: false, error, duration });
            }
          }
          if (options.log !== false) {
            results.forEach((result) => {
              if (result.success) {
                console.info(`[MoonLander][test]  ${result.name} (${result.duration.toFixed(3)}ms)`);
              } else {
                console.error(`[MoonLander][test]  ${result.name}`, result.error);
              }
            });
          }
          if (options.updateInfoPanel) {
            const passed = results.filter(r => r.success).length;
            const summary = `${passed}/${results.length} tests passed`;
            setInfoMessage(summary, 'Test Suite');
          }
          return results;
        }

        return {
          addTest,
          runAll,
          expect,
          tests,
        };
      }

      function loop(timestamp) {
        if (!lastTime) lastTime = timestamp;
        const dt = Math.min(timestamp - lastTime, 64);
        lastTime = timestamp;
        update(dt);
        ctx.clearRect(0, 0, width, height);
        // solid sky so CSS doesnt bleed through
        ctx.fillStyle = '#000010';
        ctx.fillRect(0, 0, width, height);
        // Parallax background in screen space (no camera transforms here)
        // --- Camera follow with smoothing and look-ahead ---
        const isGameplay = appMode === APP_MODE.PLAY || appMode === APP_MODE.TEST;
        const isEditor = appMode === APP_MODE.EDITOR;
        if (camX === null) {
          if (isGameplay) {
            camX = lander.x;
            camY = lander.y;
          } else if (isEditor) {
            camX = editorState.camX ?? terrain.width / 2;
            camY = editorState.camY ?? height * 0.65;
          } else {
            camX = width / 2;
            camY = height / 2;
          }
        }
        let k = 0;
        if (isGameplay) {
          const lookX = Math.max(-tune.lookCap, Math.min(tune.lookCap, lander.vx * tune.lookGainX));
          const lookY = Math.max(-tune.lookCap, Math.min(tune.lookCap, lander.vy * tune.lookGainY));
          const targetX = lander.x + lookX;
          const targetY = lander.y + lookY;
          k = Math.min(1, dt * tune.camLag);
          camX += (targetX - camX) * k;
          camY += (targetY - camY) * k;
          const halfViewX = width / 2;
          if (terrain.width <= width) {
            camX = terrain.width / 2;
          } else {
            const minCamX = halfViewX;
            const maxCamX = terrain.width - halfViewX;
            camX = Math.max(minCamX, Math.min(maxCamX, camX));
          }
          const groundFloor = height * 0.5;
          const ceiling = height * 0.15;
          camY = Math.max(ceiling, Math.min(groundFloor, camY));
        } else if (isEditor) {
          camX = editorState.camX ?? terrain.width / 2;
          camY = editorState.camY ?? height * 0.65;
          k = 0;
        } else {
          camX = width / 2;
          camY = height / 2;
          k = 0;
        }
        // --- End camera follow ---
        tileLayer(bgFar,  -camX * tune.parallaxFar, -camY * tune.parallaxFar);
        tileLayer(bgNear, -camX * tune.parallaxNear, -camY * tune.parallaxNear);

        // Center the world so the lander stays in the middle
        ctx.save();
        ctx.translate(width / 2 - camX, height / 2 - camY);
        if (isGameplay || isEditor) {
          drawTerrain();
          drawBlackHoles(isGameplay ? activeBlackHoles : terrain.blackHoles);
          if (isGameplay) {
            drawMeteorWarnings();
            drawMeteors();
            drawBombs();
            drawSmoke();
            drawBlastSmoke();
            drawWreckFlames();
            drawLander();
            drawDebris();
            drawWinFx();
          } else if (isEditor) {
            drawEditorGuides();
          }
        }
        ctx.restore();
        drawHUD();
        drawDebugOverlay(k);
        requestAnimationFrame(loop);
      }

      function handleResize() {
        resizeCanvas();
        if (manualTouchPreference === null) {
          refreshTouchControlsPreference();
        }
      }

      /**
       * Boots the Moon Lander game loop and initialises UI state.
       */
      function startGame() {
        window.addEventListener('resize', handleResize);
        handleResize();
        enterMenu();
        updateEditorOverlay();
        requestAnimationFrame(loop);
      }

      /**
       * Determines whether the embedded test suite should run automatically based on URL flags.
       */
      function shouldAutoRunTests() {
        if (typeof window === 'undefined') return false;
        const hash = window.location.hash || '';
        const query = window.location.search || '';
        return hash.includes('run-tests') || query.includes('run-tests');
      }

      /**
       * Exposes a lightweight snapshot of runtime state for debugging and tests.
       */
      function getStateSnapshot() {
        return {
          mode: appMode,
          gameOver,
          level: terrain ? terrain.levelName : null,
          lander: {
            x: lander.x,
            y: lander.y,
            vx: lander.vx,
            vy: lander.vy,
            angle: lander.angle,
            fuel: lander.fuel,
          },
        };
      }

      const moonLanderAPI = {
        start: startGame,
        physics: Physics,
        tests: {
          runAll: testSuite.runAll,
          list: () => testSuite.tests.map(test => test.name),
        },
        getStateSnapshot,
      };

      window.MoonLander = moonLanderAPI;

      startGame();

      if (shouldAutoRunTests()) {
        moonLanderAPI.tests.runAll({ updateInfoPanel: true });
      }
    })();
  </script>
</body>
</html>
