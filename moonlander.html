<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Moon Lander Game</title>
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      background: #101420;
      overflow: hidden;
      color: #fafafa;
      font-family: sans-serif;
    }
    #gameCanvas {
      display: block;
      margin: 0 auto;
      background: transparent;
    }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="600" height="400"></canvas>
  <div id="info"></div>
  <script>
    (() => {
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      const info = document.getElementById('info');
      const width = canvas.width;
      const height = canvas.height;

      // --- Procedural terrain (peaks, valleys, and a flat pad segment) ---
      const levels = [
        {
          name: 'Crater Run',
          worldWidth: 2000,
          baseBand: [0.65, 0.9],
          amp: 0.22,
          waveScale: 0.65,
          waveFreq: 0.012,
          roughWaveFreq: 0.037,
          noiseScale: 0.12,
          padOffset: 0.78,
        },
        {
          name: 'Basalt Dunes',
          worldWidth: 2400,
          baseBand: [0.60, 0.88],
          amp: 0.26,
          waveScale: 0.72,
          waveFreq: 0.009,
          roughWaveFreq: 0.028,
          noiseScale: 0.16,
          padOffset: 0.66,
        },
        {
          name: 'Ridge Maze',
          worldWidth: 2600,
          baseBand: [0.58, 0.9],
          amp: 0.28,
          waveScale: 0.80,
          waveFreq: 0.007,
          roughWaveFreq: 0.032,
          noiseScale: 0.18,
          padOffset: 0.82,
        },
      ];

      let currentLevelIndex = 0;
      let nextLevelIndex = 0;

      let terrain = { samples: [], step: 4, width: width, levelName: levels[0].name };
      const pad = { x: 0, y: 0, w: 110, h: 10 };
      const PAD_PULSE_PERIOD = 3000; // ms for a full pad glow cycle
      const BOMB_FUSE_MS = 3000;      // ms until detonation
      const BOMB_ARM_DELAY = 220;     // ms before the bomb can detonate post-drop
      const BOMB_BLINK_BASE = 0.002;  // radians/ms baseline blink speed
      const BOMB_BLINK_ACCEL = 0.013; // blink speed gain as fuse approaches zero
      const BOMB_MAX_RADIUS = 68;     // px crater influence radius
      const BOMB_MAX_DEPTH = 36;      // px maximum depth carved into terrain
      const BOMB_SELF_PUSH = 18;      // px upward nudge if lander inside blast
      const BOMB_MAX_ACTIVE = 6;      // limit simultaneous live bombs to keep perf stable
      const BOMB_DROP_COOLDOWN = 220; // ms cooldown between drops
      const BOMB_CHAIN_RADIUS = 86;   // px radius within which blasts trigger other bombs
      const EXPLOSION_KILL_RADIUS = 74; // px radius that destroys the lander from a blast
      const CRASH_CRATER_RADIUS = 78; // px terrain deformation from crashing
      const CRASH_CRATER_DEPTH = 44;  // px depth carved by a crash explosion

      function generateTerrain(index = currentLevelIndex) {
        currentLevelIndex = index;
        nextLevelIndex = currentLevelIndex;
        const level = levels[currentLevelIndex];
        terrain.levelName = level.name;
        const step = 4; // px between samples for the height profile
        terrain.step = step;
        terrain.width = level.worldWidth;
        const cols = Math.ceil(level.worldWidth / step) + 1;
        const h = new Array(cols);

        const baseMin = height * level.baseBand[0];
        const baseMax = height * level.baseBand[1];
        const baseMid = (baseMin + baseMax) * 0.5;
        const amp = height * level.amp;

        let y = baseMid;
        for (let i = 0; i < cols; i++) {
          const t = i * step;
          const primaryWave = Math.sin(t * level.waveFreq) * amp * level.waveScale;
          const secondaryWave = Math.sin((t + 500) * level.roughWaveFreq) * amp * 0.35;
          const target = baseMid + primaryWave + secondaryWave;
          const noise = (Math.random() - 0.5) * amp * level.noiseScale;
          y = y * 0.55 + (target + noise) * 0.45;
          y = Math.max(baseMin, Math.min(baseMax, y));
          h[i] = y | 0;
        }

        // create a flat segment for landing pad away from the start
        const padW = 110; // keep in sync with pad.w
        const padStepCount = Math.max(4, Math.round(padW / step));
        const padStartPx = Math.floor(level.worldWidth * level.padOffset - padW / 2);
        const padStartIdx = Math.max(0, Math.min(cols - padStepCount - 1, Math.floor(padStartPx / step)));
        let padY = h[padStartIdx];
        for (let i = 1; i < padStepCount; i++) padY = Math.min(padY, h[padStartIdx + i]);
        for (let i = 0; i < padStepCount; i++) h[padStartIdx + i] = padY;

        terrain.samples = h;

        // update pad position to sit on top of the flat segment
        pad.w = padW;
        pad.x = padStartIdx * step;
        pad.y = padY - pad.h; // top of terrain minus pad height
      }

      function terrainY(x) {
        // linear interpolation between nearest samples
        const step = terrain.step;
        const clampedX = Math.max(0, Math.min(terrain.width, x));
        const idx = Math.floor(clampedX / step);
        const a = Math.max(0, Math.min(terrain.samples.length - 1, idx));
        const b = Math.max(0, Math.min(terrain.samples.length - 1, idx + 1));
        const t = (clampedX - a * step) / step;
        return (terrain.samples[a] * (1 - t) + terrain.samples[b] * t);
      }
      // --- End terrain helpers ---

      // --- Parallax background images ---
      // Place space_far.png and space_near.png next to this HTML file
      const bgFar = new Image();  bgFar.src = 'space_far.png';   // subtle stars
      const bgNear = new Image(); bgNear.src = 'space_near.png'; // denser stars + nebula

      // Tile an image across the canvas with an offset (no global translate)
      function tileLayer(img, offX, offY) {
        if (!img.complete) return; // skip until loaded
        const iw = img.width, ih = img.height;
        // Normalize offsets to [-iw, 0) and [-ih, 0)
        let x0 = ((offX % iw) + iw) % iw - iw;
        let y0 = ((offY % ih) + ih) % ih - ih;
        // Keep pixel art crisp
        const prev = ctx.imageSmoothingEnabled;
        ctx.imageSmoothingEnabled = false;
        for (let x = x0; x < width; x += iw) {
          for (let y = y0; y < height; y += ih) {
            ctx.drawImage(img, x, y);
          }
        }
        ctx.imageSmoothingEnabled = prev;
      }
      // --- End parallax helpers ---

      // Game state
      const lander = {
        x: width / 2,
        y: 50,
        vx: 0,
        vy: 0,
        angle: 0, // in radians
        // angular velocity accumulates when rotating; in radians per ms
        angularVelocity: 0,
        // rotational acceleration applied when pressing left/right; in radians per ms^2
        rotateAccel: 0.00001,
        // damping factor applied every frame to gradually slow rotation
        rotateDamping: 0.99,
        fuel: 100,
        width: 20,
        height: 30,
        thrustPower: 0.0007,
        // rotateSpeed is no longer used; we keep it commented for reference
        // rotateSpeed: 0.04,
      };
      lander.legLength = 10;
      lander.legAttachOffset = lander.width / 4;
      lander.legFootOffset = lander.width / 2;

let g = 0.00026; // gravity (tunable, slightly lower)
      let lastTime = null;
      let keys = {};
let gameOver = false;
let message = '';
let exploded = false;
let debris = []; // explosion pieces
let landed = false; // success state
let winFx = []; // celebration particles
let padFlash = 0; // ms of pad glow remaining
let shouldRegen = false; // regenerate terrain only after a successful landing
let padPulsePhase = 0;
let padGlowAlpha = 0.525;
let smoke = []; // engine dust/smoke particles near ground
let blastSmoke = []; // post-explosion embers smoke
let wreckFlames = []; // persistent burning wreckage
let bombs = []; // active bombs dropped by the lander
let bombCooldown = 0; // ms remaining until next bomb can be dropped

let camX = null; let camY = null;

      function getLanderContactPoints() {
        const cos = Math.cos(lander.angle);
        const sin = Math.sin(lander.angle);
        const localPoints = [
          { type: 'body', lx: 0, ly: lander.height / 2 },
          { type: 'body', lx: -lander.legAttachOffset, ly: lander.height / 2 },
          { type: 'body', lx: lander.legAttachOffset, ly: lander.height / 2 },
          { type: 'foot', lx: -lander.legFootOffset, ly: lander.height / 2 + lander.legLength },
          { type: 'foot', lx: lander.legFootOffset, ly: lander.height / 2 + lander.legLength },
        ];
        return localPoints.map(pt => {
          const x = lander.x + pt.lx * cos - pt.ly * sin;
          const y = lander.y + pt.lx * sin + pt.ly * cos;
          return { ...pt, x, y };
        });
      }

      function canDropBomb() {
        if (gameOver || landed) return false;
        if (bombCooldown > 0) return false;
        if (bombs.length >= BOMB_MAX_ACTIVE) return false;
        return true;
      }

      function dropBomb() {
        if (!canDropBomb()) return;
        bombCooldown = BOMB_DROP_COOLDOWN;
        const cos = Math.cos(lander.angle);
        const sin = Math.sin(lander.angle);
        const baseOffset = lander.height / 2 + 6;
        const dropX = lander.x + sin * baseOffset;
        const dropY = lander.y + cos * baseOffset + 4;
        const inheritVx = lander.vx;
        const inheritVy = lander.vy;
        const bomb = {
          x: dropX,
          y: dropY,
          vx: inheritVx + sin * 0.006,
          vy: inheritVy + Math.max(0.012, cos * 0.006) + 0.01,
          fuseMs: BOMB_FUSE_MS,
          armingMs: BOMB_ARM_DELAY,
          blinkPhase: 0,
          blinkRate: BOMB_BLINK_BASE,
          lastFuseRatio: 1,
          radius: 7,
          grounded: false,
          detonated: false,
        };
        bombs.push(bomb);
      }

      const audio = (() => {
        const AudioCtx = window.AudioContext || window.webkitAudioContext;
        const levels = {
          master: 0.4,
          thruster: 0.27,
          explosion: 0.9,
          death: 0.3,
          win: 0.28,
        };
        const state = {
          ctx: null,
          master: null,
          unlocked: false,
          thruster: {
            osc: null,
            gain: null,
            noiseGain: null,
            filter: null,
            active: false,
          },
        };

        function ensureContext() {
          if (!AudioCtx) return null;
          if (!state.ctx) {
            state.ctx = new AudioCtx();
            state.master = state.ctx.createGain();
            state.master.gain.value = levels.master;
            state.master.connect(state.ctx.destination);
          }
          return state.ctx;
        }

        function createNoiseBuffer(ctx) {
          const buffer = ctx.createBuffer(1, ctx.sampleRate, ctx.sampleRate);
          const data = buffer.getChannelData(0);
          for (let i = 0; i < data.length; i++) {
            data[i] = Math.random() * 2 - 1;
          }
          return buffer;
        }

        function ensureThruster() {
          const ctx = ensureContext();
          if (!ctx) return null;
          if (!state.thruster.osc) {
            const mainOsc = ctx.createOscillator();
            mainOsc.type = 'sawtooth';
            const harmOsc = ctx.createOscillator();
            harmOsc.type = 'square';

            const filter = ctx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 1600;
            filter.Q.value = 0.7;

            const bodyGain = ctx.createGain();
            bodyGain.gain.value = 0;

            const noise = ctx.createBufferSource();
            noise.buffer = createNoiseBuffer(ctx);
            noise.loop = true;

            const noiseFilter = ctx.createBiquadFilter();
            noiseFilter.type = 'highpass';
            noiseFilter.frequency.value = 2200;
            noiseFilter.Q.value = 0.9;

            const noiseGain = ctx.createGain();
            noiseGain.gain.value = 0;

            mainOsc.connect(filter);
            harmOsc.connect(filter);
            filter.connect(bodyGain);
            bodyGain.connect(state.master);

            noise.connect(noiseFilter);
            noiseFilter.connect(noiseGain);
            noiseGain.connect(state.master);

            mainOsc.start();
            harmOsc.start();
            noise.start();

            state.thruster.osc = mainOsc;
            state.thruster.harm = harmOsc;
            state.thruster.noise = noise;
            state.thruster.noiseFilter = noiseFilter;
            state.thruster.filter = filter;
            state.thruster.gain = bodyGain;
            state.thruster.noiseGain = noiseGain;
          }
          return state.thruster;
        }

        function rampGain(gainNode, target, timeConstant) {
          const ctx = state.ctx;
          if (!ctx) return;
          const now = ctx.currentTime;
          gainNode.gain.cancelScheduledValues(now);
          gainNode.gain.setTargetAtTime(target, now, timeConstant);
        }

        function playNoiseBurst(duration, frequency, q, startGain, endTime) {
          const ctx = ensureContext();
          if (!ctx) return;
          const length = Math.max(0.05, duration);
          const buffer = ctx.createBuffer(1, Math.floor(ctx.sampleRate * length), ctx.sampleRate);
          const data = buffer.getChannelData(0);
          for (let i = 0; i < data.length; i++) {
            const t = i / data.length;
            const envelope = Math.pow(1 - t, 2);
            data[i] = (Math.random() * 2 - 1) * envelope;
          }
          const source = ctx.createBufferSource();
          source.buffer = buffer;
          source.playbackRate.value = 1;
          const filter = ctx.createBiquadFilter();
          filter.type = 'bandpass';
          filter.frequency.value = frequency;
          filter.Q.value = q;
          const gain = ctx.createGain();
          gain.gain.setValueAtTime(startGain, ctx.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + endTime);
          source.connect(filter);
          filter.connect(gain);
          gain.connect(state.master);
          source.start();
          source.stop(ctx.currentTime + endTime);
        }

        return {
          unlock() {
            const ctx = ensureContext();
            if (!ctx || state.unlocked) return;
            if (ctx.state === 'suspended') {
              ctx.resume();
            }
            state.unlocked = true;
          },
          setThrusterActive(on) {
            const thruster = ensureThruster();
            if (!thruster) return;
            if (state.ctx.state === 'suspended') return;
            if (thruster.active === on) return;
            const targetBody = on ? levels.thruster : 0.0001;
            const targetNoise = on ? levels.thruster * 0.75 : 0.0001;
            rampGain(thruster.gain, targetBody, on ? 0.07 : 0.08);
            if (thruster.noiseGain) {
              rampGain(thruster.noiseGain, targetNoise, on ? 0.12 : 0.09);
            }
            if (on) {
              const now = state.ctx.currentTime;
              const baseFreq = 260 + Math.random() * 30;
              const jitter = (Math.random() - 0.5) * 25;
              thruster.osc.frequency.setTargetAtTime(baseFreq + jitter, now, 0.18);
              thruster.harm.frequency.setTargetAtTime((baseFreq * 1.95) + jitter * 0.5, now, 0.18);
              thruster.osc.detune.setTargetAtTime((Math.random() - 0.5) * 70, now, 0.35);
              thruster.harm.detune.setTargetAtTime((Math.random() - 0.5) * 45, now, 0.3);
              thruster.filter.frequency.setTargetAtTime(2200 + Math.random() * 600, now, 0.28);
              if (thruster.filter.Q) {
                thruster.filter.Q.cancelScheduledValues(now);
                thruster.filter.Q.setTargetAtTime(0.8 + Math.random() * 0.25, now, 0.3);
              }
              thruster.noiseFilter.frequency.setTargetAtTime(3200 + Math.random() * 900, now, 0.3);
              if (thruster.noiseFilter.Q) {
                thruster.noiseFilter.Q.cancelScheduledValues(now);
                thruster.noiseFilter.Q.setTargetAtTime(0.9 + Math.random() * 0.4, now, 0.25);
              }
            }
            thruster.active = on;
          },
          stopThrusterImmediate() {
            if (!state.thruster.gain) return;
            const ctx = state.ctx;
            if (!ctx) return;
            const now = ctx.currentTime;
            state.thruster.gain.gain.cancelScheduledValues(now);
            state.thruster.gain.gain.setValueAtTime(0.0001, now);
            if (state.thruster.noiseGain) {
              state.thruster.noiseGain.gain.cancelScheduledValues(now);
              state.thruster.noiseGain.gain.setValueAtTime(0.0001, now);
            }
            state.thruster.active = false;
          },
          playExplosion() {
            const ctx = ensureContext();
            if (!ctx) return;
            if (ctx.state === 'suspended') return;
            playNoiseBurst(0.8, 180, 0.8, levels.explosion, 0.8);
            const boomOsc = ctx.createOscillator();
            boomOsc.type = 'sine';
            const boomGain = ctx.createGain();
            const now = ctx.currentTime;
            boomOsc.frequency.setValueAtTime(90, now);
            boomOsc.frequency.exponentialRampToValueAtTime(35, now + 0.8);
            boomGain.gain.setValueAtTime(levels.explosion * 0.6, now);
            boomGain.gain.exponentialRampToValueAtTime(0.0001, now + 0.9);
            boomOsc.connect(boomGain);
            boomGain.connect(state.master);
            boomOsc.start(now);
            boomOsc.stop(now + 1);
          },
          playDeathTone() {
            const ctx = ensureContext();
            if (!ctx) return;
            if (ctx.state === 'suspended') return;
            const osc = ctx.createOscillator();
            osc.type = 'triangle';
            const gain = ctx.createGain();
            const now = ctx.currentTime + 0.15;
            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(levels.death, now + 0.1);
            gain.gain.exponentialRampToValueAtTime(0.0001, now + 1.2);
            osc.frequency.setValueAtTime(320, now);
            osc.frequency.linearRampToValueAtTime(90, now + 0.9);
            osc.connect(gain);
            gain.connect(state.master);
            osc.start(now);
            osc.stop(now + 1.3);
          },
          playWinChime() {
            const ctx = ensureContext();
            if (!ctx) return;
            if (ctx.state === 'suspended') return;
            const notes = [523.25, 659.25, 784, 1046.5];
            const now = ctx.currentTime;
            notes.forEach((freq, i) => {
              const osc = ctx.createOscillator();
              osc.type = 'sine';
              const gain = ctx.createGain();
              const start = now + i * 0.08;
              osc.frequency.setValueAtTime(freq, start);
              gain.gain.setValueAtTime(0, start);
              gain.gain.linearRampToValueAtTime(levels.win, start + 0.05);
              gain.gain.exponentialRampToValueAtTime(0.0001, start + 0.45);
              osc.connect(gain);
              gain.connect(state.master);
              osc.start(start);
              osc.stop(start + 0.5);
            });
          },
          reset() {
            this.stopThrusterImmediate();
          },
        };
      })();

      // Live-tunable parameters and debug
      const tune = {
        camLag: 0.004,      // smoothing factor: k = min(1, dt*camLag)
        lookGainX: 120,     // px per (vx) for look-ahead
        lookGainY: 80,      // px per (vy)
        lookCap: 80,        // max look-ahead in px
        parallaxFar: 0.08,
        parallaxNear: 0.18,
        bounce: 0.35,
        friction: 0.78,
      };
      
      // Debug overlay is off by default
      let showDebug = false;

      // Store keys by their .key value and handle immediate restart on R
      window.addEventListener('keydown', (e) => {
        audio.unlock();
        const key = e.key === 'Spacebar' ? ' ' : e.key;
        if (key === ' ' || key === 'Space') {
          e.preventDefault();
        }
        keys[key] = true;
        if (key === ' ' || key === 'Space') {
          if (!e.repeat) {
            keys.Space = true;
            if (typeof canDropBomb === 'function' && canDropBomb()) {
              dropBomb();
            }
          }
          return;
        }
        if (key === 'r' || key === 'R') {
          e.preventDefault();
          resetGame(true);
        }
        // --- Tuning keys ---
        const step = (v, s, min, max) => Math.max(min, Math.min(max, v + s));
        switch (key) {
          case 'h': case 'H': showDebug = !showDebug; break;
          case 'q': tune.camLag = step(tune.camLag,  0.001, 0.0005, 0.02); break;
          case 'a': tune.camLag = step(tune.camLag, -0.001, 0.0005, 0.02); break;
          case 'w': tune.lookGainX = step(tune.lookGainX,  10, 0, 600); break;
          case 's': tune.lookGainX = step(tune.lookGainX, -10, 0, 600); break;
          case 'e': tune.lookGainY = step(tune.lookGainY,  10, 0, 600); break;
          case 'd': tune.lookGainY = step(tune.lookGainY, -10, 0, 600); break;
          case 'r': tune.lookCap   = step(tune.lookCap,    5, 0, 200); break;
          case 'f': tune.lookCap   = step(tune.lookCap,   -5, 0, 200); break;
          case 't': tune.parallaxFar  = step(tune.parallaxFar,  0.01, 0, 1); break;
          case 'g': tune.parallaxFar  = step(tune.parallaxFar, -0.01, 0, 1); break;
          case 'y': tune.parallaxNear = step(tune.parallaxNear, 0.01, 0, 1); break;
          case 'x': tune.parallaxNear = step(tune.parallaxNear,-0.01, 0, 1); break;
          case 'u': lander.thrustPower = step(lander.thrustPower,  0.0001, 0, 0.005); break;
          case 'j': lander.thrustPower = step(lander.thrustPower, -0.0001, 0, 0.005); break;
          case 'i': lander.rotateAccel = step(lander.rotateAccel,  0.0000002, 0, 0.00002); break;
          case 'k': lander.rotateAccel = step(lander.rotateAccel, -0.0000002, 0, 0.00002); break;
          case 'o': lander.rotateDamping = step(lander.rotateDamping,  0.01, 0.80, 1.00); break;
          case 'l': lander.rotateDamping = step(lander.rotateDamping, -0.01, 0.80, 1.00); break;
          case 'p': g = step(g,  0.00005, 0, 0.005); break;
          case ';': g = step(g, -0.00005, 0, 0.005); break;
          case 'b': tune.bounce = step(tune.bounce,  0.05, 0, 1); break;
          case 'n': tune.bounce = step(tune.bounce, -0.05, 0, 1); break;
          case 'm': tune.friction = step(tune.friction,  0.05, 0, 1); break;
          case ',': tune.friction = step(tune.friction, -0.05, 0, 1); break;
        }
      });
      window.addEventListener('keyup', (e) => {
        const key = e.key === 'Spacebar' ? ' ' : e.key;
        if (key === ' ' || key === 'Space') {
          e.preventDefault();
          keys.Space = false;
        }
        keys[key] = false;
      });
      window.addEventListener('mousedown', () => audio.unlock());
      window.addEventListener('touchstart', () => audio.unlock(), { passive: true });

      function resetGame(forceTerrain = false) {
        if (forceTerrain || shouldRegen) {
          const regenIndex = shouldRegen ? nextLevelIndex : currentLevelIndex;
          generateTerrain(regenIndex);
          shouldRegen = false;
        }
        const level = levels[currentLevelIndex];
        const startBuffer = 140;
        lander.x = Math.min(level.worldWidth * 0.08, level.worldWidth - startBuffer);
        lander.y = 50;
        lander.vx = 0;
        lander.vy = 0;
        lander.angle = 0;
        lander.angularVelocity = 0;
        lander.fuel = 100;
        gameOver = false;
        message = '';
        exploded = false;
        debris = [];
        landed = false;
        winFx = [];
        padFlash = 0;
        smoke = [];
        blastSmoke = [];
        wreckFlames = [];
        bombs = [];
        bombCooldown = 0;
        audio.reset();
        // reset camera to new terrain context
        camX = lander.x;
        camY = lander.y;
      }

      function spawnExplosion(x, y, baseVx, baseVy) {
        if (exploded) return;
        exploded = true;
        gameOver = true;
        message = 'You Crashed! Press R to restart';
        audio.stopThrusterImmediate();
        audio.playExplosion();
        audio.playDeathTone();
        debris = [];

        deformTerrainAt(x, CRASH_CRATER_RADIUS, CRASH_CRATER_DEPTH);
        const craterFloorY = terrainY(x);
        const originY = craterFloorY - 4;
        const pushOut = (speedMin, speedRange) => speedMin + Math.random() * speedRange;
        const randomUpVector = (jitter = 0.25) => {
          const angle = (Math.random() - 0.5) * Math.PI; // -90°..+90° around upward axis
          let dirX = Math.sin(angle);
          let dirY = -Math.cos(angle);
          dirY += (Math.random() - 0.5) * jitter;
          if (dirY > -0.05) dirY = -0.05 - Math.random() * 0.35;
          const mag = Math.hypot(dirX, dirY) || 1;
          return { dirX: dirX / mag, dirY: dirY / mag };
        };

        const coreCount = 1 + (Math.random() * 2 | 0);
        for (let i = 0; i < coreCount; i++) {
          const radius = 48 + Math.random() * 20;
          const life = 1600 + Math.random() * 900;
          const dir = randomUpVector(0.18);
          const speed = pushOut(0.32, 0.36);
          debris.push({
            x,
            y: originY,
            vx: baseVx * 0.25 + dir.dirX * speed,
            vy: baseVy * 0.18 + dir.dirY * speed,
            radius,
            radiusStart: radius,
            life,
            lifeStart: life,
            glowBias: 1.2,
            kind: 'core',
          });
        }

        const shardCount = 46 + Math.floor(Math.random() * 24);
        for (let i = 0; i < shardCount; i++) {
          const dir = randomUpVector(0.32);
          const speed = pushOut(0.22, 0.42);
          const radius = 12 + Math.random() * 12;
          const life = 1200 + Math.random() * 880;
          debris.push({
            x,
            y: originY,
            vx: baseVx * 0.25 + dir.dirX * speed,
            vy: baseVy * 0.18 + dir.dirY * speed,
            radius,
            radiusStart: radius,
            life,
            lifeStart: life,
            glowBias: 0.85 + Math.random() * 0.4,
            kind: 'shard',
          });
        }

        const emberCount = 28 + Math.floor(Math.random() * 18);
        for (let i = 0; i < emberCount; i++) {
          const dir = randomUpVector(0.42);
          const speed = pushOut(0.14, 0.3);
          const radius = 6 + Math.random() * 6;
          const life = 900 + Math.random() * 660;
          debris.push({
            x,
            y: originY,
            vx: baseVx * 0.25 + dir.dirX * speed,
            vy: baseVy * 0.18 + dir.dirY * speed,
            radius,
            radiusStart: radius,
            life,
            lifeStart: life,
            glowBias: 0.6 + Math.random() * 0.3,
            kind: 'ember',
          });
        }

        const smokeCount = 34 + Math.floor(Math.random() * 22);
        for (let i = 0; i < smokeCount; i++) {
          const spread = (Math.random() - 0.5) * 120;
          const spawnX = Math.max(0, Math.min(terrain.width, x + spread));
          const groundY = terrainY(spawnX);
          const radius = 18 + Math.random() * 18;
          const life = 2200 + Math.random() * 1800;
          const rise = 0.012 + Math.random() * 0.018;
          const bias = Math.random() * 0.55 + 0.65;
          blastSmoke.push({
            x: spawnX,
            y: groundY - radius * bias,
            vx: baseVx * 0.22 + (Math.random() - 0.5) * 0.12,
            vy: -rise,
            radius,
            radiusStart: radius,
            life,
            lifeStart: life,
            heat: 0.75 + Math.random() * 0.35,
            source: 'blast',
          });
        }

        const wreckCount = 3 + (Math.random() * 3 | 0);
        for (let i = 0; i < wreckCount; i++) {
          const spread = (Math.random() - 0.5) * 50;
          const px = Math.max(0, Math.min(terrain.width, x + spread));
          const gy = terrainY(px);
          const baseRadius = 14 + Math.random() * 12;
          wreckFlames.push({
            x: px,
            y: gy - baseRadius * (0.52 + Math.random() * 0.16),
            radius: baseRadius,
            heat: 0.9 + Math.random() * 0.15,
            pulse: Math.random() * Math.PI * 2,
            flicker: Math.random() * 0.4,
            smokeTimer: 120 + Math.random() * 200,
          });
        }
        if (wreckFlames.length > 12) {
          wreckFlames.splice(0, wreckFlames.length - 12);
        }

        applyExplosionEffects(x, craterFloorY);
      }

      function updateDebris(dt) {
        const BOUNCE = tune.bounce;
        const FRIC = tune.friction;
        for (const p of debris) {
          p.life -= dt;
          if (p.life <= 0) continue;

          const lifeRatio = Math.max(0, p.life / p.lifeStart);
          const shrinkCurve = p.kind === 'core' ? 0.52 : p.kind === 'shard' ? 0.7 : 0.82;
          const scale = 0.35 + 0.65 * Math.pow(lifeRatio, shrinkCurve);
          p.radius = p.radiusStart * scale;

          // physics
          const driftDamp = p.kind === 'ember' ? 0.993 : 0.997;
          p.vy += g * dt;
          p.vx *= driftDamp;
          p.x += p.vx * dt;
          p.y += p.vy * dt;

          // ground collision against terrain profile
          const gy = terrainY(p.x);
          if (p.y + p.radius >= gy) {
            p.y = gy - p.radius;
            p.vy = -Math.abs(p.vy) * (0.35 + BOUNCE * 0.65);
            p.vx *= FRIC;
          }
          // side walls (optional, keep pieces on screen)
          if (p.x < 0) { p.x = 0; p.vx = Math.abs(p.vx) * BOUNCE; }
          if (p.x > terrain.width) { p.x = terrain.width; p.vx = -Math.abs(p.vx) * BOUNCE; }
        }
        // trim dead
        debris = debris.filter(p => p.life > 0.0 && p.radius > 0.4);
      }

      function clamp01(v) {
        return v < 0 ? 0 : v > 1 ? 1 : v;
      }

      function heatColor(t, glowBias) {
        const mix = Math.pow(clamp01(t), 0.65);
        const flare = (1 - mix) * glowBias;
        const g = 244 - mix * 170 + flare * 28;
        const b = 195 - Math.pow(mix, 1.15) * 160 + flare * 12;
        return {
          r: 255,
          g: Math.max(0, Math.min(255, Math.round(g))),
          b: Math.max(0, Math.min(255, Math.round(b))),
        };
      }

      function updateBlastSmoke(dt) {
        for (const p of blastSmoke) {
          p.life -= dt;
          if (p.life <= 0) continue;
          const lifeRatio = Math.max(0, p.life / p.lifeStart);
          const growthBase = p.source === 'wreck' ? 1.35 : 1.1;
          const growth = 1 + (1 - lifeRatio) * growthBase;
          p.radius = p.radiusStart * growth;
          const buoyancy = p.source === 'wreck' ? -g * 0.28 : g * 0.07;
          p.vy += buoyancy * dt;
          if (p.source === 'wreck') {
            if (p.vy > -0.008) p.vy = -0.008;
            if (p.vy < -0.08) p.vy = -0.08;
            p.vx *= 0.9985;
          } else {
            if (p.vy < -0.035) p.vy = -0.035;
            p.vx *= 0.997;
          }
          p.x += p.vx * dt;
          p.y += p.vy * dt;
          const gy = terrainY(p.x);
          if (p.y + p.radius >= gy) {
            p.y = gy - p.radius;
            p.vy *= -0.1;
            p.vx *= 0.88;
          }
        }
        blastSmoke = blastSmoke.filter(p => p.life > 0 && p.radius > 0.5);
      }

      function updateWreckFlames(dt) {
        if (wreckFlames.length === 0) return;
        const seconds = dt / 1000;
        for (const f of wreckFlames) {
          f.pulse += seconds * (2.1 + Math.random() * 0.9);
          const flickerTarget = 0.35 + Math.random() * 0.4;
          f.flicker += (flickerTarget - f.flicker) * 0.16;
          const heatTarget = 0.72 + Math.random() * 0.2;
          f.heat += (heatTarget - f.heat) * 0.05;
          f.smokeTimer -= dt;
          if (f.smokeTimer <= 0) {
            const radius = 14 + Math.random() * 12;
            const life = 5200 + Math.random() * 2800;
            blastSmoke.push({
              x: f.x + (Math.random() - 0.5) * 6,
              y: f.y - f.radius * 0.35,
              vx: (Math.random() - 0.5) * 0.05,
              vy: -0.009 - Math.random() * 0.009,
              radius,
              radiusStart: radius,
              life,
              lifeStart: life,
              heat: 0.52 + Math.random() * 0.24,
              source: 'wreck',
            });
            f.smokeTimer = 360 + Math.random() * 440;
          }
        }
      }

      function drawDebris() {
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        for (const p of debris) {
          if (p.life <= 0 || p.radius <= 0.4) continue;
          const progress = 1 - clamp01(p.life / p.lifeStart);
          const { r, g, b } = heatColor(progress, p.glowBias);
          const alpha = Math.min(1, 0.85 * (1 - progress * 0.35) * p.glowBias);
          const glowRadius = p.radius * (p.kind === 'core' ? 1.9 : 1.35);
          const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, glowRadius);
          gradient.addColorStop(0, `rgba(${r},${g},${b},${alpha})`);
          gradient.addColorStop(0.35, `rgba(${r},${g},${b},${alpha * 0.7})`);
          gradient.addColorStop(1, `rgba(${r},${g},${b},0)`);
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(p.x, p.y, glowRadius, 0, Math.PI * 2);
          ctx.fill();

          const coreRadius = Math.max(1.5, p.radius * 0.52);
          const coreAlpha = Math.min(1, alpha * 1.08);
          ctx.fillStyle = `rgba(255,${Math.round(Math.min(255, g + 20))},${Math.round(Math.min(255, b + 40))},${coreAlpha})`;
          ctx.beginPath();
          ctx.arc(p.x, p.y, coreRadius, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.restore();
      }

      function drawBlastSmoke() {
        if (blastSmoke.length === 0) return;
        ctx.save();
        ctx.globalCompositeOperation = 'source-over';
        for (const p of blastSmoke) {
          if (p.life <= 0) continue;
          const lifeRatio = clamp01(p.life / p.lifeStart);
          const expo = p.source === 'wreck' ? 0.58 : 0.75;
          const heat = Math.pow(lifeRatio, expo);
          const r = Math.max(0, Math.min(255, Math.round(118 * heat * p.heat)));
          const g = Math.max(0, Math.min(255, Math.round(48 * heat * (p.source === 'wreck' ? 0.9 : 0.7))));
          const b = Math.max(0, Math.min(255, Math.round(44 * heat * (p.source === 'wreck' ? 0.75 : 0.6))));
          const alphaBase = p.source === 'wreck' ? 0.32 : 0.28;
          const centerAlpha = Math.min(0.88, alphaBase + 0.72 * Math.pow(lifeRatio, 0.5) * p.heat);
          const midAlpha = centerAlpha * 0.68;
          const radius = p.radius * (1.0 + (1 - lifeRatio) * (p.source === 'wreck' ? 0.55 : 0.42));
          const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, radius);
          gradient.addColorStop(0, `rgba(${r},${g},${b},${centerAlpha})`);
          gradient.addColorStop(0.45, `rgba(${r},${g},${b},${midAlpha})`);
          gradient.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.restore();
      }

      function drawWreckFlames() {
        if (wreckFlames.length === 0) return;
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        for (const f of wreckFlames) {
          const pulse = Math.sin(f.pulse) * 0.5 + 0.5;
          const flameRadius = f.radius * (0.78 + pulse * 0.5 + f.flicker * 0.15);
          const flameHeat = Math.min(1, f.heat + pulse * 0.2);
          const r = 255;
          const g = Math.round(210 * flameHeat + 40 * (1 - flameHeat));
          const b = Math.round(120 * (1 - flameHeat * 0.8));
          const alphaCore = 0.82 * (0.7 + pulse * 0.3);
          const alphaEdge = alphaCore * 0.55;
          const gradient = ctx.createRadialGradient(f.x, f.y, 0, f.x, f.y, flameRadius);
          gradient.addColorStop(0, `rgba(${r},${g},${b},${alphaCore})`);
          gradient.addColorStop(0.55, `rgba(${r},${g},${b},${alphaEdge})`);
          gradient.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(f.x, f.y, flameRadius, 0, Math.PI * 2);
          ctx.fill();

          const coalRadius = Math.max(4, f.radius * 0.45);
          ctx.fillStyle = `rgba(90,40,25,0.55)`;
          ctx.beginPath();
          ctx.arc(f.x, f.y + coalRadius * 0.4, coalRadius, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.restore();
      }

      // Celebration particles (confetti)
      function spawnWinFx(x, y) {
        winFx = [];
        const COUNT = 80;
        const colors = ['#ffd166', '#06d6a0', '#118ab2', '#ef476f', '#ffffff'];
        for (let i = 0; i < COUNT; i++) {
          const a = Math.random() * Math.PI * 2;
          const sp = 0.03 + Math.random() * 0.18;
          winFx.push({
            x, y,
            vx: Math.cos(a) * sp,
            vy: -0.05 - Math.random() * 0.20, // kick upward
            ang: Math.random() * Math.PI * 2,
            angVel: (Math.random() - 0.5) * 0.02,
            size: 3 + (Math.random() * 3 | 0),
            life: 1200 + Math.random() * 1200,
            color: colors[i % colors.length],
          });
        }
      }

      function updateWinFx(dt) {
        for (const p of winFx) {
          p.life -= dt;
          if (p.life <= 0) continue;
          // lighter gravity for confetti
          p.vy += (g * 0.6) * dt;
          p.x += p.vx * dt;
          p.y += p.vy * dt;
          p.ang += p.angVel * dt;
          // bounce on ground lightly
          const gy = terrainY(p.x);
          if (p.y + p.size >= gy) {
            p.y = gy - p.size;
            p.vy = -Math.abs(p.vy) * 0.25;
            p.vx *= 0.9;
          }
        }
        winFx = winFx.filter(p => p.life > 0);
      }

      function drawWinFx() {
        if (winFx.length === 0) return;
        ctx.save();
        for (const p of winFx) {
          ctx.save();
          ctx.translate(p.x, p.y);
          ctx.rotate(p.ang);
          ctx.fillStyle = p.color;
          ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size);
          ctx.restore();
        }
        ctx.restore();
      }

      function updateBombs(dt) {
        if (bombCooldown > 0) {
          bombCooldown -= dt;
          if (bombCooldown < 0) bombCooldown = 0;
        }
        if (bombs.length === 0) return;
        const airDrag = 0.9985;
        const groundDrag = 0.94;
        for (const bomb of bombs) {
          if (bomb.detonated) continue;
          bomb.armingMs = Math.max(0, bomb.armingMs - dt);
          bomb.fuseMs -= dt;
          const fuseRatio = Math.max(0, bomb.fuseMs / BOMB_FUSE_MS);
          bomb.lastFuseRatio = fuseRatio;
          bomb.blinkRate = BOMB_BLINK_BASE + BOMB_BLINK_ACCEL * (1 - fuseRatio);
          bomb.blinkPhase += bomb.blinkRate * dt;
          if (bomb.fuseMs <= 0) {
            explodeBomb(bomb);
            continue;
          }
          if (!bomb.grounded) {
            bomb.vy += g * dt;
            bomb.vx *= airDrag;
            bomb.vy *= 0.999;
          } else {
            bomb.vx *= groundDrag;
            if (Math.abs(bomb.vx) < 0.00001) bomb.vx = 0;
          }
          bomb.x += bomb.vx * dt;
          bomb.y += bomb.vy * dt;
          if (bomb.x < 0) {
            bomb.x = 0;
            bomb.vx = Math.abs(bomb.vx) * 0.35;
          }
          if (bomb.x > terrain.width) {
            bomb.x = terrain.width;
            bomb.vx = -Math.abs(bomb.vx) * 0.35;
          }
          const groundY = terrainY(bomb.x);
          const radius = bomb.radius;
          if (bomb.y + radius >= groundY) {
            bomb.y = groundY - radius;
            if (bomb.vy > 0) bomb.vy = 0;
            bomb.grounded = true;
          } else if (bomb.grounded && bomb.y + radius < groundY - 1) {
            bomb.grounded = false;
          }
        }
        bombs = bombs.filter(b => !b.detonated);
      }

      function drawBombs() {
        if (bombs.length === 0) return;
        ctx.save();
        for (const bomb of bombs) {
          if (bomb.detonated) continue;
          const fuseRatio = clamp01(bomb.lastFuseRatio ?? 1);
          const heat = 1 - fuseRatio;
          const pulse = Math.sin(bomb.blinkPhase);
          const coreRadius = bomb.radius;
          const haloRadius = coreRadius * (1.6 + heat * 0.9 + Math.max(0, pulse) * 0.4);
          const halo = ctx.createRadialGradient(bomb.x, bomb.y, 0, bomb.x, bomb.y, haloRadius);
          const innerAlpha = Math.min(1, 0.35 + heat * 0.45 + Math.max(0, pulse) * 0.3);
          const midAlpha = innerAlpha * 0.55;
          halo.addColorStop(0, `rgba(255, ${Math.round(150 + heat * 100)}, ${Math.round(70 + heat * 70)}, ${innerAlpha})`);
          halo.addColorStop(0.55, `rgba(255, ${Math.round(110 + heat * 70)}, ${Math.round(40 + heat * 60)}, ${midAlpha})`);
          halo.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.fillStyle = halo;
          ctx.beginPath();
          ctx.arc(bomb.x, bomb.y, haloRadius, 0, Math.PI * 2);
          ctx.fill();

          ctx.fillStyle = pulse > 0 ? '#ffe27a' : '#ff744a';
          ctx.beginPath();
          ctx.arc(bomb.x, bomb.y, coreRadius, 0, Math.PI * 2);
          ctx.fill();

          ctx.strokeStyle = '#311f33';
          ctx.lineWidth = 1.2;
          ctx.beginPath();
          ctx.arc(bomb.x, bomb.y, coreRadius, 0, Math.PI * 2);
          ctx.stroke();
        }
        ctx.restore();
      }

      function checkLanderExplosion(x, y) {
        if (exploded || gameOver) return;
        const dx = lander.x - x;
        const dy = lander.y - y;
        if (dx * dx + dy * dy <= EXPLOSION_KILL_RADIUS * EXPLOSION_KILL_RADIUS) {
          spawnExplosion(lander.x, lander.y, lander.vx, lander.vy);
        }
      }

      function applyExplosionEffects(x, y, sourceBomb = null) {
        if (bombs.length > 0) {
          const chainRadiusSq = BOMB_CHAIN_RADIUS * BOMB_CHAIN_RADIUS;
          for (const other of bombs) {
            if (other === sourceBomb) continue;
            if (!other || other.detonated) continue;
            if (other.armingMs > 0) continue;
            const dx = other.x - x;
            const dy = other.y - y;
            if (dx * dx + dy * dy <= chainRadiusSq) {
              explodeBomb(other);
            }
          }
        }
        checkLanderExplosion(x, y);
      }

      function explodeBomb(bomb) {
        if (!bomb || bomb.detonated) return;
        bomb.detonated = true;
        bomb.fuseMs = 0;
        const x = bomb.x;
        const y = bomb.y;
        if (audio && typeof audio.playExplosion === 'function') {
          audio.playExplosion();
        }

        const shardCount = 18 + (Math.random() * 10 | 0);
        for (let i = 0; i < shardCount; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = 0.14 + Math.random() * 0.22;
          const radius = 6 + Math.random() * 6;
          const life = 900 + Math.random() * 900;
          debris.push({
            x,
            y,
            vx: lander.vx * 0.15 + Math.cos(angle) * speed,
            vy: lander.vy * 0.12 + Math.sin(angle) * speed - 0.02,
            radius,
            radiusStart: radius,
            life,
            lifeStart: life,
            glowBias: 0.85 + Math.random() * 0.4,
            kind: 'shard',
          });
        }

        const emberCount = 12 + (Math.random() * 8 | 0);
        for (let i = 0; i < emberCount; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = 0.10 + Math.random() * 0.18;
          const radius = 4 + Math.random() * 4;
          const life = 800 + Math.random() * 600;
          debris.push({
            x,
            y,
            vx: lander.vx * 0.1 + Math.cos(angle) * speed * 0.75,
            vy: lander.vy * 0.1 + Math.sin(angle) * speed * 0.75 - 0.01,
            radius,
            radiusStart: radius,
            life,
            lifeStart: life,
            glowBias: 0.6 + Math.random() * 0.25,
            kind: 'ember',
          });
        }

        const smokeCount = 20 + (Math.random() * 12 | 0);
        for (let i = 0; i < smokeCount; i++) {
          const spread = (Math.random() - 0.5) * BOMB_MAX_RADIUS * 1.2;
          const spawnX = Math.max(0, Math.min(terrain.width, x + spread));
          const groundY = terrainY(spawnX);
          const radius = 14 + Math.random() * 16;
          const life = 1700 + Math.random() * 1400;
          blastSmoke.push({
            x: spawnX,
            y: groundY - radius * (0.55 + Math.random() * 0.25),
            vx: (Math.random() - 0.5) * 0.08,
            vy: -0.02 - Math.random() * 0.02,
            radius,
            radiusStart: radius,
            life,
            lifeStart: life,
            heat: 0.75 + Math.random() * 0.35,
            source: 'blast',
          });
        }

        deformTerrainAt(x, BOMB_MAX_RADIUS, BOMB_MAX_DEPTH);
        const blastY = terrainY(x);
        applyExplosionEffects(x, blastY, bomb);
      }

      function deformTerrainAt(x, radius, depth) {
        if (!terrain.samples || terrain.samples.length === 0) return;
        if (radius <= 0 || depth <= 0) return;
        const step = terrain.step;
        const samples = terrain.samples;
        const centerIdx = Math.round(x / step);
        const radiusSamples = Math.ceil(radius / step);
        const start = Math.max(0, centerIdx - radiusSamples - 2);
        const end = Math.min(samples.length - 1, centerIdx + radiusSamples + 2);
        const padStartIdx = Math.floor(pad.x / step);
        const padEndIdx = Math.floor((pad.x + pad.w) / step);

        for (let i = start; i <= end; i++) {
          const sampleX = i * step;
          const dx = sampleX - x;
          const dist = Math.abs(dx);
          if (dist > radius) continue;
          if (i >= padStartIdx && i <= padEndIdx) continue;
          const t = dist / radius;
          const falloff = Math.max(0, 1 - t * t);
          if (falloff <= 0) continue;
          const delta = depth * falloff;
          const newY = samples[i] + delta;
          samples[i] = Math.min(height, newY);
        }

        const smoothIterations = 2;
        for (let iter = 0; iter < smoothIterations; iter++) {
          const snapshot = samples.slice();
          for (let i = start; i <= end; i++) {
            if (i <= 0 || i >= samples.length - 1) continue;
            if (i >= padStartIdx && i <= padEndIdx) continue;
            const neighborAvg = (snapshot[i - 1] + snapshot[i] + snapshot[i + 1]) / 3;
            const blended = snapshot[i] * 0.6 + neighborAvg * 0.4;
            samples[i] = Math.min(height, blended);
          }
        }

        // Keep landing pad aligned to the current terrain profile beneath it
        const padIdxStart = Math.max(0, Math.floor(pad.x / step));
        const padIdxEnd = Math.min(samples.length - 1, Math.floor((pad.x + pad.w) / step));
        let padSurface = samples[padIdxStart];
        for (let i = padIdxStart + 1; i <= padIdxEnd; i++) {
          if (samples[i] < padSurface) padSurface = samples[i];
        }
        pad.y = Math.max(0, Math.min(height - pad.h, padSurface - pad.h));

        // Nudge lander upward if terrain carved out beneath it
        const landerDist = Math.abs(lander.x - x);
        if (landerDist <= radius + lander.width) {
          const contactPoints = getLanderContactPoints();
          let maxPenetration = 0;
          for (const pt of contactPoints) {
            const groundY = terrainY(pt.x);
            const penetration = pt.y - groundY;
            if (penetration > maxPenetration) {
              maxPenetration = penetration;
            }
          }
          if (maxPenetration > 0) {
            const lift = Math.min(BOMB_SELF_PUSH, maxPenetration + 2);
            lander.y -= lift;
            if (lander.vy > 0) lander.vy = 0;
          }
        }
      }

      // --- Engine dust/smoke when close to terrain ---
      function castThrustRay(originX, originY, dirX, dirY, maxDistance) {
        // Ray-march the exhaust downwards until it collides with terrain.
        if (dirY <= 0) return null;
        const clampX = (x) => Math.max(0, Math.min(terrain.width, x));
        const step = Math.max(2, terrain.step * 0.5);
        const maxSteps = Math.ceil(maxDistance / step);
        let traveled = 0;
        let prevX = originX;
        let prevY = originY;
        for (let i = 0; i < maxSteps; i++) {
          const nextX = prevX + dirX * step;
          const nextY = prevY + dirY * step;
          const groundY = terrainY(clampX(nextX));
          if (nextY >= groundY) {
            let lo = 0;
            let hi = 1;
            let hitX = nextX;
            let hitY = groundY;
            for (let j = 0; j < 5; j++) {
              const mid = (lo + hi) / 2;
              const testX = prevX + dirX * step * mid;
              const testY = prevY + dirY * step * mid;
              const testGround = terrainY(clampX(testX));
              if (testY >= testGround) {
                hi = mid;
                hitX = testX;
                hitY = testGround;
              } else {
                lo = mid;
              }
            }
            const hitDistance = traveled + hi * step;
            return { x: clampX(hitX), y: hitY, distance: hitDistance };
          }
          traveled += step;
          prevX = nextX;
          prevY = nextY;
        }
        return null;
      }

      function spawnSmoke(x, y, count, spread, pushUp, prox) { // prox in [0,1] (ADJUST near emission site)
        // TUNING NOTES:
        //  - baseR: starting dust size when far; sizeBoost scales with proximity.
        //  - Increase sizeBoost to make near-ground particles bigger.
        //  - life/maxLife control how long dust lingers.
        // Colors fade from terrain hue toward brighter, lofted dust
        const groundColor = [0x33, 0x2c, 0x4a];
        const highlight = groundColor.map((c, idx) => {
          const lift = [60, 52, 44][idx];
          return Math.min(255, c + lift);
        });
        const warmHighlight = groundColor.map((c, idx) => {
          const lift = [150, 140, 130][idx];
          return Math.min(255, c + lift);
        });
        for (let i = 0; i < count; i++) {
          const a = (Math.random() - 0.5) * Math.PI * 0.6; // lateral cone
          const sp = Math.random() * spread;
          const baseR = 8 + Math.random() * 6;            // broader base dust size range
          const sizeJitter = 0.6 + Math.random() * 1.4;   // vary dust scale per particle
          const sizeBoost = 4 * prox;                     // ADJUST proximity size gain
          const radius = (baseR + sizeBoost) * sizeJitter;
          const spawnX = Math.max(0, Math.min(terrain.width, x + (Math.random() - 0.5) * 12));
          const groundY = terrainY(spawnX);
          const biasDepth = radius * (0.35 + Math.random() * 0.55);
          const surfaceChance = 0.18;
          const buryDepth = Math.random() < surfaceChance ? Math.random() * radius * 0.25 : biasDepth;
          let bottom = groundY + buryDepth;
          bottom += (Math.random() - 0.5) * radius * 0.28;       // jitter contact height slightly while staying beneath
          bottom = Math.max(bottom, groundY);                    // never float above the surface
          bottom = Math.min(bottom, groundY + radius * 1.6);     // allow deeper default placement without going extreme
          let spawnY = bottom - radius;
          spawnY = Math.min(spawnY, y);
          const liftMix = Math.min(0.40, 0.12 + prox * 0.26 + Math.random() * 0.16);
          const shadowBias = -10 + Math.random() * 12; // skew darker but allow some lift
          const brightMix = Math.random() < 0.45 ? (0.3 + Math.random() * 0.45) * (0.45 + prox * 0.55) : 0;
          const tint = groundColor.map((c, idx) => {
            const target = highlight[idx];
            let value = c + (target - c) * liftMix + shadowBias;
            if (brightMix > 0) {
              const warm = warmHighlight[idx];
              value += (warm - value) * brightMix;
            }
            value += (Math.random() - 0.5) * 6;
            return Math.round(Math.max(0, Math.min(255, value)));
          });
          const alpha = Math.min(230, 140 + Math.random() * 60 + prox * 40);
          const vx = Math.cos(a) * sp * (Math.random()*0.6 + 0.7);
          const rawLift = Math.abs(Math.sin(a) * sp) * 0.2 + pushUp * 0.45; // base upward impulse from thrust cone
          const cappedLift = Math.min(rawLift, 0.06 + prox * 0.06);         // cap so particles never launch far
          let vy = Math.random() * 0.05;                                    // slight downward drift to hug surface
          vy -= cappedLift;
          vy = Math.max(vy, -0.025 - prox * 0.045);                         // limit upward velocity (negative is upward)
          vy = Math.min(vy, 0.07 + prox * 0.05);                            // keep downward speed gentle
          const lifeBase = 3000 + prox * 520;
          const lifeVariance = 0.45 + Math.random() * 1.75;
          const lifeJitter = Math.random() * 360 - Math.random() * 220;
          const life = Math.max(420, lifeBase * lifeVariance + lifeJitter);
          const maxLife = life * (1.05 + Math.random() * 0.7);
          smoke.push({
            x: spawnX,
            y: spawnY,
            vx,
            vy,
            r: radius,
            life,
            maxLife,
            color: [...tint, alpha],
            prox: prox
          });
        }
      }

      function updateSmoke(dt) {
        for (const p of smoke) {
          p.life -= dt;
          if (p.life <= 0) continue;
          // gravity and slight horizontal drag
          p.vy += g * dt * 0.2; // very light fall
          p.vx *= 0.995;
          p.x += p.vx * dt;
          p.y += p.vy * dt;
          // collide with ground softly
          const gy = terrainY(p.x);
          if (p.y + p.r >= gy) {
            p.y = gy - p.r;
            p.vy *= -0.15;
            p.vx *= 0.85;
          }
        }
        smoke = smoke.filter(p => p.life > 0);
      }

      function drawSmoke() {
        if (smoke.length === 0) return;
        ctx.save();
        ctx.globalCompositeOperation = 'source-over';
        for (const p of smoke) {
          if (p.life <= 0) continue;
          const aLife = Math.max(0, Math.min(1, p.life / p.maxLife));
          const aProx = 0.25 + 0.75 * (p.prox || 0);    // ADJUST proximity alpha gain
          const alphaRaw = (p.color[3]/255) * aProx * (0.25 + 0.75 * aLife);
          const alpha = Math.min(0.95, alphaRaw);       // cap dust opacity at 95%
          ctx.fillStyle = `rgba(${p.color[0]},${p.color[1]},${p.color[2]},${alpha})`;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.r * (1.2 - 0.6*aLife), 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.restore();
      }
      // --- End smoke helpers ---

      // Draw functions
      function drawLander() {
        if (exploded) return;
        ctx.save();
        ctx.translate(lander.x, lander.y);
        ctx.rotate(lander.angle);
        ctx.fillStyle = '#e8e8ff';
        ctx.beginPath();
        ctx.moveTo(0, -lander.height / 2);
        ctx.lineTo(-lander.width / 2, lander.height / 2);
        ctx.lineTo(lander.width / 2, lander.height / 2);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = '#c0c0f0';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-lander.legAttachOffset, lander.height / 2);
        ctx.lineTo(-lander.legFootOffset, lander.height / 2 + lander.legLength);
        ctx.moveTo(lander.legAttachOffset, lander.height / 2);
        ctx.lineTo(lander.legFootOffset, lander.height / 2 + lander.legLength);
        ctx.stroke();
        if (keys['ArrowUp'] && lander.fuel > 0 && !gameOver) {
          ctx.fillStyle = '#ff9933';
          ctx.beginPath();
          ctx.moveTo(0, lander.height / 2);
          ctx.lineTo(-5, lander.height / 2 + 15);
          ctx.lineTo(5, lander.height / 2 + 15);
          ctx.closePath();
          ctx.fill();
        }
        ctx.restore();
      }

      function drawTerrain() {
        // ground fill from terrain profile down to bottom of screen
        ctx.fillStyle = '#332c4a';
        ctx.beginPath();
        ctx.moveTo(0, height);
        for (let x = 0; x <= terrain.width; x += terrain.step) {
          ctx.lineTo(x, terrainY(x));
        }
        if ((terrain.width % terrain.step) !== 0) {
          ctx.lineTo(terrain.width, terrainY(terrain.width));
        }
        ctx.lineTo(terrain.width, height);
        ctx.closePath();
        ctx.fill();

        // landing pad drawn on top
        ctx.fillStyle = `rgba(46, 204, 113, ${padGlowAlpha})`;
        ctx.fillRect(pad.x, pad.y, pad.w, pad.h);

        if (padFlash > 0) {
          const t = (padFlash / 1200);
          ctx.save();
          ctx.lineWidth = 3;
          ctx.strokeStyle = `rgba(255, 255, 255, ${0.2 + 0.6 * Math.abs(Math.sin(t * Math.PI * 4))})`;
          ctx.strokeRect(pad.x - 4, pad.y - 4, pad.w + 8, pad.h + 8);
          ctx.restore();
        }
      }

      function drawHUD() {
        info.textContent = `Level: ${terrain.levelName} | Fuel: ${lander.fuel.toFixed(1)} | Velocity: ${Math.sqrt(lander.vx ** 2 + lander.vy ** 2).toFixed(2)} | Angle: ${(lander.angle * 57.2958).toFixed(0)}°`;
        if (gameOver) {
          ctx.fillStyle = '#ffffff';
          ctx.font = '16px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText(message, width / 2, 28);
        }
      }

      function drawDebugOverlay(k) {
        // Hide the DOM info panel so it doesn't cover the canvas debug overlay
        if (typeof info !== 'undefined' && info) {
          info.style.display = showDebug ? 'none' : 'block';
        }
        if (!showDebug) return;
        // Ensure overlay renders in screen space with full opacity
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0); // identity transform
        ctx.globalAlpha = 1;
        const activeBombs = bombs.filter(b => !b.detonated);
        const nextFuseMs = activeBombs.length === 0 ? null : activeBombs.reduce((min, b) => Math.min(min, b.fuseMs), Infinity);
        const lines = [
          `level: ${terrain.levelName}  worldWidth: ${terrain.width.toFixed(0)}  padX: ${pad.x.toFixed(1)}`,
          `camLag: ${tune.camLag.toFixed(4)}  (Q/A)`,
          `lookGainX: ${tune.lookGainX.toFixed(0)}  (W/S)`,
          `lookGainY: ${tune.lookGainY.toFixed(0)}  (E/D)`,
          `lookCap: ${tune.lookCap.toFixed(0)}  (R/F)`,
          `parallaxFar: ${tune.parallaxFar.toFixed(2)}  (T/G)`,
          `parallaxNear: ${tune.parallaxNear.toFixed(2)}  (Y/H)`,
          `thrustPower: ${lander.thrustPower.toFixed(4)}  (U/J)`,
          `rotateAccel: ${lander.rotateAccel.toExponential(2)}  (I/K)`,
          `rotateDamping: ${lander.rotateDamping.toFixed(2)}  (O/L)`,
          `gravity g: ${g.toFixed(5)}  (P/;)`,
          `bounce: ${tune.bounce.toFixed(2)}  (B/N)`,
          `friction: ${tune.friction.toFixed(2)}  (M/,)`,
          `cam: (${camX.toFixed(1)}, ${camY.toFixed(1)})  lander: (${lander.x.toFixed(1)}, ${lander.y.toFixed(1)})`,
          `vel: (${lander.vx.toFixed(3)}, ${lander.vy.toFixed(3)})  ang: ${lander.angle.toFixed(2)}  angVel: ${lander.angularVelocity.toFixed(5)}`,
          `bombs: ${activeBombs.length}  cooldown: ${bombCooldown.toFixed(0)}ms  next fuse: ${nextFuseMs === null ? '—' : (nextFuseMs / 1000).toFixed(2) + 's'}`,
          `Hold H to toggle this overlay. R to reset.`
        ];
        ctx.font = '14px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace';
        ctx.textBaseline = 'top';
        const padInset = 8, lineH = 18;
        const w = 420, h = lineH * lines.length + padInset * 2;
        ctx.fillStyle = 'rgba(0,0,0,0.70)';
        ctx.fillRect(10, 10, w, h);
        ctx.strokeStyle = '#88d0ff';
        ctx.lineWidth = 2;
        ctx.strokeRect(10.5, 10.5, w-1, h-1);
        ctx.fillStyle = '#e6f7ff';
        for (let i = 0; i < lines.length; i++) {
          ctx.fillText(lines[i], 16, 10 + padInset + lineH * i);
        }
        // Watermark in corner
        ctx.fillStyle = '#88d0ff';
        ctx.fillText('DEBUG ON (H to hide)', 16, 12);
        ctx.restore(); // restore identity transform state for subsequent draws
      }

      function update(dt) {
        updateDebris(dt);
        updateWreckFlames(dt);
        updateBlastSmoke(dt);
        updateWinFx(dt);
        updateSmoke(dt);
        updateBombs(dt);
        if (padFlash > 0) padFlash -= dt;
        padPulsePhase = (padPulsePhase + (dt / PAD_PULSE_PERIOD) * Math.PI * 2) % (Math.PI * 2);
        padGlowAlpha = 0.525 + 0.325 * Math.sin(padPulsePhase);
        if (gameOver) {
          audio.setThrusterActive(false);
          return;
        }
        // rotation momentum: accelerate angular velocity when rotating and apply damping
        if (keys['ArrowLeft']) lander.angularVelocity -= lander.rotateAccel * dt;
        if (keys['ArrowRight']) lander.angularVelocity += lander.rotateAccel * dt;
        lander.angularVelocity *= lander.rotateDamping;
        lander.angle += lander.angularVelocity * dt;
        // thrust
        if (keys['ArrowUp'] && lander.fuel > 0) {
          const ax = Math.sin(lander.angle) * lander.thrustPower;
          const ay = -Math.cos(lander.angle) * lander.thrustPower;
          lander.vx += ax * dt;
          lander.vy += ay * dt;
          lander.fuel -= 0.0005 * dt; // ~2x slower than previous, ~160x slower than original
          if (lander.fuel < 0) lander.fuel = 0;
        }
        // gravity
        lander.vy += g * dt;
        // update position
        lander.x += lander.vx * dt;
        lander.y += lander.vy * dt;
        // horizontal boundaries sized to the current terrain width
        const edgePadding = 12;
        const minX = edgePadding;
        const maxX = Math.max(edgePadding, terrain.width - edgePadding);
        if (lander.x < minX) {
          lander.x = minX;
          if (lander.vx < 0) lander.vx = -lander.vx * tune.bounce;
        }
        if (lander.x > maxX) {
          lander.x = maxX;
          if (lander.vx > 0) lander.vx = -lander.vx * tune.bounce;
        }
        // Engine dust lifted from the ground by thrusters (emits along exhaust ray)
        // ADJUST DUST_MAX_DIST to control when dust starts appearing
        const DUST_MAX_DIST = 70; // px of vertical clearance; farther than this = no dust
        const thrusting = !!keys['ArrowUp'] && lander.fuel > 0;
        audio.setThrusterActive(thrusting);
        if (thrusting) {
          const nozzleOffset = lander.height / 2;
          const originX = lander.x - Math.sin(lander.angle) * nozzleOffset;
          const originY = lander.y + Math.cos(lander.angle) * nozzleOffset;
          const dirX = -Math.sin(lander.angle);
          const dirY = Math.cos(lander.angle);
          const maxRayDistance = DUST_MAX_DIST / Math.max(dirY, 0.05);
          const hit = castThrustRay(originX, originY, dirX, dirY, maxRayDistance);
          if (hit) {
            const verticalDrop = hit.y - originY;
            if (verticalDrop > 0 && verticalDrop < DUST_MAX_DIST) {
              // Proximity factor in [0,1]; stronger very close to ground
              const prox = Math.max(0, 1 - verticalDrop / DUST_MAX_DIST);
              const intensity = prox * prox; // ADJUST ramp shape
              const baseCount = Math.floor(1 + intensity * 30); // ADJUST particle count curve
              const spawnCount = Math.min(60, baseCount);
              const emitX = hit.x;
              const emitY = hit.y - 2;
              const spread = 0.02 + intensity * 0.22; // ADJUST lateral spread
              const pushUp = 0.015 + intensity * 0.10; // ADJUST upward lift
              spawnSmoke(emitX, emitY, spawnCount, spread, pushUp, prox);
            }
          }
        }
        // collisions with terrain
        const contactPoints = getLanderContactPoints();
        let maxPenetration = 0;
        let impactPoint = null;
        for (const pt of contactPoints) {
          const groundY = terrainY(pt.x);
          const penetration = pt.y - groundY;
          if (penetration > maxPenetration) {
            maxPenetration = penetration;
            impactPoint = { ...pt, groundY };
          }
        }
        if (maxPenetration > 0) {
          lander.y -= maxPenetration;
          const settledPoints = getLanderContactPoints();
          const footContacts = settledPoints
            .filter(pt => pt.type === 'foot')
            .map(pt => ({ ...pt, groundY: terrainY(pt.x) }));
          const touchingFeet = footContacts.filter(pt => Math.abs(pt.groundY - pt.y) < 1);
          const speed = Math.hypot(lander.vx, lander.vy);
          const uprightTol = 0.26; // radians (~15°)
          const normalizedAngle = ((lander.angle % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
          const uprightNow = normalizedAngle < uprightTol || normalizedAngle > Math.PI * 2 - uprightTol;
          const padLeft = pad.x - 1;
          const padRight = pad.x + pad.w + 1;
          const onPad = touchingFeet.length > 0 && touchingFeet.every(pt => pt.x >= padLeft && pt.x <= padRight);
          const okSpeed = speed < 0.09;
          const okVx = Math.abs(lander.vx) < 0.07;
          const okVy = lander.vy < 0.07;
          if (onPad && uprightNow && okSpeed && okVx && okVy) {
            landed = true;
            shouldRegen = true;
            nextLevelIndex = (currentLevelIndex + 1) % levels.length;
            gameOver = true;
            exploded = false;
            lander.vx = 0;
            lander.vy = 0;
            lander.angularVelocity = 0;
            const upcoming = levels[nextLevelIndex].name;
            message = `Nice landing! Press R to explore ${upcoming}`;
            const touchdownY = touchingFeet.length
              ? touchingFeet.reduce((min, pt) => Math.min(min, pt.groundY), touchingFeet[0].groundY)
              : terrainY(lander.x);
            spawnWinFx(lander.x, touchdownY - 12);
            padFlash = 1200;
            audio.stopThrusterImmediate();
            audio.playWinChime();
          } else {
            const crashX = impactPoint ? impactPoint.x : lander.x;
            const crashY = impactPoint ? impactPoint.groundY : terrainY(lander.x);
            spawnExplosion(crashX, crashY, lander.vx, lander.vy);
          }
        }
      }

      function loop(timestamp) {
        if (!lastTime) lastTime = timestamp;
        const dt = timestamp - lastTime;
        lastTime = timestamp;
        update(dt);
        ctx.clearRect(0, 0, width, height);
        // solid sky so CSS doesn’t bleed through
        ctx.fillStyle = '#000010';
        ctx.fillRect(0, 0, width, height);
        // Parallax background in screen space (no camera transforms here)
        // --- Camera follow with smoothing and look-ahead ---
        if (camX === null) { camX = lander.x; camY = lander.y; }
        const lookX = Math.max(-tune.lookCap, Math.min(tune.lookCap, lander.vx * tune.lookGainX));
        const lookY = Math.max(-tune.lookCap, Math.min(tune.lookCap, lander.vy * tune.lookGainY));
        const targetX = lander.x + lookX;
        const targetY = lander.y + lookY;
        const k = Math.min(1, dt * tune.camLag);
        camX += (targetX - camX) * k;
        camY += (targetY - camY) * k;
        const halfViewX = width / 2;
        if (terrain.width <= width) {
          camX = terrain.width / 2;
        } else {
          const minCamX = halfViewX;
          const maxCamX = terrain.width - halfViewX;
          camX = Math.max(minCamX, Math.min(maxCamX, camX));
        }
        const groundFloor = height * 0.5;
        const ceiling = height * 0.15;
        camY = Math.max(ceiling, Math.min(groundFloor, camY));
        // --- End camera follow ---
        tileLayer(bgFar,  -camX * tune.parallaxFar, -camY * tune.parallaxFar);
        tileLayer(bgNear, -camX * tune.parallaxNear, -camY * tune.parallaxNear);

        // Center the world so the lander stays in the middle
        ctx.save();
        ctx.translate(width / 2 - camX, height / 2 - camY);
        drawTerrain();
        drawBombs();
        drawSmoke();
        drawBlastSmoke();
        drawWreckFlames();
        drawLander();
        drawDebris();
        drawWinFx();
        ctx.restore();
        drawHUD();
        drawDebugOverlay(k);
        requestAnimationFrame(loop);
      }

      generateTerrain(currentLevelIndex);
      resetGame();
      requestAnimationFrame(loop);
    })();
  </script>
</body>
</html>
